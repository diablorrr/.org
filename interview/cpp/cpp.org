* c和cpp的区别？ [[https://www.cnblogs.com/binarch/p/17449410.html][参考]]
- c是面向过程的语言，cpp既可以面向过程也能面向对象

* static关键字的用法？ [[https://www.cnblogs.com/binarch/p/17462001.html][参考]]
1. 全局作用域中，修饰变量[fn:1]、函数为静态，限制本文件内使用
2. 方法中，修饰局部变量；第一次访问时初始化，程序结束时销毁
3. 类中，修饰成员变量[fn:2]、成员函数；被类持有，而非类的对象持有

* 介绍下std::map？使用场景？可以修改key吗？底层使用什么数据结构？如何实现从大到小排序？ [[https://www.cnblogs.com/binarch/p/17510199.html][参考]]
- std::map是有序的关联容器，存储key-value对，key唯一有序
- key是const的，不可以修改；但能通过erase + insert间接实现
- 有序数据的情况，如：范围查找
- 底层使用红黑树，红黑树是一种自平衡的二叉树，确保插入、删除、查找的时间复杂度为 O(logn)
- 设置第3个模板参数来自定义排序规则，替换std::less<key>为std::greater<key>；也能通过仿函数、lambda表达式实现

* 介绍下std::unordered_map？使用场景？底层实现？自定义类型作为key？[[https://cppreference.com/w/cpp/container/unordered_map/unordered_map.html][参考]]
- C++11添加的无序的关联容器，存储key-value对，key唯一
- 高效查询
- 底层是使用哈希表实现的，插入、删除、查找的平均时间复杂度为O(1)
- 需要实现计算key的hash函数、比较key的函数

* 介绍下static_cast和dynamic_cast？为什么不建议使用static_cast对类进行向下转型？
- dynamic_cast提供运行时检查，用于向下转型(在继承体系中，将基类指针/引用安全的转换为派生类指针/引用)；static_cast提供编译时检查，非向下转型的情况使用；
- static_cast不会提供运行时检查，因此对类进行向下转型总是成功，可能产生未定义行为(eg：[fn:3])；不同于dynamic_cast向下转型失败会返回空指针(指针)/抛出bad_cast异常(引用)，以此保证安全

* push_back和emplace_back的区别？
- 适用于已构造的对象，需要 *一次拷贝/移动* 将对象放入vector；使用构造新对象，在vector中 *直接构造，无需拷贝/移动*
* 向下转型和虚函数如何选择？
- 只在以下情况使用向下转型
  1. 无法在基类中增加虚函数(eg：基类是标准库)
  2. 访问派生类特有的函数(eg：该函数只存在于派生类)

* 类中的变量、函数是如何存储的？调用成员函数，如何识别是哪个对象？ [[https://tangocc.github.io/2018/03/20/cpp-class-memory-struct/][参考]]
- 存储区域：
  1. 非static成员变量 => 栈/堆
  2. static成员变量   => 静态存储区
  3. 成员函数         => 代码段
- 编译器在编译阶段，将成员函数非成员化：将this指针作为函数的第1个参数，通过this指针识别对象，也能找到对象的成员变量[fn:4]

* TODO 内存泄漏有哪几种方式？
- 用裸指针指向堆中动态分配的内存，没有即时释放指针：创建/释放指针之间的代码出现
  1. 返回
  2. 抛出异常

* 为什么构造函数加锁，析构函数不加锁？
- 对象的构造在单线程中进行，此时没有其他线程使用该对象；而对对象析构时，可能其他线程还在使用对象
* 什么是移动语义？什么是右值引用？右值引用的使用场景？
- (偷资源)转移资源的所有权，减少了拷贝的开销
- 用右值初始化的引用，有3个性质：
  1. 延长右值的生命周期与右值引用一致
  2. 非const的右值引用允许你修改右值
  3. 右值引用是左值
- 作为函数参数 => 实现函数重载

* 什么时候触发移动构造和移动赋值函数？什么情况下编译器会合成移动构造和移动赋值函数？介绍下std::move？
- 用于构造或赋值的参数是右值(字面值或临时值)
- 以下2点满足：
  1. 没有用户声明的拷贝构造、拷贝赋值、析构、移动构造、移动赋值
  2. 非静态成员变量可移动[fn:6]
- 将左值转换为右值 => 用于invoke移动语义(call移动构造或移动赋值)

* 介绍下std::unique_ptr？传入std::unique_ptr到函数？[[https://www.learncpp.com/cpp-tutorial/stdunique_ptr/][参考]]
- 独占资源的智能指针；没有拷贝构造和拷贝赋值函数，只能转移资源的所有权(使用移动语义)[fn:7]
- 应该传入裸指针(代表着资源)而不是std::unique_ptr，因为我们并不想转移资源所有权

* 什么是异常安全？介绍下std::shared_ptr？最佳实践？什么是循环引用？如何解决？什么是std::weak_ptr？[[https://www.learncpp.com/cpp-tutorial/circular-dependency-issues-with-stdshared_ptr-and-stdweak_ptr/][参考]]
- 异常抛出时，代码能保证避免资源泄漏、确保数据处于一致性状态
- 共享资源的智能指针；内部除了有指向资源的指针，还有指针指向控制块，内部有引用计数，表示有多少个共享指针指向资源，当引用计数归0时，才会释放资源
- 从同一资源创建多个共享指针 => 多次释放 => 段错误[fn:8] => 最佳实践：使用拷贝
- 两个或多个对象通过内部的智能指针互相指向对方 => 导致引用计数无法归0，引发内存泄漏
- 使用std::weak_ptr作为内部的智能指针
- 只用于观察和访问std::shared_ptr但不持有资源的指针[fn:9]

* std::auto_ptr的缺陷？[[https://www.learncpp.com/cpp-tutorial/introduction-to-smart-pointers-move-semantics/][参考]]
- 它的移动语义是通过拷贝构造函数、拷贝赋值运算符实现的 :: 在作为参数 值传递到函数中，函数调用方的资源被移动到函数中，函数结束时，又导致auto_ptr释放资源，最终函数调用方再想访问资源会导致未定义行为
- 它删除资源是通过delete，对动态数组应该使用delete []

* 在编译时编译器对模板做了什么？模板替换发生在什么时期？[[https://blog.csdn.net/qq_45014727/article/details/130937135][参考]]
- 两阶段检查：
  1. 在模板定义阶段，检查语法、非依赖名称(不依赖类型参数的部分)[fn:10]
  2. 在模板实例化阶段，进行模板类型替换；检查依赖名称(依赖类型参数的部分)[fn:11]
- 发生在模板实例化阶段

* tmp
模板使用的时候才会实例化
实例化模板：编译器将模板副本中的类型参数替换为实际的类型
最佳实践：单头文件编写

类型参数 非类型参数(必须是constexpr的)

全特化：全部参数特例化
偏特化：部分模板特例化
优先级：普通非模板函数 模板全特化 模板偏特化



* Footnotes
[fn:11]
依赖名称：
T t; t.foo();                    => 检查T中是否有foo()成员
T add(T a, T b) {return a + b; } => 检查T是否支持operator+

[fn:10]
非依赖名称：和T不相关的，如std::cout，此时会检查是否包含<iostream>
语法：尖括号是否配对，是否加;等

[fn:9]
不会增加std::shared_ptr的共享计数

[fn:8]
假设从资源r分别创建共享指针a、b；则a、b有独立的控制块，它们的引用计数不同步

[fn:7]
eg：uptr2 = std::move(uptr1);

[fn:1]
生命周期贯穿整个程序运行期间

[fn:2]
生命周期贯穿整个程序运行期间

[fn:3]
基类指针本身指向的可能是基类，也可能是子类，若是子类对其进行向下转型，可能产生未定义行为

[fn:4]
e.print() => print(&e)

[fn:5]
A中的成员变量a，在B、C中存在2份
A中的虚函数，被B、C override

[fn:6]
内置类型：移动 = 拷贝
如：类类型std::string定义了移动构造和移动赋值
