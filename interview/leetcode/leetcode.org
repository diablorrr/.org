* 子串和子序列
** 前缀和
核心思想：任何子序列的和都可以表示为两个前缀和的差
可以用 *数组、变量* 表示前缀和
- 数组
  #+begin_example
  数组为nums
  前缀和数组为s，s[0]=0
  则前缀和数组的长度为：nums.size()+1
  nums[i]=s[i+1]-s[i]
  #+end_example
- 变量
* 定长滑动窗口
假设窗口大小为k
核心思想：入- 更新- 出
入：right元素进入，判断窗口是否为k（left = right -k + 1，因此left < 0代表left不存在，那么窗口大小就不为k了），没到k，继续入
更新：窗口大小为k，更新
出：left出去
* 不定长滑动窗口
入 [出] 更新
right入；若不符合条件了，left出；更新
- 题目说求子数组或子串，意味着数据 *不满足单调性* ，不使用双指针，只能使用滑动窗口；一般不定长滑动窗口是根据某种状态来移动左右窗口边界，比如求窗口内元素和为某个值，若数据中有负数，则不可使用，因为此时左边界会往左走，只能使用前缀和
* 快慢双指针？应用场景？
- 从同一方向开始移动，fast指针移动2，slow移动1
  + 设开始节点到环起始节点距离a，环起始节点到相遇节点距离b，相遇节点到环起始节点
    距离c；又fast速度是slow两倍
  + 2(a + b) = a + b + c + b   => 2 x slow移动距离 = fast移动距离
  + 化简：a = c                => fast回到开始节点，每次移动1，slow继续每次移动1，它们会在环起始节点相遇
- 应用场景：找链表中点
* 相向双指针？如何使用？
- 通过两个指针(索引)获取一定信息[fn:1]，根据信息结果，缩小处理数据范围 => 高效
- 一般情况下数据 *满足单调性(有序)* ，定义两个指针(索引)在两侧，相向移动
* 红蓝染色法(二分查找)使用场景？
- 元素非递减有序/部分有序[fn:2]，时间复杂度要求log n
- 核心： *根据while中的if语句确定红蓝区意义* ，然后进行对应染色。红蓝区的意义可以是红色为<target的范围，蓝色为>target的范围；也可以是其他意义[fn:3]
  1. 循环不变量：(闭区间情况) left-1始终为红色，right+1始终为蓝色
  2. 区间形式：闭区间、开区间、左开右闭、左闭右开
* 反转链表
- 设置哨兵节点dummy统一操作；pre、cur、nxt三个指针(cur用于反转指向，nxt只用于定位！)
- 最终状态
  1. pre在反转区域的最后一个位置
  2. cur在反转区域的下一个位置
* 递归
- 循环和递归都是在调用同一份代码，通过不断解决小问题从而解决原问题，区别在于循环的每次循环就是提出小问题就解决，递归每次调用自身就是将原问题拆解为小问题(递)，返回时解决小问题(归)，因为递归解决的是嵌套 问题；在返回值方面，循环每次将值返回到当前问题，递归将值返回给上一个问题；再说一些两者类似的地方，递归的边界条件类似循环中的条件判断，不同之处在于循环每次提出小问题就判断一次，递归到最小问题时才进行判断，递归每次调用自身就类似循环每次进入下一次循环；通过循环来理解递归更容易
* 二叉树 递归
- 两种方法：
  1. 递归的时候传入节点                             => 通过归的值得到结果
  2. 递归的时候传入节点、其他变量；同时存在全局变量 => 不断更新全局变量，全局变量的值即为结果
* 二叉树 最大深度 相同 对称 平衡
# 二叉树的解法，函数式编程，假设知道某些基础算法，在那些算法基础上解题
- 对称 :: 使用 *相同的变体* 来判断
- 平衡 :: 使用 *最大深度* 来判断
* 二叉树 右视图
- 先右后左(右边遮蔽左边)，比较当前深度和当前整棵树最大深度(结果数组的长度)，若相等(意味着第一次到达这个深度)，则加入结果数组
* 二叉搜索树判别
- 核心思想：二叉搜索树，进入root->left缩小范围右边界为root值，进入root->right缩小范围左边界为root值；root的范围应该是无限小和无限大
- 中序遍历得到递增序列
* 二叉树层序遍历
- 使用队列：队列相当于是工作队列(里面有工作就取出完成，否则中止 => 以此判断终止条件)
* 回溯
- 通过 *递归* 尝试 *所有可能解* 的算法
- 核心思想：遍历这颗搜索树(二叉树或N叉树)，每次到搜索树的一个节点就记录到path
  + 遍历搜索树，我们使用dfs(i)，dfs(i)中的i为一个范围(>=i 或 <=i)， 而在dfs(i)内的代码出现的i为当前处理的点
* 剪枝
- 通过条件判断，减少某些递归调用
* 子集型回溯
- 输入视角：选或不选(就是个二叉树) => 对二叉树遍历 => 结果位于叶子节点
- 输出视角：选哪个  (就是个N叉树)  => 对N叉树遍历(nums为输入，第一个分支可选择数的范围是nums.size()，第二个分支的范围是nums.size()-1...)  => 结果位于每个节点 => *搜索树每一层的结果数量是相等的*
  + for循环其实就是遍历一般树的每一个子树，然后在每个子树中使用dfs
* 组合型回溯
- 适合使用 输出视角
- *子集型回溯的基础* 上取特定的组合
* 排列型回溯
- 适合使用 输出视角的变体(对N叉树遍历：每个分支可选择数的范围都是nums.size())，因此我们需要on_path(需要初始化on_path(len)，覆盖的形式使用)来记录nums中的某个数选过没
- 最终结果在叶子节点
* 记忆化搜索
- 本质就是 回溯 + 记忆化
- 自顶向下 计算 搜索树
* 动态规划
- 将 记忆化搜索 翻译成 递推
  1. dfs      -> f数组
  2. 递归     -> 循环
  3. 递归边界 -> 数组初始值
- 自底向上(递推：只有递没有归) 计算 搜索树
* 01背包？
* 完全背包？

* 历史信息
** 变量
获取历史信息（最大值，最小值）
** int数组
用于获取历史信息（特别适合存放char，因为char对应[[id:dfb83e03-e939-4a01-87b5-54aaa92fd424][ASCII]]中的数字，使得我们可以通过数学计算来获取关系）
** 哈希表
用于快速获取历史信息（是否存在、key-value附加信息）
** 单调栈
用于获取上一个值的历史信息（上一个最大/最小）
- 单调性：栈上面的数<栈下面的数(记录t[i]前会把所有<=t[i]的数去掉)
** 单调队列
用于获取一个范围内的历史信息（范围内最大/最小）
1. 右边入（同时维护单调性）
2. 左边出
3. 记录（根据队首）


* Footnotes

[fn:1]
eg：在两数之和中，这个信息就是两个指针的值与target的比较

[fn:2]
比如用红色染有序部分，蓝色染无序部分

[fn:3]
162.寻找峰值中红色代表有序部分，蓝色代表无序部分
