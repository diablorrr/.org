* -------------------------------------------------------------------------------------------------------
* 哈希表？
- 对历史记录的快速查找
* 快慢双指针？应用场景？
- 从同一方向开始移动，fast指针移动2，slow移动1
  + 设开始节点到环起始节点距离a，环起始节点到相遇节点距离b，相遇节点到环起始节点
    距离c；又fast速度是slow两倍
  + 2(a + b) = a + b + c + b   => 2 x slow移动距离 = fast移动距离
  + 化简：a = c                => fast回到开始节点，每次移动1，slow继续每次移动1，它们会在环起始节点相遇
- 应用场景：找链表中点
* 相向双指针？如何使用？
- 通过两个指针(索引)获取一定信息[fn:1]，根据信息结果，缩小处理数据范围 => 高效
- 一般情况下数据 *满足单调性(有序)* ，定义两个指针(索引)在两侧，相向移动
* 前后缀分解？如何使用？
- 前/后缀代表着 最前点/最后点到当前点的信息
- 需要定义 前/后缀数组 记录信息
* 不定长滑动窗口？如何使用？
- 一般问题是求一个范围内的信息是否符合条件，移动右边界增大范围，移动左边界缩小范围
- 题目说求子数组或子串，意味着数据 *不满足单调性* ，不使用双指针，只能使用滑动窗口
* 哈希表？
1. 不重复元素
2. 快速查询元素是否存在
* 红蓝染色法(二分查找)使用场景？
- 元素非递减有序/部分有序[fn:2]，时间复杂度要求log n
- 核心： *根据while中的if语句确定红蓝区意义* ，然后进行对应染色。红蓝区的意义可以是红色为<target的范围，蓝色为>target的范围；也可以是其他意义[fn:3]
  1. 循环不变量：(闭区间情况) left-1始终为红色，right+1始终为蓝色
  2. 区间形式：闭区间、开区间、左开右闭、左闭右开
* 反转链表？
- 设置哨兵节点dummy统一操作；pre、cur、nxt三个指针(cur用于反转指向，nxt只用于定位！)
- 最终状态
  1. pre在反转区域的最后一个位置
  2. cur在反转区域的下一个位置
* 递归？
- 循环和递归都是在调用同一份代码，通过不断解决小问题从而解决原问题，区别在于循环的每次循环就是提出小问题就解决，递归每次调用自身就是将原问题拆解为小问题(递)，返回时解决小问题(归)，因为递归解决的是嵌套 问题；在返回值方面，循环每次将值返回到当前问题，递归将值返回给上一个问题；再说一些两者类似的地方，递归的边界条件类似循环中的条件判断，不同之处在于循环每次提出小问题就判断一次，递归到最小问题时才进行判断，递归每次调用自身就类似循环每次进入下一次循环；通过循环来理解递归更容易
* 二叉树 递归？
- 两种方法：
  1. 递归的时候传入节点                             => 通过归的值得到结果
  2. 递归的时候传入节点、其他变量；同时存在全局变量 => 不断更新全局变量，全局变量的值即为结果
* 二叉树 最大深度 相同 对称 平衡？
# 二叉树的解法，函数式编程，假设知道某些基础算法，在那些算法基础上解题
- 对称 :: 使用 *相同的变体* 来判断
- 平衡 :: 使用 *最大深度* 来判断
* 二叉树 右视图？
- 先右后左(右边遮蔽左边)，比较当前深度和当前整棵树最大深度(结果数组的长度)，若相等(意味着第一次到达这个深度)，则加入结果数组
* 二叉搜索树判别？
- 核心思想：二叉搜索树，进入root->left缩小范围右边界为root值，进入root->right缩小范围左边界为root值；root的范围应该是无限小和无限大
- 中序遍历得到递增序列
* 二叉树层序遍历？
- 使用队列：队列相当于是工作队列(里面有工作就取出完成，否则中止 => 以此判断终止条件)
* 回溯？
- 通过 *递归* 尝试 *所有可能解* 的算法
- 核心思想：遍历这颗搜索树(二叉树或N叉树)，每次到搜索树的一个节点就记录到path
  + 遍历搜索树，我们使用dfs(i)，dfs(i)中的i为一个范围(>=i 或 <=i)， 而在dfs(i)内的代码出现的i为当前处理的点
* 剪枝？
- 通过条件判断，减少某些递归调用
* 子集型回溯？
- 输入视角：选或不选(就是个二叉树) => 对二叉树遍历 => 结果位于叶子节点
- 输出视角：选哪个  (就是个N叉树)  => 对N叉树遍历(nums为输入，第一个分支可选择数的范围是nums.size()，第二个分支的范围是nums.size()-1...)  => 结果位于每个节点 => *搜索树每一层的结果数量是相等的*
  + for循环其实就是遍历一般树的每一个子树，然后在每个子树中使用dfs
* 组合型回溯？
- 适合使用 输出视角
- *子集型回溯的基础* 上取特定的组合
* 排列型回溯？
- 适合使用 输出视角的变体(对N叉树遍历：每个分支可选择数的范围都是nums.size())，因此我们需要on_path(需要初始化on_path(len)，覆盖的形式使用)来记录nums中的某个数选过没
- 最终结果在叶子节点
* 记忆化搜索？
- 本质就是 回溯 + 记忆化
- 自顶向下 计算 搜索树
* 动态规划？
- 将 记忆化搜索 翻译成 递推
  1. dfs      -> f数组
  2. 递归     -> 循环
  3. 递归边界 -> 数组初始值
- 自底向上(递推：只有递没有归) 计算 搜索树
* 01背包？
* 完全背包？
* 单调栈？
- 两个特性
  1. 栈：后进先出
  2. 单调性：栈上面的数<栈下面的数(记录t[i]前会把所有<=t[i]的数去掉)
- 使用场景：在计算过程中，要使用上/下一个更大/小的元素
* 单调队列？
- 两个特性
  1. 双端队列
  2. 单调性：队首到队尾是单调递减的：在队尾加入元素时，根据大小关系将元素弹出
* -------------------------------------------------------------------------------------------------------
* 定长滑动窗口？

* Footnotes

[fn:1]
eg：在两数之和中，这个信息就是两个指针的值与target的比较

[fn:2]
比如用红色染有序部分，蓝色染无序部分

[fn:3]
162.寻找峰值中红色代表有序部分，蓝色代表无序部分
