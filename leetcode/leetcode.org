#+title: Leetcode
#+startup: show2levels

* plan
** [ ] 一刷 leetcode hot100
SCHEDULED: <2025-03-20 四>


* [[https://leetcode.cn/problems/two-sum/description/?envType=study-plan-v2&envId=top-100-liked][1.两数之和]] [0/3]
- [ ] 一刷
- [ ] 二刷
- [ ] 三刷
** 解法1:暴力枚举
#+begin_src cpp :results output :includes '(<vector> <iostream>) :main no :namespaces std
vector<int> twoSum(vector<int>& nums, int target){
    int i,j;
    for(i=0; i < nums.size()-1; ++i){
        for(j=i+1; j < nums.size(); ++j){
            if(nums[i]+nums[j] == target){
                return {i,j};
            }
        }
    }
    return {};
}

int main(){
    vector<int> nums = {2,4,6,7};
    int target = 9;
    vector<int> vec = twoSum(nums, target);
    for (auto v : vec){
        cout << v << endl;
    }
}

#+end_src

#+RESULTS:
: 0
: 3

* [[https://leetcode.cn/problems/group-anagrams/?envType=study-plan-v2&envId=top-100-liked][49.字母异位词分组]] [0/3]
- [ ] 一刷
- [ ] 二刷
- [ ] 三刷
** 解法1:排序
#+begin_src cpp :results output :includes '(<vector> <iostream> <algorithm> <unordered_map>) :main no :namespaces std
vector<vector<string>> groupAnagrams(vector<string>& strs) {
    unordered_map<string, vector<string>> mp;
    for(auto& str:strs){
        string key = str;
        sort(key.begin(), key.end());
        mp[key].emplace_back(str);
    }

    vector<vector<string>> ans;
    for(auto it=mp.begin(); it!=mp.end(); ++it){
        ans.emplace_back(it->second);
    }
    return ans;
}

int main(){
    vector<string> strs = {"eat", "tea", "tan", "ate", "nat", "bat"};
    auto ga = groupAnagrams(strs);
    for(auto& g:ga){
        for(auto& s:g){
            cout << s << endl;
        }
    }
}
#+end_src

#+RESULTS:
: bat
: tan
: nat
: eat
: tea
: ate
*** 复杂度
- 字符串数量m，平均字符串长度n
- 复杂度消耗在排序
- 时间复杂度 :: O(mnlogn)
- 空间复杂度 ::
** 解法2:ASCII码作为hash map的key
- 思路 :: 将26个字母通过[[id:bc0b7272-ae2a-43e6-9727-0992493ddc04][ASCII]]映射到string，string为26个数字组成；将string作为hash map的key，以此分组
#+begin_src cpp :results output :includes '(<vector> <iostream> <algorithm> <unordered_map>) :main no :namespaces std
class Solution {
public:
vector<vector<string>> groupAnagrams(vector<string>& strs) {
    vector<vector<string>> res;
    unordered_map<string, vector<string>> u_mapRes;
    for(auto& str:strs){
        string count(26, 0);
        for(auto& c:str){
            count[c-'a'] += 1;
        }
        u_mapRes[count].push_back(str);
    }
    for(auto& pair:u_mapRes){
        res.push_back(pair.second);
    }
    return res;
}
};

int main(){
    vector<string> strs = {"eat", "tea", "tan", "ate", "nat", "bat"};
    Solution sol;
    auto ga = sol.groupAnagrams(strs);
    for(auto& g:ga){
        for(auto& s:g){
            cout << s << endl;
        }
    }
}
#+end_src

#+RESULTS:
: bat
: tan
: nat
: eat
: tea
: ate
*** 复杂度
- 字符串数量m，平均字符串长度n
- 复杂度消耗在排序
- 时间复杂度 :: O(mn)
- 空间复杂度 ::
*** 参考
[[https://www.bilibili.com/video/BV1Fm42157HG/?spm_id_from=333.337.search-card.all.click&vd_source=4441bc96046659b39d059d583f36ff52][【小白都能听懂的算法课】【力扣】【LeetCode 49】]]

* [[https://leetcode.cn/problems/longest-consecutive-sequence/description/?envType=study-plan-v2&envId=top-100-liked][128.最长连续序列]] [/]
** 解法1:unordered_set
- 思路 :: 遍历数组，通过左边数是否存在判断是否为序列开始；通过判断右边是否存在持续更新数组长度
#+begin_src cpp :results output :includes '(<vector> <iostream> <algorithm> <unordered_set>) :main no :namespaces std
class Solution {
public:
    int longestConsecutive(vector<int>& nums) {
        int max_len = 0;
        unordered_set<long long> u_set;
        for(int i = 0; i < nums.size(); ++i){
            u_set.emplace(nums[i]);
        }
        for(auto& num:u_set){
            if(u_set.find(num - 1) == u_set.end()){
                int len = 0;
                while(u_set.find(num + len) != u_set.end()){
                    ++len;
                    max_len = max(max_len, len);
                }
            }
        }
        return max_len;
    }
};

int main(){
    vector<int> nums = {0,3,7,2,5,8,4,6,0,1};
    Solution sol;
    cout << sol.longestConsecutive(nums) << endl;
}
#+end_src

#+RESULTS:
: 9
*** 复杂度
- 时间复杂度 :: O(n)
- 空间复杂度 ::
*** 参考
[[https://www.bilibili.com/video/BV1qqHKetETN?spm_id_from=333.788.videopod.sections&vd_source=4441bc96046659b39d059d583f36ff52][【大厂程序员带你刷力扣】【LeetCode 128】]]

* [[https://leetcode.cn/problems/move-zeroes/?envType=study-plan-v2&envId=top-100-liked][283.移动零]] [/]
** 解法1:双指针
- 思路 :: 右指针遍历，遇到0元素移动；遇到非0元素与左指针交换，左指针移动一个元素
#+begin_src cpp :results output :includes '(<vector> <iostream> <algorithm> <unordered_set>) :main no :namespaces std
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int left = 0;
        for(int right = 0; right < nums.size(); ++right){
            if(nums[right]){
                int tmp = nums[right];
                nums[right] = nums[left];
                nums[left] = tmp;
                ++left;
            }
        }
    }
};

int main(){
    vector<int> nums = {0,1,0,3,12};
    Solution sol;
    sol.moveZeroes(nums);
    for(auto& num:nums){
        cout << num << endl;
    }
}
#+end_src

#+RESULTS:
: 1
: 3
: 12
: 0
: 0

*** 复杂度
- 时间复杂度 ::
- 空间复杂度 :: O(1)
*** 参考
[[https://www.bilibili.com/video/BV1tZtVeUE2o/?spm_id_from=333.337.search-card.all.click&vd_source=4441bc96046659b39d059d583f36ff52][【力扣hot100】【LeetCode 283】]]

* [[https://leetcode.cn/problems/container-with-most-water/?envType=study-plan-v2&envId=top-100-liked][11.盛最多水的容器]] [/]
** 解法1:双指针
- 思路 :: 指针在数组两端，只有移动指针值小的，面积才可能变大；因此指针移动策略为移动指针值小的那端指针
#+begin_src cpp :results output :includes '(<vector> <iostream> <algorithm> <unordered_set>) :main no :namespaces std
class Solution {
public:
    int maxArea(vector<int>& height) {
        int L = 0, R = height.size() - 1;
        int max_area = 0;
        while (L < R){
            int area = (R - L) * min(height[L], height[R]);
            max_area = max(max_area, area);
            if (height[L] < height[R]){
                ++L;
            } else {
                --R;
            }
        }
        return max_area;
    }
};

int main(){
    vector<int> height = {1,8,6,2,5,4,8,3,7};
    Solution sol;
    cout << sol.maxArea(height) << endl;
}
#+end_src

#+RESULTS:
: 49

*** 复杂度
*** 参考
[[https://www.bilibili.com/video/BV1Dm411k78M/?spm_id_from=333.337.search-card.all.click&vd_source=4441bc96046659b39d059d583f36ff52][【小白都能听懂的算法课】【力扣】【Leetcode11】]]

* [[https://leetcode.cn/problems/3sum/?envType=study-plan-v2&envId=top-100-liked][15.三数之和]] [/]
** 解法1:双指针
- 思路 :: 排序数字；第一个数从左到右遍历(需去重)；同时第二、三个数用双指针控制，第二个数向第三个数遍历，期间三数之和相加结果符合要求，就放入结果数组；相加结果小了，移动第二个数的指针；大了，移动第三个数的指针
#+begin_src cpp :results output :includes '(<vector> <iostream> <algorithm> <unordered_set>) :main no :namespaces std
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        vector<vector<int>> res;
        sort(nums.begin(), nums.end());
        for (int a = 0; a < nums.size(); ++a){
            if (a > 0 && nums[a] == nums[a - 1]){
                continue;
            }
            int left = a + 1, right = nums.size() - 1;
            while (left < right) {
                if (nums[a] + nums[left] + nums[right] == 0){
                    res.push_back({nums[a], nums[left], nums[right]});
                    ++left;
                    while (left < right && nums[left - 1] == nums[left]){
                        ++left;
                    }
                } else if (nums[a] + nums[left] + nums[right] < 0) {
                    ++left;
                } else {
                    --right;
                }
            }
        }
        return res;
    }
};

int main(){
    vector<int> nums = {-1,0,1,2,-1,-4};
    Solution sol;
    auto vec = sol.threeSum(nums);
    for (auto& v:vec) {
        for (auto& vv:v) {
            cout << vv << endl;
        }
    }
}
#+end_src

#+RESULTS:
: -1
: -1
: 2
: -1
: 0
: 1

*** 复杂度
- 时间复杂度 :: O(n^2)
- 空间复杂度 ::
*** 参考
[[https://www.bilibili.com/video/BV1Ux4y127uZ/?spm_id_from=333.337.search-card.all.click&vd_source=4441bc96046659b39d059d583f36ff52][【小白都能听懂的算法课】【力扣】【Leetcode15】]]

* [[https://leetcode.cn/problems/trapping-rain-water/?envType=study-plan-v2&envId=top-100-liked][42.接雨水]] [/]
** 解法1:双指针
- 思路 :: 每一个点能存储雨水的量取决于 该点左右较大边界中较小的一个 与自身的差值；根据木桶效应，左右边界中较小的一方移动，移动过程中更新自身的值，并与当前点的差值更新总的雨水量
#+begin_src cpp :results output :includes '(<vector> <iostream> <algorithm> <unordered_set>) :main no :namespaces std
class Solution {
public:
    int trap(vector<int>& height) {
        int res = 0;
        int left = 0, right = height.size() - 1;
        int maxL = height[left], maxR = height[right];
        while (left < right) {
            if (maxL < maxR) {
                ++left;
                maxL = max(maxL, height[left]);
                res += (maxL - height[left]);
            } else {
                --right;
                maxR = max(maxR, height[right]);
                res += (maxR - height[right]);
            }
        }
        return res;
    }
};

int main(){
    Solution sol;
    vector<int> height = {0,1,0,2,1,0,1,3,2,1,2,1};
    cout << sol.trap(height) << endl;
}

#+end_src

#+RESULTS:
: 6

*** 复杂度
- 时间复杂度 :: O(n)
- 空间复杂度 :: O(1)
*** 参考
[[https://www.bilibili.com/video/BV1CmtZePErE/?spm_id_from=333.337.search-card.all.click&vd_source=4441bc96046659b39d059d583f36ff52][【力扣hot100】【LeetCode 42】]]
** TODO 解法2:辅助数组
- 思路 ::
*** 复杂度
- 时间复杂度 :: O(n)
- 空间复杂度 :: O(n)
*** 参考
[[https://www.bilibili.com/video/BV1CmtZePErE/?spm_id_from=333.337.search-card.all.click&vd_source=4441bc96046659b39d059d583f36ff52][【力扣hot100】【LeetCode 42】]]

* [[https://leetcode.cn/problems/longest-substring-without-repeating-characters/?envType=study-plan-v2&envId=top-100-liked][3.无重复字符的最长子串]] [/]
** 解法1:滑动窗口
- 思路 :: 右边界遍历一遍，不重复的元素加入窗口，重复的元素从左边界删除
#+begin_src cpp :results output :includes '(<vector> <iostream> <algorithm> <unordered_set>) :main no :namespaces std
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        unordered_set<char> u_set;
        int res = 0;
        int cur_window = 0;
        for (int left = 0, right = 0; right < s.length(); ++right) {
            while (left < right && u_set.count(s[right])) {
                u_set.erase(s[left]);
                ++left;
                --cur_window;
            }
            u_set.insert(s[right]);
            ++cur_window;
            res = max(res, cur_window);
        }
        return res;
    }
};

int main(){
    Solution sol;
    string s = "pwwkew";
    cout << sol.lengthOfLongestSubstring(s) << endl;
}
#+end_src

#+RESULTS:
: 3

*** 复杂度
- 时间复杂度 :: O(n)
- 空间复杂度 ::
*** 参考
[[https://www.bilibili.com/video/BV17D421G7Nv/?spm_id_from=333.337.search-card.all.click&vd_source=4441bc96046659b39d059d583f36ff52][【小白都能听懂的算法课】【力扣】【Leetcode3】]]

* [[https://leetcode.cn/problems/find-all-anagrams-in-a-string/?envType=study-plan-v2&envId=top-100-liked][438.找到字符串中所有字母异位词]] [/]
** 解法1:滑动窗口
- 思路 ::
#+begin_src cpp :results output :includes '(<vector> <iostream> <algorithm> <unordered_set>) :main no :namespaces std
class Solution {
public:
    vector<int> findAnagrams(string s, string p) {
        vector<int> res;
        if (s.size() < p.size()) {
            return res;
        }
        vector<int> counts(26);
        for (int i = 0; i < p.size(); ++i) {
            ++counts[p[i] - 'a'];
        }
        vector<int> curCounts(26);
        for (int i = 0; i < p.size() - 1; ++i) {
            ++curCounts[s[i] - 'a'];
        }
        for (int left = 0, right = p.size() - 1; right < s.size(); ++left, ++right) {
            ++curCounts[s[right] - 'a'];
            if (counts == curCounts) {
                res.push_back(left);
            }
            --curCounts[s[left] - 'a'];
        }
        return res;
    }
};

int main(){
    Solution sol;
    string s = "cbaebabacd", p = "abc";
    vector<int> resVec = sol.findAnagrams(s, p);
    for (auto& res:resVec) {
        cout << res << endl;
    }
}
#+end_src

#+RESULTS:
: 0
: 6

**** 复杂度
- 时间复杂度 ::
- 空间复杂度 ::
**** 参考
[[https://www.bilibili.com/video/BV1mf4y1f78S/?spm_id_from=333.337.search-card.all.click&vd_source=4441bc96046659b39d059d583f36ff52][史上最燃算法刷题！滑动窗口的逆袭！Leetcode 438]]

* [[https://leetcode.cn/problems/subarray-sum-equals-k/?envType=study-plan-v2&envId=top-100-liked][560.和为 K 的子数组]] [/]
** 解法1:[[id:aa4d00a0-0fa0-453f-826e-56d34b4fe5ed][前缀和数组]]+哈希表
- 思路 ::
#+begin_src cpp :results output :includes '(<vector> <iostream> <algorithm> <unordered_map>) :main no :namespaces std
class Solution {
public:
    int subarraySum(vector<int>& nums, int k) {
        int res = 0;
        unordered_map<int, int> u_map;
        int cur_sum = 0;
        u_map[cur_sum] = 1;
        for (int i = 0; i < nums.size(); ++i) {
            cur_sum += nums[i];
            if (u_map[cur_sum - k]) {
                res += u_map[cur_sum - k];
            }

            u_map[cur_sum] += 1;
        }
        return res;
    }
};

int main(){
    Solution sol;
    vector<int> nums = {1,2,3};
    int k = 3;
    cout << sol.subarraySum(nums, k) << endl;
}

#+end_src

#+RESULTS:
: 2

**** 复杂度
- 时间复杂度 ::
- 空间复杂度 ::
**** 参考
[[https://www.bilibili.com/video/BV13t4y1y7ya/?vd_source=4441bc96046659b39d059d583f36ff52][560. 和为 K 的子数组 Subarray Sum Equals K【LeetCode 力扣官方题解】]]
[[https://www.bilibili.com/video/BV1UnsbeEETq/?spm_id_from=333.1387.search.video_card.click&vd_source=4441bc96046659b39d059d583f36ff52][【力扣hot100】【LeetCode 560】]]

* [[https://leetcode.cn/problems/sliding-window-maximum/?envType=study-plan-v2&envId=top-100-liked][239.滑动窗口最大值]] [/]
** 解法1:单调队列
- 思路 ::
#+begin_src cpp :results output :includes '(<vector> <iostream> <algorithm> <deque>) :main no :namespaces std
class Solution {
private:
    class MyQueue {
        deque<int> que;
    public:
        void pop(int value) {
            if (!que.empty() && value == que.front()) {
                que.pop_front();
            }
        }
        void push(int value) {
            while (!que.empty() && value > que.back()) {
                que.pop_back();
            }
            que.push_back(value);
        }

        int front() {
            return que.front();
        }
    };
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) {
        MyQueue que;
        vector<int> res;
        for (int i = 0; i < k; ++i) {
            que.push(nums[i]);
        }
        res.push_back(que.front());
        for (int i = k; i < nums.size(); ++i) {
            que.pop(nums[i - k]);
            que.push(nums[i]);
            res.push_back(que.front());
        }
        return res;
    }
};

int main() {
    Solution sol;
    vector<int> nums = {1,3,-1,-3,5,3,6,7};
    int k = 3;
    vector<int> res = sol.maxSlidingWindow(nums, k);
    for (auto& r:res) {
        cout << r << " ";
    }
}
#+end_src

#+RESULTS:
: 3 3 5 5 6 7

**** 复杂度
- 时间复杂度 :: O(n)
- 空间复杂度 :: O(k)
**** 参考
[[https://programmercarl.com/0239.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC.html#%E6%80%9D%E8%B7%AF][代码随想录]]

* [[https://leetcode.cn/problems/minimum-window-substring/?envType=study-plan-v2&envId=top-100-liked][76.最小覆盖子串]] [/]
** 解法1:滑动窗口
- 思路 ::
#+begin_src cpp :results output :includes '(<climits> <iostream> <algorithm> <unordered_map>) :main no :namespaces std
class Solution {
public:
    string minWindow(string s, string t) {
        if (s.length() == 0 || t.length() == 0) {
            return "";
        }
        unordered_map<char, int> u_mapT;
        unordered_map<char, int> u_mapW;
        for (int i = 0; i < t.length(); i++) {
            u_mapT[t[i]]++;
        }
        int tCount = u_mapT.size();
        int have = 0;
        int resStart = 0, resLen = INT_MAX;
        int left = 0, right = 0;
        while (right < s.length()) {
            if (u_mapT.count(s[right])) {
                u_mapW[s[right]]++;
                if (u_mapT[s[right]] == u_mapW[s[right]]) {
                    have++;
                }
            }
            while (have == tCount) {
                if (right - left + 1 < resLen) {
                    resLen = right - left + 1;
                    resStart = left;
                }
                if (u_mapT.count(s[left])) {
                    u_mapW[s[left]]--;
                    if (u_mapT[s[left]] > u_mapW[s[left]]) {
                        --have;
                    }
                }
                ++left;
            }
            ++right;
        }
        if (resLen == INT_MAX) return "";
        return s.substr(resStart, resLen);
    }
};

int main(){
    Solution sol;
    string s = "ADOBECODEBANC", t = "ABC";
    cout << sol.minWindow(s, t) << endl;
}
#+end_src

#+RESULTS:
: BANC

**** 复杂度
- 时间复杂度 ::
- 空间复杂度 ::
**** 参考
[[https://www.bilibili.com/video/BV1sJ4m1g727/?vd_source=4441bc96046659b39d059d583f36ff52][【小白都能听懂的算法课】【力扣】【LeetCode 76】]]

* [[https://leetcode.cn/problems/maximum-subarray/?envType=study-plan-v2&envId=top-100-liked][53.最大子数组和]] [/]
** 解法1:枚举所有子数组的最后一个元素
- 思路 ::
#+begin_src cpp :results output :includes '(<vector> <iostream> <algorithm> <unordered_set>) :main no :namespaces std
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        int maxSub = nums[0];
        int curSum = 0;
        for (int i = 0; i < nums.size(); ++i) {
            if (curSum < 0) {
                curSum = 0;
            }
            curSum += nums[i];
            maxSub = max(maxSub, curSum);
        }
        return maxSub;
    }
};

int main() {
    Solution sol;
    vector<int> nums = {-2,1,-3,4,-1,2,1,-5,4};
    cout << sol.maxSubArray(nums);
}
#+end_src

#+RESULTS:
: 6

**** 复杂度
- 时间复杂度 ::
- 空间复杂度 ::
**** 参考
[[https://www.bilibili.com/video/BV17q421c7Gs/?spm_id_from=333.337.search-card.all.click&vd_source=4441bc96046659b39d059d583f36ff52][【小白都能听懂的算法课】【力扣】【Leetcode53】]]
** TODO 解法2:代码随想录
*** 参考
[[https://programmercarl.com/0053.%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%89.html#%E6%80%9D%E8%B7%AF][代码随想录]]

* [[https://leetcode.cn/problems/merge-intervals/?envType=study-plan-v2&envId=top-100-liked][56.合并区间]] [/]
** 解法1:排序
- 思路 ::
#+begin_src cpp :results output :includes '(<vector> <iostream> <algorithm> <unordered_set>) :main no :namespaces std
class Solution {
public:
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        vector<vector<int>> res;
        if (intervals.size() == 0)
            return res;
        sort(intervals.begin(), intervals.end(), [](const vector<int>& interval1, const vector<int>& interval2){
            return interval1[0] < interval2[0];
        });

        int tempStart = intervals[0][0];
        int tempEnd = intervals[0][1];

        for (int i = 0; i < intervals.size(); ++i) {
            if (tempEnd >= intervals[i][0]) {
                tempEnd = max(tempEnd, intervals[i][1]);
            } else {
                res.push_back({tempStart, tempEnd});
                tempStart = intervals[i][0];
                tempEnd = intervals[i][1];
            }
        }
        res.push_back({tempStart, tempEnd});
        return res;
    }
};

int main() {
    Solution sol;
    vector<vector<int>> intervals = {{1,3},{2,6},{8,10},{15,18}};
    auto resNums = sol.merge(intervals);
    for (auto& res:resNums) {
        for (auto& r:res) {
            cout << r << " ";
        }
        cout << endl;
    }
}
#+end_src

#+RESULTS:
: 1 6
: 8 10
: 15 18

**** 复杂度
- 时间复杂度 ::
- 空间复杂度 ::
**** 参考
[[https://www.bilibili.com/video/BV1nVHXehEBC/?vd_source=4441bc96046659b39d059d583f36ff52
][【大厂程序员带你刷力扣】【LeetCode 56】]]

* [[https://leetcode.cn/problems/rotate-array/?envType=study-plan-v2&envId=top-100-liked][189.轮转数组]] [/]
** 解法1:多次反转
- 思路 ::
#+begin_src cpp :results output :includes '(<vector> <iostream> <algorithm> <unordered_set>) :main no :namespaces std
class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        k = k % nums.size();
        reverse(nums, 0, nums.size() - 1);
        reverse(nums, 0, k - 1);
        reverse(nums, k, nums.size() - 1);
    }

    void reverse(vector<int>& nums, int left, int right) {
        while (left < right) {
            int temp = nums[left];
            nums[left] = nums[right];
            nums[right] = temp;
            ++left;
            --right;
        }
    }
};

int main() {
    Solution sol;
    vector<int> nums = {1,2,3,4,5,6,7};
    int k = 3;
    sol.rotate(nums, k);
    for (auto& num:nums) {
        cout << num << " ";
    }
}
#+end_src

#+RESULTS:
: 5 6 7 1 2 3 4

**** 复杂度
- 时间复杂度 ::
- 空间复杂度 :: O(1)
**** 参考
[[https://www.bilibili.com/video/BV13ox5eHE9n/?vd_source=4441bc96046659b39d059d583f36ff52][【力扣hot100】【LeetCode 189】]]

* [[https://leetcode.cn/problems/product-of-array-except-self/?envType=study-plan-v2&envId=top-100-liked][238.除自身以外数组的乘积]] [/]
** 解法1:[[id:d4215449-8882-47a2-90af-c9f3b929f1f1][前缀积]]
- 思路 ::
#+begin_src cpp :results output :includes '(<vector> <iostream> <algorithm> <unordered_set>) :main no :namespaces std
class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        vector<int> res(nums.size(), 1);
        int prefix = 1;
        for (int i = 0; i < nums.size(); ++i) {
            res[i] = prefix;
            prefix = prefix * nums[i];
        }

        int postfix = 1;
        for (int j = nums.size() - 1; j >= 0; --j) {
            res[j] = res[j] * postfix;
            postfix = postfix * nums[j];
        }
        return res;
    }
};

int main() {
    Solution sol;
    vector<int> nums = {1,2,3,4};
    auto resNums = sol.productExceptSelf(nums);
    for (auto& res:resNums) {
        cout << res << " ";
    }
}
#+end_src

#+RESULTS:
: 24 12 8 6

**** 复杂度
- 时间复杂度 :: O(n)
- 空间复杂度 ::
**** 参考
[[https://www.bilibili.com/video/BV181421S7QY/?spm_id_from=333.337.search-card.all.click&vd_source=4441bc96046659b39d059d583f36ff52][【小白都能听懂的算法课】【力扣】【LeetCode238】]]

* [[https://leetcode.cn/problems/first-missing-positive/description/?envType=study-plan-v2&envId=top-100-liked][41.缺失的第一个正数]] [/]
** 解法1:交换元素到本应该在的位置
- 思路 ::
#+begin_src cpp :results output :includes '(<vector> <iostream> <algorithm> <unordered_set>) :main no :namespaces std
using namespace std;

class Solution {
public:
    int firstMissingPositive(vector<int>& nums) {
      for (int i = 0; i < nums.size(); ++i){
        while (nums[i] > 0 && nums[i] <= nums.size() && nums[i] != i+1 && nums[nums[i]-1] != nums[i]) {
            swap(nums, i, nums[i]-1);
        }
      }
      for (int i = 0; i < nums.size(); ++i){
        if (nums[i]!=i+1){
            return i+1;
        }
      }
      return nums.size()+1;
    }

    void swap(vector<int>& nums, int i, int j){
        int tmp = nums[i];
        nums[i] = nums[j];
        nums[j] = tmp;
    }
};

int main() {
    Solution sol;
    vector<int> nums = {3,4,-1,1};
    cout << sol.firstMissingPositive(nums);
}
#+end_src

#+RESULTS:
: 2

**** 复杂度
- 时间复杂度 ::
- 空间复杂度 ::
**** 参考
[[https://www.bilibili.com/video/BV1XK411n7tf/?spm_id_from=333.337.search-card.all.click&vd_source=4441bc96046659b39d059d583f36ff52][LeetCode每日打卡.41.缺失的第一个正数]] 代码有点错误，看评论区if改while

* [[https://leetcode.cn/problems/set-matrix-zeroes/?envType=study-plan-v2&envId=top-100-liked][73.矩阵置零]] [/]
** 解法1:
- 思路 ::
#+begin_src cpp :results output :includes '(<vector> <iostream> <algorithm> <unordered_set>) :main no :namespaces std
class Solution {
public:
    void setZeroes(vector<vector<int>>& matrix) {
     int rows = matrix.size();
     int cols = matrix[0].size();
     int zeroRow = 1;
     for (int row = 0; row < rows; ++row) {
        for (int col =0; col < cols; ++col) {
            if (matrix[row][col] == 0) {
                matrix[0][col] = 0;
                if (row > 0) {
                    matrix[row][0] = 0;
                } else {
                    zeroRow = 0;
                }
            }
        }
     }
     for (int row = 1; row < rows; ++row) {
        for (int col = 1; col < cols; ++col) {
            if (matrix[row][0] == 0 || matrix[0][col] == 0) {
                matrix[row][col] = 0;
            }
        }
     }
     if (matrix[0][0] == 0) {
        for (int row = 1; row < rows; ++row) {
            matrix[row][0] = 0;
        }
     }
     if (zeroRow == 0) {
        for (int col = 0; col < cols; ++col) {
            matrix[0][col] = 0;
        }
     }
    }
};

int main() {
    Solution sol;
    vector<vector<int>> matrix = {{1,1,1},{1,0,1},{1,1,1}};
    sol.setZeroes(matrix);
    for (auto& row:matrix) {
        for (auto& col:row ) {
            cout << col << " ";
        }
        cout << endl;
    }
}
#+end_src

#+RESULTS:
: 1 0 1
: 0 0 0
: 1 0 1

**** 复杂度
- 时间复杂度 :: O(nm)
- 空间复杂度 :: O(1)
**** 参考
[[https://www.bilibili.com/video/BV1WKHEeMEug/?spm_id_from=333.337.search-card.all.click&vd_source=4441bc96046659b39d059d583f36ff52][【大厂程序员带你刷力扣】【LeetCode 73】]]

* [[https://leetcode.cn/problems/spiral-matrix/?envType=study-plan-v2&envId=top-100-liked][54.螺旋矩阵]] [/]
** 解法1:设置、移动矩阵边界
- 思路 ::
#+begin_src cpp :results output :includes '(<vector> <iostream> <algorithm> <unordered_set>) :main no :namespaces std
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        int left = 0, right = matrix[0].size(), top = 0, bottom = matrix.size();
        vector<int> res;
        while (left < right && top < bottom) {
            for (int i = left; i < right; ++i) {
                res.push_back(matrix[top][i]);
            }
            ++top;
            if (top >= bottom) {
                break;
            }
            for (int j = top; j < bottom; ++j) {
                res.push_back(matrix[j][right - 1]);
            }
            --right;
            if (left >= right) {
                break;
            }
            for (int k = right - 1; k >= left; --k) {
                res.push_back(matrix[bottom - 1][k]);
            }
            --bottom;
            if (top >= bottom) {
                break;
            }
            for (int l = bottom - 1; l >= top; --l) {
                res.push_back(matrix[l][left]);
            }
            ++left;
        }
        return res;
    }
};

int main() {
    Solution sol;
    vector<vector<int>> matrix = {{1,2,3,4},{5,6,7,8},{9,10,11,12}};
    auto resMatrix = sol.spiralOrder(matrix);
    for (auto& res:resMatrix) {
        cout << res << " ";
    }
}
#+end_src

#+RESULTS:
: 1 2 3 4 8 12 11 10 9 5 6 7

**** 复杂度
- 时间复杂度 ::
- 空间复杂度 ::
**** 参考
[[https://www.bilibili.com/video/BV17JHreoETn/?spm_id_from=333.337.search-card.all.click&vd_source=4441bc96046659b39d059d583f36ff52][【大厂程序员带你刷力扣】【LeetCode 54】]]

* [[https://leetcode.cn/problems/rotate-image/?envType=study-plan-v2&envId=top-100-liked][48.旋转图像]] [/]
** 解法1:设置、移动矩阵边界
- 思路 ::
#+begin_src cpp :results output :includes '(<vector> <iostream> <algorithm> <unordered_set>) :main no :namespaces std
class Solution {
public:
    void rotate(vector<vector<int>>& matrix) {
        int left = 0, right = matrix.size() - 1;
        while (left < right) {
            for (int i = 0; i < right - left; ++i) {
                int top = left, bottom = right;
                int topleft = matrix[top][left + i];
                matrix[top][left + i] = matrix[bottom - i][left];
                matrix[bottom - i][left] = matrix[bottom][right - i];
                matrix[bottom][right - i] = matrix[top + i][right];
                matrix[top + i][right] = topleft;
            }
            ++left;
            --right;
        }
    }
};

int main() {
    Solution sol;
    vector<vector<int>> matrix = {{5,1,9,11},{2,4,8,10},{13,3,6,7},{15,14,12,16}};
    sol.rotate(matrix);
    for (auto& rows:matrix) {
        for (auto& rol:rows) {
            cout << rol << " ";
        }
        cout << endl;
    }
}
#+end_src

#+RESULTS:
: 15 13 2 5
: 14 3 4 1
: 12 6 8 9
: 16 7 10 11

**** 复杂度
- 时间复杂度 ::
- 空间复杂度 ::
**** 参考
[[https://www.bilibili.com/video/BV1FaHbecE9V/?spm_id_from=333.337.search-card.all.click&vd_source=4441bc96046659b39d059d583f36ff52][【大厂程序员带你刷力扣】【LeetCode 48】]]

* [[https://leetcode.cn/problems/search-a-2d-matrix-ii/?envType=study-plan-v2&envId=top-100-liked][240.搜索二维矩阵 II]] [/]
** 解法1:缩小搜索范围
- 思路 ::
#+begin_src cpp :results output :includes '(<vector> <iostream> <algorithm> <unordered_set>) :main no :namespaces std
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
       if (matrix.size() == 0 || matrix[0].size() == 0) {
        return false;
       }
       int row = 0, col = matrix[0].size() - 1;
       while (row < matrix.size() && col >= 0) {
        if (matrix[row][col] == target) {
            return true;
        } else if (matrix[row][col] > target) {
            --col;
        } else {
            ++row;
        }
       }
       return false;
    }
};

int main() {
    Solution sol;
    vector<vector<int>> matrix = {{1,4,7,11,15},{2,5,8,12,19},{3,6,9,16,22},{10,13,14,17,24},{18,21,23,26,30}};
    int target = 5;
    cout << sol.searchMatrix(matrix, target);
}
#+end_src

#+RESULTS:
: 1

**** 复杂度
- 时间复杂度 ::
- 空间复杂度 ::
**** 参考
[[https://www.bilibili.com/video/BV1WV4y1f7GZ/?vd_source=4441bc96046659b39d059d583f36ff52][leetcode-二分查找篇 240题 搜索二维矩阵 II]]

* [[https://leetcode.cn/problems/intersection-of-two-linked-lists/?envType=study-plan-v2&envId=top-100-liked][160.相交链表]] [/]
** 解法1:
- 思路 ::
#+begin_src cpp :results output :includes '(<vector> <iostream> <algorithm> <unordered_set>) :main no :namespaces std
struct ListNode {
     int val;
     ListNode *next;
     ListNode(int x) : val(x), next(NULL) {}
 };

class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
       unordered_set<ListNode*> st;
       while (headA != nullptr) {
        st.insert(headA);
        headA = headA -> next;
       }
       while (headB != nullptr) {
        if (st.count(headB)) return headB;
        headB = headB -> next;
       }
       return nullptr;
    }
};
#+end_src

**** 复杂度
- 时间复杂度 ::
- 空间复杂度 ::
**** 参考
[[https://www.bilibili.com/video/BV1JC411L7AJ/?spm_id_from=333.337.search-card.all.click&vd_source=4441bc96046659b39d059d583f36ff52][【史上最燃算法刷题】Leetcode160.相交链表]]

* [[https://leetcode.cn/problems/reverse-linked-list/?envType=study-plan-v2&envId=top-100-liked][206.反转链表]] [/]
** 解法1:双指针
- 思路 ::
#+begin_src cpp :results output :includes '(<vector> <iostream> <algorithm> <unordered_set>) :main no :namespaces std
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
       if (!head) {
        return head;
       }
       ListNode* pre = NULL;
       ListNode* cur = head;
       while (cur) {
        ListNode* tmp = cur->next;
        cur->next = pre;
        pre = cur;
        cur = tmp;
       }
       return pre;
    }
};
#+end_src

**** 复杂度
- 时间复杂度 ::
- 空间复杂度 ::
**** 参考
[[https://www.bilibili.com/video/BV1gE421N7W2/?spm_id_from=333.337.search-card.all.click&vd_source=4441bc96046659b39d059d583f36ff52][【小白都能听懂的算法课】【力扣】【LeetCode 206】]]

* [[https://leetcode.cn/problems/palindrome-linked-list/description/?envType=study-plan-v2&envId=top-100-liked][234.回文链表]] [/]
** 解法1:链表一分为二 + 反转链表 + 快慢指针
- 思路 ::
#+begin_src cpp :results output :includes '(<vector> <iostream> <algorithm> <unordered_set>) :main no :namespaces std
class Solution {
public:
    bool isPalindrome(ListNode* head) {
        ListNode* slow = head;
        ListNode* fast = head->next;
        while (fast && fast->next) {
           slow = slow->next;
           fast = fast->next->next;
        }
        ListNode* second = reverseList(slow->next);
        slow->next = NULL;
        ListNode* first = head;
        while (second) {
            if (first->val != second->val) {
                return false;
            }
            first = first->next;
            second = second->next;
        }
        return true;
    }

    ListNode* reverseList(ListNode* head) {
        if (!head) {
            return head;
        }
        ListNode* pre = NULL;
        ListNode* cur = head;
        while (cur) {
            ListNode* tmp = cur->next;
            cur->next = pre;
            pre = cur;
            cur = tmp;
        }
        return pre;
    }
};
#+end_src

**** 复杂度
- 时间复杂度 :: O(n)
- 空间复杂度 :: O(1)
**** 参考
[[https://www.bilibili.com/video/BV1ArsdeSE3D/?spm_id_from=333.337.search-card.all.click&vd_source=4441bc96046659b39d059d583f36ff52][【力扣hot100】【LeetCode 234】]]

* [[https://leetcode.cn/problems/linked-list-cycle/?envType=study-plan-v2&envId=top-100-liked][141.环形链表]]
** 解法1:快慢指针
- 思路 ::
#+begin_src cpp :results output :includes '(<vector> <iostream> <algorithm> <unordered_set>) :main no :namespaces std
class Solution {
public:
    bool hasCycle(ListNode *head) {
        ListNode* slow = head;
        ListNode* fast = head;
        while (fast && fast->next) {
            slow = slow->next;
            fast = fast->next->next;
            if (slow == fast) {
                return true;
            }
        }
        return false;
    }
}
#+end_src

**** 复杂度
- 时间复杂度 :: O(n)
- 空间复杂度 :: O(1)
**** 参考
[[https://www.bilibili.com/video/BV18z421q78k/?spm_id_from=333.337.search-card.all.click&vd_source=4441bc96046659b39d059d583f36ff52][【小白都能听懂的算法课】【力扣】【LeetCode 141】]]

* [[https://leetcode.cn/problems/linked-list-cycle-ii/?envType=study-plan-v2&envId=top-100-liked][142.环形链表II]]
** 解法1:快慢指针
- 思路 ::
#+begin_src cpp :results output :includes '(<vector> <iostream> <algorithm> <unordered_set>) :main no :namespaces std
class Solution {
public:
    ListNode* detectCycle(ListNode* head) {
        ListNode *slow = head, *fast = head;
        if (head == nullptr || head->next == nullptr) {
            return nullptr;
        }
        while (fast && fast->next) {
            slow = slow->next;
            fast = fast->next->next;
            if (slow == fast) {
                fast = head;
                while (slow != fast) {
                    slow = slow->next;
                    fast = fast->next;
                }
                return fast;
            }
        }
        return nullptr;
    }
};
#+end_src

**** 复杂度
- 时间复杂度 ::
- 空间复杂度 :: O(1)
**** 参考
[[https://www.bilibili.com/video/BV1VU4EeTE7Y/?spm_id_from=333.337.search-card.all.click&vd_source=4441bc96046659b39d059d583f36ff52][【力扣hot100】【LeetCode 142】]]
* [[https://leetcode.cn/problems/merge-two-sorted-lists/?envType=study-plan-v2&envId=top-100-liked][21.合并两个有序链表]]
** 解法1:双指针
- 思路 ::
#+begin_src cpp :results output :includes '(<vector> <iostream> <algorithm> <unordered_set>) :main no :namespaces std
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        ListNode* dummy = new ListNode();
        ListNode* tail = dummy;
        while (list1 && list2) {
            if (list1->val <= list2->val) {
                tail->next = list1;
                tail = list1;
                list1 = list1->next;
            } else {
                tail->next = list2;
                tail = list2;
                list2 = list2->next;
            }
        }
        if (list1) {
            tail->next = list1;
        }
        if (list2) {
            tail->next =list2;
        }
        dummy = dummy->next;
        return dummy;
    }
};
#+end_src

**** 复杂度
- 时间复杂度 ::
- 空间复杂度 ::
**** 参考
[[https://www.bilibili.com/video/BV17w4m1Y7CJ/?spm_id_from=333.337.search-card.all.click&vd_source=4441bc96046659b39d059d583f36ff52][【小白都能听懂的算法课】【力扣】【LeetCode 21】]]
* [[https://leetcode.cn/problems/add-two-numbers/?envType=study-plan-v2&envId=top-100-liked][2.两数相加]]
** 解法1:
- 思路 ::
#+begin_src cpp :results output :includes '(<vector> <iostream> <algorithm> <unordered_set>) :main no :namespaces std
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode* dummy = new ListNode();
        ListNode* tail = dummy;
        int carry = 0;
        while (l1 || l2 || carry) {
            int val1 = 0, val2 = 0;
            if (l1) {
                val1 = l1->val;
                l1 = l1->next;
            }
            if (l2) {
                val2 = l2->val;
                l2 = l2->next;
            }
            int res = val1 + val2 + carry;
            int newVal = res % 10;
            tail->next = new ListNode(newVal);
            tail = tail->next;
            carry = res / 10;
        }
        return dummy->next;
    }
}
#+end_src

#+RESULTS:


**** 复杂度
- 时间复杂度 ::
- 空间复杂度 ::
**** 参考
[[https://www.bilibili.com/video/BV1EYxkerEW3/?spm_id_from=333.337.search-card.all.click&vd_source=4441bc96046659b39d059d583f36ff52][【力扣hot100】【LeetCode 2】]]
* [[https://leetcode.cn/problems/remove-nth-node-from-end-of-list/?envType=study-plan-v2&envId=top-100-liked][19.删除链表倒数第N个节点]]
** 解法1:双指针
- 思路 ::
#+begin_src cpp :results output :includes '(<vector> <iostream> <algorithm> <unordered_set>) :main no :namespaces std
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        ListNode* dummy = new ListNode(0, head);
        ListNode* left = dummy;
        ListNode* right = head;
        while (n && right) {
            right = right->next;
            --n;
        }
        while (right) {
            left = left->next;
            right = right->next;
        }
        left->next = left->next->next;
        return dummy->next;
    }
};
#+end_src

**** 复杂度
- 时间复杂度 ::
- 空间复杂度 ::
**** 参考
[[https://www.bilibili.com/video/BV1hs421M7Ke/?spm_id_from=333.337.search-card.all.click&vd_source=4441bc96046659b39d059d583f36ff52][【小白都能听懂的算法课】【力扣】【LeetCode 19】]]
* [[https://leetcode.cn/problems/swap-nodes-in-pairs/?envType=study-plan-v2&envId=top-100-liked][24.两两交换链表中的节点]]
** 解法1:
- 思路 ::
#+begin_src cpp :results output :includes '(<vector> <iostream> <algorithm> <unordered_set>) :main no :namespaces std
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        ListNode* dummy = new ListNode(0, head);
        ListNode* pre = dummy;
        ListNode* first = head;
        ListNode* second = NULL;
        while (first && first->next) {
            second = first->next;
            ListNode* nxt = second->next;
            pre->next = second;
            second->next = first;
            first->next = nxt;
            pre = first;
            first = nxt;
        }
        return dummy->next;
    }
}
#+end_src

**** 复杂度
+ 时间复杂度 ::
+ 空间复杂度 ::
**** 参考
[[https://www.bilibili.com/video/BV1MJxWeBEt9/?spm_id_from=333.337.search-card.all.click&vd_source=4441bc96046659b39d059d583f36ff52][【力扣hot100】【LeetCode 24】]]
* [[https://leetcode.cn/problems/reverse-nodes-in-k-group/description/?envType=study-plan-v2&envId=top-100-liked][25.K个一组翻转链表]]
** 解法1
- 思路 ::
#+begin_src cpp :results output :includes '(<vector> <iostream> <algorithm> <unordered_set>) :main no :namespaces std
class Solution {
public:
    ListNode* reverseKGroup(ListNode* head, int k) {
       ListNode* dummy = new ListNode(0, head);
       ListNode* groupPre = dummy;
       while (true) {
        ListNode* cur = groupPre;
        int kth = k;
        // 判断是否至少有K个节点
        while (kth > 0 && cur) {
            --kth;
            cur = cur->next;
        }
        if (!cur) {
            break;
        }
        // 定位右边界
        ListNode* groupNxt = cur->next;
        // 处理组内节点
        ListNode* pre = groupNxt;
        cur = groupPre->next;
        ListNode* tmp = NULL;
        while (cur != groupNxt) {
            tmp = cur->next;
            cur->next = pre;
            pre = cur;
            cur = tmp;
        }
        // 重新定位左边界
        tmp = groupPre->next;
        groupPre->next = pre;
        groupPre = tmp;
       }
        return dummy->next;
    }
};
#+end_src

**** 复杂度
+ 时间复杂度 ::
+ 空间复杂度 ::
**** 参考
[[https://www.bilibili.com/video/BV1Xe2wYnEhL/?spm_id_from=333.337.search-card.all.click&vd_source=4441bc96046659b39d059d583f36ff52][【力扣hot100】【LeetCode 25】]]

* [[https://leetcode.cn/problems/copy-list-with-random-pointer/description/?envType=study-plan-v2&envId=top-100-liked][138.随机链表的复制]]
** 解法1
- 思路 ::
#+begin_src cpp :results output :includes '(<vector> <iostream> <algorithm> <unordered_set>) :main no :namespaces std
class Solution {
public:
    Node* copyRandomList(Node* head) {
       unordered_map<Node*, Node*> oldMapNew;
       Node* cur = head;
       while (cur) {
        Node* newNode = new Node(cur->val);
        oldMapNew[cur] = newNode;
        cur = cur->next;
       }
       cur = head;
       while (cur) {
        Node* newNode = oldMapNew[cur];
        newNode->next = oldMapNew[cur->next];
        newNode->random = oldMapNew[cur->random];
        cur = cur->next;
       }
       return oldMapNew[head];
    }
};
#+end_src

**** 复杂度
+ 时间复杂度 ::
+ 空间复杂度 ::
**** 参考
[[https://www.bilibili.com/video/BV1qh1CY6EdY/?spm_id_from=333.337.search-card.all.click&vd_source=4441bc96046659b39d059d583f36ff52][【力扣hot100】【LeetCode 138】]]

* [[https://leetcode.cn/problems/sort-list/?envType=study-plan-v2&envId=top-100-liked][148.排序链表]]
** 解法1:归并排序
- 思路 :: 将链表一分为二 => 归并排序
#+begin_src cpp :results output :includes '(<vector> <iostream> <algorithm> <unordered_set>) :main no :namespaces std
class Solution {
public:
    ListNode* sortList(ListNode* head) {
        if (!head || !head->next) {
            return head;
        }
        ListNode* slow = head;
        ListNode* fast = head->next;
        while (fast && fast->next) {
            slow = slow->next;
            fast = fast->next->next;
        }
        ListNode* second = slow->next;
        slow->next = NULL;
        ListNode* first = head;
        first = sortList(first);
        second = sortList(second);
        return mergeList(first, second);
    }
    ListNode* mergeList(ListNode* left, ListNode* right) {
        ListNode* dummy = new ListNode(0);
        ListNode* tail = dummy;
        while (left && right) {
            if (left->val < right->val) {
                tail->next = left;
pp                left = left->next;
            } else {
                tail->next = right;
                right = right->next;
            }
            tail = tail->next;
        }
        if (left) {
            tail->next = left;
        } else {
            tail->next = right;
        }
        return dummy->next;
    }
}
#+end_src

**** 复杂度
+ 时间复杂度 ::
+ 空间复杂度 ::
**** 参考
[[https://www.bilibili.com/video/BV1Kx2GYqEZD/?spm_id_from=333.337.search-card.all.click&vd_source=4441bc96046659b39d059d583f36ff52][【力扣hot100】【LeetCode 148】]]
* [[https://leetcode.cn/problems/merge-k-sorted-lists/description/?envType=study-plan-v2&envId=top-100-liked][23.合并K个升序链表]]
** 解法1
- 思路 ::
#+begin_src cpp :results output :includes '(<vector> <iostream> <algorithm> <unordered_set>) :main no :namespaces std
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        ListNode* dummy = new ListNode();
        ListNode* tail = dummy;
        while (list1 && list2) {
            if (list1->val <= list2->val) {
                tail->next = list1;
                list1 = list1->next;
            } else {
                tail->next = list2;
                list2 = list2->next;
            }
            tail = tail->next;
        }
        if (list1) {
            tail->next = list1;
        } else if (list2) {
            tail->next = list2;
        }
        return dummy->next;
    }
    ListNode* mergeKLists(vector<ListNode*>& lists) {
       if (lists.size() == 0) {
        return NULL;
       }
       while (lists.size() > 1) {
        vector<ListNode*> tempList;
        for (int i = 0; i < lists.size(); i+=2) {
            ListNode* l1 = lists[i];
            ListNode* l2 = NULL;
            if (i + 1 < lists.size()) {
                l2 = lists[i + 1];
            }
            tempList.push_back(mergeTwoLists(l1, l2));
        }
        lists = tempList;
       }
       return lists[0];
    }
};
#+end_src

**** 复杂度
+ 时间复杂度 ::
+ 空间复杂度 ::
**** 参考
[[https://www.bilibili.com/video/BV136421f7hR/?spm_id_from=333.337.search-card.all.click&vd_source=4441bc96046659b39d059d583f36ff52][【小白都能听懂的算法课】【力扣】【LeetCode 23】]]
* [[https://leetcode.cn/problems/lru-cache/description/?envType=study-plan-v2&envId=top-100-liked][146.LRU缓存]]
** 解法1
- 思路 ::
#+begin_src cpp :results output :includes '(<vector> <iostream> <algorithm> <unordered_set>) :main no :namespaces std
struct DLinkedNode {
    int key, value;
    DLinkedNode* prev;
    DLinkedNode* next;
    DLinkedNode() : key(0), value(0), prev(nullptr), next(nullptr) {}
    DLinkedNode(int _key, int _value)
        : key(_key), value(_value), prev(nullptr), next(nullptr) {}
};

class LRUCache {
private:
    unordered_map<int, DLinkedNode*> cache;
    DLinkedNode* head;
    DLinkedNode* tail;
    int size;
    int capacity;

public:
    LRUCache(int _capacity) : capacity(_capacity), size(0) {
        head = new DLinkedNode();
        tail = new DLinkedNode();
        head->next = tail;
        tail->prev = head;
    }

    int get(int key) {
        if (!cache.count(key)) {
            return -1;
        }
        DLinkedNode* node = cache[key];
        moveToHead(node);
        return node->value;
    }

    void put(int key, int value) {
        if (!cache.count(key)) {
            DLinkedNode* node = new DLinkedNode(key, value);
            cache[key] = node;
            addToHead(node);
            ++size;
            if (size > capacity) {
                DLinkedNode* removed = removeTail();
                cache.erase(removed->key);
                delete removed;
                --size;
            }
        } else {
            DLinkedNode* node = cache[key];
            node->value = value;
            moveToHead(node);
        }
    }

    void addToHead(DLinkedNode* node) {
        node->prev = head;
        node->next = head->next;
        head->next->prev = node;
        head->next = node;
    }

    void removeNode(DLinkedNode* node) {
        node->prev->next = node->next;
        node->next->prev = node->prev;
    }

    void moveToHead(DLinkedNode* node) {
        removeNode(node);
        addToHead(node);
    }

    DLinkedNode* removeTail() {
        DLinkedNode* node = tail->prev;
        removeNode(node);
        return node;
    }
};
#+end_src

**** 复杂度
+ 时间复杂度 ::
+ 空间复杂度 ::
**** 参考
[[https://leetcode.cn/problems/lru-cache/solutions/259678/lruhuan-cun-ji-zhi-by-leetcode-solution/?envType=study-plan-v2&envId=top-100-liked][leetcode评论区:官方题解]]
* [[https://leetcode.cn/problems/binary-tree-inorder-traversal/description/?envType=study-plan-v2&envId=top-100-liked][94.二叉树的中序遍历]]
** 解法1:栈
- 思路 ::
#+begin_src cpp :results output :includes '(<vector> <iostream> <algorithm> <unordered_set>) :main no :namespaces std
class Solution {
public:
    vector<int> inorderTraversal(TreeNode* root) {
        vector<int> res;
        stack<TreeNode*> st;
        TreeNode* cur = root;
        while (cur || !st.empty()) {
            while (cur) {
                st.push(cur);
                cur = cur->left;
            }
            cur = st.top();
            st.pop();
            res.push_back(cur->val);
            cur = cur->right;
        }
        return res;
    }
}
#+end_src

**** 复杂度
+ 时间复杂度 :: O(n)
+ 空间复杂度 :: O(n)
**** 参考
[[https://www.bilibili.com/video/BV1qp21YmEfT/?spm_id_from=333.337.search-card.all.click&vd_source=4441bc96046659b39d059d583f36ff52][【力扣hot100】【LeetCode 94】]]
* [[https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/?envType=study-plan-v2&envId=top-100-like][104.二叉树的最大深度]]
** 解法1:dfs(栈)
- 思路 ::
#+begin_src cpp :results output :includes '(<vector> <iostream> <algorithm> <unordered_set>) :main no :namespaces std
class Solution {
public:
    int maxDepth(TreeNode* root) {
       if (!root) {
        return 0;
       }
       int depth = 0;
       stack<pair<TreeNode*, int>> s;
       s.push({root, 1});
       while (!s.empty()) {
        auto temp = s.top();
        s.pop();
        depth = max(depth, temp.second);
        if (temp.first->right) {
            s.push({temp.first->right, temp.second + 1});
        }
        if (temp.first->left) {
            s.push({temp.first->left, temp.second + 1});
        }
       }
       return depth;
    }
}
#+end_src

**** 复杂度
+ 时间复杂度 ::
+ 空间复杂度 ::
**** 参考
[[https://www.bilibili.com/video/BV1MRYHeHEeP/?spm_id_from=333.337.search-card.all.click&vd_source=4441bc96046659b39d059d583f36ff52][【大厂程序员带你刷力扣】【Leetcode 104】]]
** 解法2:bfs(queue)
- 思路 ::
#+begin_src cpp :results output :includes '(<vector> <iostream> <algorithm> <unordered_set>) :main no :namespaces std
class Solution {
public:
    int maxDepth(TreeNode* root) {
       if (!root) {
        return 0;
       }
       int depth = 0;
       queue<pair<TreeNode*, int>> q;
       q.push({root, 1});
       while (!q.empty()) {
        auto temp = q.front();
        q.pop();
        depth = max(depth, temp.second);
        if (temp.first->left) {
            q.push({temp.first->left, temp.second + 1});
        }
        if (temp.first->right) {
            q.push({temp.first->right, temp.second + 1});
        }
       }
       return depth;
    }
};
#+end_src
* [[https://leetcode.cn/problems/invert-binary-tree/?envType=study-plan-v2&envId=top-100-liked][226.翻转二叉树]]
** 解法1:递归
- 思路 ::
#+begin_src cpp :results output :includes '(<vector> <iostream> <algorithm> <unordered_set>) :main no :namespaces std
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if (!root) {
            return root;
        }
        root->left = invertTree(root->left);
        root->right = invertTree(root->right);
        TreeNode* temp = root->left;
        root->left = root->right;
        root->right = temp;
        return root;
    }
};
#+end_src

**** 复杂度
+ 时间复杂度 ::
+ 空间复杂度 ::
**** 参考
[[https://www.bilibili.com/video/BV1N7YheBE8H/?spm_id_from=333.337.search-card.all.click&vd_source=4441bc96046659b39d059d583f36ff52][【大厂程序员带你刷力扣】【Leetcode 226】]]
* [[https://leetcode.cn/problems/symmetric-tree/?envType=study-plan-v2&envId=top-100-liked][101.对称二叉树]]
** 解法1:递归
- 思路 ::
#+begin_src cpp :results output :includes '(<vector> <iostream> <algorithm> <unordered_set>) :main no :namespaces std
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        return check(root->left, root->right);
    }

    bool check(TreeNode* p, TreeNode* q) {
        if (!p && !q) return true;
        if (!p || !q) return false;
        return p->val==q->val && check(p->left, q->right) && check(p->right, q->left);
    }
}
#+end_src

**** 复杂度
+ 时间复杂度 ::
+ 空间复杂度 ::
**** 参考
[[https://leetcode.cn/problems/symmetric-tree/solutions/268109/dui-cheng-er-cha-shu-by-leetcode-solution/?envType=study-plan-v2&envId=top-100-liked][leetcode官方题解]]
* [[https://leetcode.cn/problems/diameter-of-binary-tree/?envType=study-plan-v2&envId=top-100-liked][543.二叉树的直径]]
** 解法1
- 思路 ::
#+begin_src cpp :results output :includes '(<vector> <iostream> <algorithm> <unordered_set>) :main no :namespaces std
class Solution {
    // ans是节点的数量
    int ans;
    // 深度是计算节点的数量，而不是边的数量
    int depth(TreeNode* root) {
        if (root == NULL) return 0;
        int L = depth(root->left);
        int R = depth(root->right);
        ans = max(ans, L + R + 1);
        return max(L, R) + 1;
    }
public:
    int diameterOfBinaryTree(TreeNode* root) {
        ans = 1;
        depth(root);
        return ans - 1;
    }
}
#+end_src

**** 复杂度
+ 时间复杂度 ::
+ 空间复杂度 ::
**** 参考
[[https://leetcode.cn/problems/diameter-of-binary-tree/solutions/142094/shi-pin-jie-shi-di-gui-dai-ma-de-yun-xing-guo-chen/?envType=study-plan-v2&envId=top-100-liked][leetcode评论区]]
* [[https://leetcode.cn/problems/binary-tree-level-order-traversal/?envType=study-plan-v2&envId=top-100-liked][102.二叉树的层序遍历]]
** 解法1:待优化
- 思路 ::
#+begin_src cpp :results output :includes '(<vector> <iostream> <algorithm> <unordered_set>) :main no :namespaces std
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> res;
        queue<pair<int, TreeNode*>> q;
        pair<int, TreeNode*> temp;
        if (!root) {
            return res;
        }
        TreeNode* cur = root;
        q.push({0, cur});
        while (!q.empty()) {
            auto [level, node] = q.front();
            q.pop();
            if (res.size() <= level) {
                res.push_back({});
            }
            if (node) {
                res[level].push_back(node->val);
                q.push({level + 1, node->left});
                q.push({level + 1, node->right});
            }
        }
        res.pop_back();
        return res;
    }
};
#+end_src

**** 复杂度
+ 时间复杂度 ::
+ 空间复杂度 ::
**** 参考
自己
* [[https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/?envType=study-plan-v2&envId=top-100-liked][108.将有序数组转换为二叉搜索树]]
** 解法1:递归
- 思路 ::
#+begin_src cpp :results output :includes '(<vector> <iostream> <algorithm> <unordered_set>) :main no :namespaces std
class Solution {
public:
    TreeNode* sortedArrayToBST(vector<int>& nums) {
       return build(nums, 0, nums.size() - 1);
    }

    TreeNode* build(vector<int>& nums, int l, int r) {
        if (l > r) return nullptr;
        int mid = l + (r - l) / 2;
        TreeNode* root = new TreeNode(nums[mid]);
        root->left = build(nums, l, mid - 1);
        root->right = build(nums, mid + 1, r);
        return root;
    }
};
#+end_src

**** 复杂度
+ 时间复杂度 :: O(n)
+ 空间复杂度 :: O(logn)
**** 参考
[[https://www.bilibili.com/video/BV1Wu411k7ZE/?vd_source=4441bc96046659b39d059d583f36ff52][bilibili]]
* [[https://leetcode.cn/problems/validate-binary-search-tree/?envType=study-plan-v2&envId=top-100-liked][98.验证二叉搜索树]]
** 解法1
- 思路 ::
#+begin_src cpp :results output :includes '(<vector> <iostream> <algorithm> <unordered_set>) :main no :namespaces std
class Solution {
public:
    long long maxVal = LONG_MIN;
    bool isValidBST(TreeNode* root) {
        if (root == NULL) return true;
        bool left = isValidBST(root->left);
        if (root->val > maxVal) maxVal = root->val;
        else return false;
        bool right = isValidBST(root->right);
        return left && right;
    }
};
#+end_src

**** 复杂度
+ 时间复杂度 ::
+ 空间复杂度 ::
**** 参考
[[https://programmercarl.com/0098.%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html#%E6%80%9D%E8%B7%AF][代码随想录]]
* [[https://leetcode.cn/problems/kth-smallest-element-in-a-bst/?envType=study-plan-v2&envId=top-100-liked][230.二叉搜索树中第K小的元素]]
** 解法1:中序遍历
- 思路 ::
#+begin_src cpp :results output :includes '(<vector> <iostream> <algorithm> <unordered_set>) :main no :namespaces std
class Solution {
public:
    int kthSmallest(TreeNode* root, int k) {
       vector<int> vec;
       tran(root, vec);
       return vec[k - 1];
    }

    void tran(TreeNode* root, vector<int>& vec) {
        if (!root) return;
        tran(root->left, vec);
        vec.emplace_back(root->val);
        tran(root->right, vec);
    }
};
#+end_src

**** 复杂度
+ 时间复杂度 ::
+ 空间复杂度 ::
**** 参考
自己
[[https://programmercarl.com/0098.%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html#%E6%80%9D%E8%B7%AF][代码随想录]]
* [[https://leetcode.cn/problems/binary-tree-right-side-view/?envType=study-plan-v2&envId=top-100-liked][199.二叉树的右视图]]
** 解法1:层序遍历
- 思路 ::
#+begin_src cpp :results output :includes '(<vector> <iostream> <algorithm> <unordered_set>) :main no :namespaces std
class Solution {
public:
    vector<int> rightSideView(TreeNode* root) {
        vector<int> ans;
        if (!root) return ans;

        queue<TreeNode*> q;
        q.push(root);

        while (!q.empty()) {
            int cnt = q.size();
            for (int i = 0; i < cnt; ++i) {
                TreeNode* cur = q.front();
                q.pop();
                if (cur->left) q.push(cur->left);
                if (cur->right) q.push(cur->right);
                if (i == cnt-1) ans.push_back(cur->val);
            }
        }
        return ans;
    }
};
#+end_src

**** 复杂度
+ 时间复杂度 ::
+ 空间复杂度 ::
**** 参考
[[https://www.bilibili.com/video/BV1Kd4y1E7Nv/?vd_source=4441bc96046659b39d059d583f36ff52][bilibili]]
* [[https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/?envType=study-plan-v2&envId=top-100-liked][114.二叉树展开为链表]]
** 解法1
- 思路 ::
#+begin_src cpp :results output :includes '(<vector> <iostream> <algorithm> <unordered_set>) :main no :namespaces std
class Solution {
public:
    void flatten(TreeNode* root) {
        TreeNode* cur = root;
        while (cur) {
            if (cur->left) {
                TreeNode* p = cur->left;
                while (p->right) p = p->right;
                p->right = cur->right;
                cur->right = cur->left;
                cur->left = nullptr;
            }
            cur = cur->right;
        }
    }
}
#+end_src

**** 复杂度
+ 时间复杂度 ::
+ 空间复杂度 ::
**** 参考
[[https://www.bilibili.com/video/BV19T4y1r7y5/?vd_source=4441bc96046659b39d059d583f36ff52][bilibili]]
* [[https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/?envType=study-plan-v2&envId=top-100-liked][105.从前序与中序遍历序列构造二叉树]]
** 解法1
- 思路 ::
#+begin_src cpp :results output :includes '(<vector> <iostream> <algorithm> <unordered_set>) :main no :namespaces std
class Solution {
public:
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
       if (preorder.size() == 0 || inorder.size() == 0) return nullptr;
       TreeNode* root = new TreeNode(preorder[0]);
       int index = 0;
       for (int i = 0; i < inorder.size(); ++i) {
        if (preorder[0] == inorder[i]) {
            index = i;
            break;
        }
       }
       vector<int> left_preorder(preorder.begin() + 1, preorder.begin() + index + 1);
       vector<int> left_inorder(inorder.begin(), inorder.begin() + index);
       root->left = buildTree(left_preorder, left_inorder);
       vector<int> right_preorder(preorder.begin() + index + 1, preorder.end());
       vector<int> right_inorder(inorder.begin() + index + 1, inorder.end());
       root->right = buildTree(right_preorder, right_inorder);
       return root;
    }
};
#+end_src

**** 复杂度
+ 时间复杂度 ::
+ 空间复杂度 ::
**** 参考
[[https://www.bilibili.com/video/BV1XAYke2ETp/?vd_source=4441bc96046659b39d059d583f36ff52][bilibili]]
* [[https://leetcode.cn/problems/path-sum-iii/?envType=study-plan-v2&envId=top-100-liked][437.路径总和III]]
** 解法1
- 思路 ::
#+begin_src cpp :results output :includes '(<vector> <iostream> <algorithm> <unordered_set>) :main no :namespaces std
class Solution {
    int res = 0;
    void dfs(TreeNode* node, long long sum) {
        if (!node) return;
        if (node->val == sum) {
            ++res;
        }
        dfs(node->left, sum - node->val);
        dfs(node->right, sum - node->val);
    }
public:
    int pathSum(TreeNode* root, long long targetSum) {
        if (root) {
            dfs(root, targetSum);
            pathSum(root->left, targetSum);
            pathSum(root->right, targetSum);
        }
        return res;
    }
};
#+end_src

**** 复杂度
+ 时间复杂度 ::
+ 空间复杂度 ::
**** 参考
[[https://www.bilibili.com/video/BV1Lb4y1h7EV/?vd_source=4441bc96046659b39d059d583f36ff52][bilibili]]
* [[https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/description/?envType=study-plan-v2&envId=top-100-liked][236.二叉树的最近公共祖先]]
** 解法1
- 思路 ::
#+begin_src cpp :results output :includes '(<vector> <iostream> <algorithm> <unordered_set>) :main no :namespaces std
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if (root == q || root == p || root == NULL) return root;
        TreeNode* left = lowestCommonAncestor(root->left, p, q);
        TreeNode* right = lowestCommonAncestor(root->right, p, q);
        if (left != NULL && right != NULL) return root;
        if (left == NULL && right != NULL) return right;
        else if (left != NULL && right == NULL) return left;
        else return NULL;
    }
};
#+end_src

**** 复杂度
+ 时间复杂度 ::
+ 空间复杂度 ::
**** 参考
[[https://programmercarl.com/0236.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.html#%E6%80%9D%E8%B7%AF][代码随想录]]
* [[https://leetcode.cn/problems/binary-tree-maximum-path-sum/?envType=study-plan-v2&envId=top-100-liked][124.二叉树中的最大路径和]]
** 解法1:dfs
- 思路 ::
#+begin_src cpp :results output :includes '(<vector> <iostream> <algorithm> <unordered_set>) :main no :namespaces std
class Solution {
public:
    int maxPathSum(TreeNode* root) {
       int res = root->val;
       dfs(root, res);
       return res;
    }

    int dfs(TreeNode* root, int& res) {
        if (!root) {
            return 0;
        }
        int lmax = max(0, dfs(root->left, res));
        int rmax = max(0, dfs(root->right, res));
        res = max(res, lmax + rmax + root->val);
        return root->val + max(lmax, rmax);
    }
};
#+end_src

**** 复杂度
+ 时间复杂度 ::
+ 空间复杂度 ::
**** 参考
[[https://www.bilibili.com/video/BV12FYee2Eg6/?vd_source=4441bc96046659b39d059d583f36ff52][bilibili]]
* [[https://leetcode.cn/problems/number-of-islands/description/?envType=study-plan-v2&envId=top-100-liked][200.岛屿数量]]
** 解法1:bfs
- 思路 ::
#+begin_src cpp :results output :includes '(<vector> <iostream> <algorithm> <unordered_set>) :main no :namespaces std
class Solution {
public:
    int numIslands(vector<vector<char>>& grid) {
       int nums = 0;
       int rows = grid.size();
       if (!rows) return nums;
       int cols = grid[0].size();
       vector<vector<bool>> visit(rows, vector<bool>(cols, false));
       for (int row = 0; row < rows; ++row) {
        for (int col = 0; col < cols; ++col) {
            if (grid[row][col] == '1' && !visit[row][col]) {
                bfs(grid, row, col, visit);
                ++nums;
            }
        }
       }
       return nums;
    }

    void bfs(vector<vector<char>>& grid, int row, int col, vector<vector<bool>>& visit) {
        queue<pair<int, int>> q;
        q.push({row, col});
        visit[row][col] = true;
        while(!q.empty()) {
            pair<int, int> tmp = q.front();
            q.pop();
            vector<vector<int>> dirs = {{1,0}, {-1,0}, {0,1}, {0,-1}};
            for (int i = 0; i < dirs.size(); ++i) {
                int tmp_row = tmp.first + dirs[i][0];
                int tmp_col = tmp.second + dirs[i][1];
                if (tmp_row >= 0 && tmp_row < grid.size() && tmp_col >= 0 && tmp_col < grid[0].size() && grid[tmp_row][tmp_col] == '1' && !visit[tmp_row][tmp_col]) {
                    q.push({tmp_row, tmp_col});
                    visit[tmp_row][tmp_col] = true;
                }
            }
        }
    }
};
#+end_src

**** 复杂度
+ 时间复杂度 ::
+ 空间复杂度 ::
**** 参考
[[https://www.bilibili.com/video/BV1LUsMezEtq/?spm_id_from=333.337.search-card.all.click&vd_source=4441bc96046659b39d059d583f36ff52][bilibili]]
* [[https://leetcode.cn/problems/rotting-oranges/description/?envType=study-plan-v2&envId=top-100-liked][994.腐烂的橘子]]
** 解法1:bfs
- 思路 ::
#+begin_src cpp :results output :includes '(<vector> <iostream> <algorithm> <unordered_set>) :main no :namespaces std
class Solution {
public:
    int orangesRotting(vector<vector<int>>& grid) {
        queue<pair<int, int>> q;
        int time = 0, fresh = 0;
        for (int r = 0; r < grid.size(); ++r) {
            for (int c = 0; c < grid[0].size(); ++c) {
                if (grid[r][c] == 1) {
                    ++fresh;
                } else if (grid[r][c] == 2) {
                    q.push({r, c});
                }
            }
        }

        vector<pair<int, int>> dirs = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
        while (!q.empty() && fresh > 0) {
            int q_len = q.size();
            for (int i = 0; i < q_len; ++i) {
                auto cur = q.front();
                q.pop();
                for (auto dir : dirs) {
                    int row = cur.first + dir.first;
                    int col = cur.second + dir.second;
                    if (row < 0 || row >= grid.size() || col < 0 ||
                        col >= grid[0].size() || grid[row][col] != 1) {
                        continue;
                    }
                    grid[row][col] = 2;
                    q.push({row, col});
                    --fresh;
                }
            }
            ++time;
        }
        if (fresh) {
            return -1;
        } else {
            return time;
        }
    }
};
#+end_src

**** 复杂度
+ 时间复杂度 ::
+ 空间复杂度 ::
**** 参考
[[https://www.bilibili.com/video/BV12omGYuEc3/?spm_id_from=333.337.search-card.all.click&vd_source=4441bc96046659b39d059d583f36ff52][bilibili]]
* [[https://leetcode.cn/problems/course-schedule/?envType=study-plan-v2&envId=top-100-liked][207.课程表]]
** 解法1:bfs
- 思路 ::
#+begin_src cpp :results output :includes '(<vector> <iostream> <algorithm> <unordered_set>) :main no :namespaces std
class Solution {
public:
    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {
        map<int, list<int>> adjList;
        vector<int> indegree(numCourses, 0);
        for (auto p : prerequisites) {
            int start = p[1], end = p[0];
            adjList[start].push_back(end);
            ++indegree[end];
        }
        queue<int> q;
        for (int i = 0; i < indegree.size(); ++i) {
            if (indegree[i] == 0) {
                q.push(i);
            }
        }
        int cnt = 0;
        while (!q.empty()) {
            int course = q.front();
            q.pop();
            ++cnt;
            for (int adj:adjList[course]) {
                --indegree[adj];
                if (indegree[adj] == 0) {
                    q.push(adj);
                }
            }
        }
        return cnt == numCourses;
    }
};
#+end_src

**** 复杂度
+ 时间复杂度 ::
+ 空间复杂度 ::
**** 参考
[[https://www.bilibili.com/video/BV1jY411G7Jb/?vd_source=4441bc96046659b39d059d583f36ff52][bilibili]]
* [[https://leetcode.cn/problems/implement-trie-prefix-tree/?envType=study-plan-v2&envId=top-100-liked][208.实现Trie(前缀树)]]
** 解法1
- 思路 ::
#+begin_src cpp :results output :includes '(<vector> <iostream> <algorithm> <unordered_set>) :main no :namespaces std
class TrieNode {
public:
    unordered_map<char, TrieNode*> children;
    bool isEnd;
    TrieNode() {
        children.clear();
        isEnd = false;
    }
};

class Trie {
private:
    TrieNode* root;

public:
    Trie() { root = new TrieNode(); }

    void insert(string word) {
        TrieNode* cur = root;
        for (int i = 0; i < word.size(); ++i) {
            if (cur->children.count(word[i]) == 0)
                cur->children[word[i]] = new TrieNode();
            cur = cur->children[word[i]];
        }
        cur->isEnd = true;
    }

    bool search(string word) {
        TrieNode* cur = root;
        for (int i = 0; i < word.size(); ++i) {
            if (cur->children.count(word[i]) == 0)
                return false;
            cur = cur->children[word[i]];
        }
        return cur->isEnd == true;
    }

    bool startsWith(string prefix) {
        TrieNode* cur = root;
        for (int i = 0; i < prefix.size(); ++i) {
            if (cur->children.count(prefix[i]) == 0)
                return false;
            cur = cur->children[prefix[i]];
        }
        return true;
    }
};
#+end_src

**** 复杂度
+ 时间复杂度 ::
+ 空间复杂度 ::
**** 参考
[[https://www.bilibili.com/video/BV1dFpZeBE2u/?spm_id_from=333.337.search-card.all.click&vd_source=4441bc96046659b39d059d583f36ff52][bilibili]]
* [[https://leetcode.cn/problems/permutations/?envType=study-plan-v2&envId=top-100-liked][46.全排列]]
** 解法1
- 思路 ::
#+begin_src cpp :results output :includes '(<vector> <iostream> <algorithm> <unordered_set>) :main no :namespaces std
class Solution {
public:
    vector<vector<int>> result;
    vector<int> path;
    void backtracking(vector<int>& nums, vector<bool>& used) {
        if (path.size() == nums.size()) {
            result.push_back(path);
            return;
        }
        for (int i = 0; i < nums.size(); ++i) {
            if (used[i] == true) continue;
            used[i] = true;
            path.push_back(nums[i]);
            backtracking(nums, used);
            path.pop_back();
            used[i] = false;
        }
    }
    vector<vector<int>> permute(vector<int>& nums) {
        result.clear();
        path.clear();
        vector<bool> used(nums.size(), false);
        backtracking(nums, used);
        return result;
    }
};
#+end_src

**** 复杂度
+ 时间复杂度 ::
+ 空间复杂度 ::
**** 参考
[[https://programmercarl.com/0046.%E5%85%A8%E6%8E%92%E5%88%97.html#%E6%80%9D%E8%B7%AF][代码随想录]]
* [[https://leetcode.cn/problems/subsets/?envType=study-plan-v2&envId=top-100-liked][78.子集]]
** 解法1:回溯
- 思路 ::
#+begin_src cpp :results output :includes '(<vector> <iostream> <algorithm> <unordered_set>) :main no :namespaces std
class Solution {
private:
    vector<vector<int>> result;
    vector<int> path;
    void backtracking(vector<int>& nums, int startIndex) {
        result.push_back(path);
        if (startIndex >= nums.size()) {
            return;
        }
        for (int i = startIndex; i < nums.size(); ++i) {
            path.push_back(nums[i]);
            backtracking(nums, i + 1);
            path.pop_back();
        }
    }
public:
    vector<vector<int>> subsets(vector<int>& nums) {
       result.clear();
       path.clear();
       backtracking(nums, 0);
       return result;
    }
};
#+end_src

**** 复杂度
+ 时间复杂度 ::
+ 空间复杂度 ::
**** 参考
[[https://programmercarl.com/0078.%E5%AD%90%E9%9B%86.html#%E6%80%9D%E8%B7%AF][代码随想录]]
* [[https://leetcode.cn/problems/letter-combinations-of-a-phone-number/?envType=study-plan-v2&envId=top-100-liked][17.电话号码的字母组合]]
** 解法1:回溯
- 思路 ::
#+begin_src cpp :results output :includes '(<vector> <iostream> <algorithm> <unordered_set>) :main no :namespaces std
class Solution {
private:
    const string letterMap[10] = {
        "",
        "",
        "abc",
        "def",
        "ghi",
        "jkl",
        "mno",
        "pqrs",
        "tuv",
        "wxyz",
    };
public:
    vector<string> result;
    string s;
    void backtracking(const string& digits, int index) {
        if (index == digits.size()) {
            result.push_back(s);
            return;
        }
        int digit = digits[index] - '0';
        string letters = letterMap[digit];
        for (int i = 0; i < letters.size(); ++i) {
            s.push_back(letters[i]);
            backtracking(digits, index + 1);
            s.pop_back();
        }
    }
    vector<string> letterCombinations(string digits) {
        s.clear();
        result.clear();
        if (digits.size() == 0) {
            return result;
        }
        backtracking(digits, 0);
        return result;
    }
};
#+end_src

**** 复杂度
+ 时间复杂度 ::
+ 空间复杂度 ::
**** 参考
[[https://programmercarl.com/0017.%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88.html#%E6%80%9D%E8%B7%AF][代码随想录]]
* [[https://leetcode.cn/problems/combination-sum/?envType=study-plan-v2&envId=top-100-liked][39.组合总和]]
** 解法1:回溯
- 思路 ::
#+begin_src cpp :results output :includes '(<vector> <iostream> <algorithm> <unordered_set>) :main no :namespaces std
class Solution {
private:
    vector<vector<int>> result;
    vector<int> path;
    void backtracking(vector<int>& candidates, int target, int sum, int startIndex) {
        if (sum > target) {
            return;
        }
        if (sum == target) {
            result.push_back(path);
            return;
        }
        for (int i = startIndex; i < candidates.size(); ++i) {
            sum += candidates[i];
            path.push_back(candidates[i]);
            backtracking(candidates, target, sum, i);
            sum -= candidates[i];
            path.pop_back();
        }
    }
public:
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        result.clear();
        path.clear();
        backtracking(candidates, target, 0, 0);
        return result;
    }
}
#+end_src

**** 复杂度
+ 时间复杂度 ::
+ 空间复杂度 ::
**** 参考
[[https://programmercarl.com/0039.%E7%BB%84%E5%90%88%E6%80%BB%E5%92%8C.html#%E6%80%9D%E8%B7%AF][代码随想录]]
* [[https://leetcode.cn/problems/generate-parentheses/?envType=study-plan-v2&envId=top-100-liked][22.括号生成]]
** 解法1
- 思路 ::
#+begin_src cpp :results output :includes '(<vector> <iostream> <algorithm> <unordered_set>) :main no :namespaces std
class Solution {
    vector<string> ans;

public:
    vector<string> generateParenthesis(int n) {
        ans.clear();
        backtracking(0, 0, n, "");
        return ans;
    }

    void backtracking(int lc, int rc, int n, string seq) {
        if (lc == n && rc == n) {
            ans.push_back(seq);
            return;
        }
        if (lc < n)
            backtracking(lc + 1, rc, n, seq + "(");
        if (rc < n && lc > rc)
            backtracking(lc, rc + 1, n, seq + ")");
    }
}
#+end_src

**** 复杂度
+ 时间复杂度 ::
+ 空间复杂度 ::
**** 参考
[[https://blog.lichangao.com/daily_practice/leetcode/backtracking/achieve.html#_0022-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90][鲤鱼笔记]]
* [[https://leetcode.cn/problems/word-search/description/?envType=study-plan-v2&envId=top-100-liked][79.单词搜索]]
** 解法1:回溯
- 思路 ::
#+begin_src cpp :results output :includes '(<vector> <iostream> <algorithm> <unordered_set>) :main no :namespaces std
class Solution {
public:
    bool exist(vector<vector<char>>& board, string word) {
        int rows = board.size();
        int cols = board[0].size();
        vector<vector<bool>> visit(rows, vector<bool>(cols, false));
        for (int row = 0; row < rows; ++row) {
            for (int col = 0; col < cols; ++col) {
                if (dfs(board, word, row, col, 0, visit)) {
                    return true;
                }
            }
        }
        return false;
    }

    bool dfs(vector<vector<char>>& board, string word, int row, int col,
             int index, vector<vector<bool>>& visit) {
        if (index == word.length()) {
            return true;
        }
        int rows = board.size();
        int cols = board[0].size();
        if (row >= rows || row < 0 || col >= cols || col < 0 ||
            board[row][col] != word[index] || visit[row][col]) {
            return false;
        }

        visit[row][col] = true;
        bool res = false;
        res |= dfs(board, word, row + 1, col, index + 1, visit);
        res |= dfs(board, word, row, col + 1, index + 1, visit);
        res |= dfs(board, word, row - 1, col, index + 1, visit);
        res |= dfs(board, word, row, col - 1, index + 1, visit);
        visit[row][col] = false;
        return res;
    }
};
#+end_src

**** 复杂度
+ 时间复杂度 ::
+ 空间复杂度 ::
**** 参考
[[https://www.bilibili.com/video/BV1HBpTe6EvS/?spm_id_from=333.337.search-card.all.click&vd_source=4441bc96046659b39d059d583f36ff52][bilibili]]
* [[https://leetcode.cn/problems/palindrome-partitioning/description/?envType=study-plan-v2&envId=top-100-liked][131.分割回文串]]
** 解法1:回溯
- 思路 ::
#+begin_src cpp :results output :includes '(<vector> <iostream> <algorithm> <unordered_set>) :main no :namespaces std
class Solution {
private:
    vector<vector<string>> result;
    vector<string> path;
    void backtracking (const string& s, int startIndex) {
        if (startIndex >= s.size()) {
            result.push_back(path);
            return;
        }
        for (int i = startIndex; i < s.size(); ++i) {
            if (isPalindrome(s, startIndex, i)) {
                string str = s.substr(startIndex, i - startIndex + 1);
                path.push_back(str);
            } else {
                continue;
            }
            backtracking(s, i + 1);
            path.pop_back();
        }
    }
    bool isPalindrome(const string& s, int start, int end) {
        for (int i = start, j = end; i < j; ++i, --j) {
            if (s[i] != s[j]) {
                return false;
            }
        }
        return true;
    }
public:
    vector<vector<string>> partition(string s) {
       result.clear();
       path.clear();
       backtracking(s, 0);
       return result;
    }
};
#+end_src

**** 复杂度
+ 时间复杂度 ::
+ 空间复杂度 ::
**** 参考
[[https://programmercarl.com/0131.%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2.html#%E6%80%9D%E8%B7%AF][代码随想录]]
* [[https://leetcode.cn/problems/n-queens/?envType=study-plan-v2&envId=top-100-liked][51.N皇后]]
** 解法1
- 思路 ::
#+begin_src cpp :results output :includes '(<vector> <iostream> <algorithm> <unordered_set>) :main no :namespaces std
class Solution {
private:
    vector<vector<string>> result;
    void backtracking(int n, int row, vector<string>& chessboard) {
        if (row == n) {
            result.push_back(chessboard);
            return;
        }
        for (int col = 0; col < n; ++col) {
            if (isValid(row, col, chessboard, n)) {
                chessboard[row][col] = 'Q';
                backtracking(n, row + 1, chessboard);
                chessboard[row][col] = '.';
            }
        }
    }
    bool isValid(int row, int col, vector<string>& chessboard, int n) {
        for (int i = 0; i < row; ++i) {
            if (chessboard[i][col] == 'Q') {
                return false;
            }
        }
        for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; --i, --j) {
            if (chessboard[i][j] == 'Q') {
                return false;
            }
        }
        for (int i = row - 1, j = col + 1; i >= 0 && j < n; --i, ++j) {
            if (chessboard[i][j] == 'Q') {
                return false;
            }
        }
        return true;
    }

public:
    vector<vector<string>> solveNQueens(int n) {
        result.clear();
        vector<string> chessboard(n, string(n, '.'));
        backtracking(n, 0, chessboard);
        return result;
    }
};
#+end_src

**** 复杂度
+ 时间复杂度 ::
+ 空间复杂度 ::
**** 参考
[[https://programmercarl.com/0051.N%E7%9A%87%E5%90%8E.html#%E6%80%9D%E8%B7%AF][代码随想录]]
* [[https://leetcode.cn/problems/search-insert-position/?envType=study-plan-v2&envId=top-100-liked][35.搜索插入位置]]
** 解法1:二分查找
- 思路 ::
#+begin_src cpp :results output :includes '(<vector> <iostream> <algorithm> <unordered_set>) :main no :namespaces std
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int low = 0, high = nums.size() - 1;
        while (low <= high) {
            int mid = (low + high) / 2;
            if (nums[mid] == target) {
                return mid;
            } else if (nums[mid] > target) {
                high = mid - 1;
            } else {
                low = mid + 1;
            }
        }
        return low;
    }
};
#+end_src

**** 复杂度
+ 时间复杂度 ::
+ 空间复杂度 ::
**** 参考
[[https://www.bilibili.com/video/BV1CzymYoEwo/?spm_id_from=333.337.search-card.all.click&vd_source=4441bc96046659b39d059d583f36ff52][bilibili]]
* [[https://leetcode.cn/problems/search-a-2d-matrix/?envType=study-plan-v2&envId=top-100-liked][74.搜索二维矩阵]]
** 解法1:二分查找
- 思路 ::
#+begin_src cpp :results output :includes '(<vector> <iostream> <algorithm> <unordered_set>) :main no :namespaces std
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        if (matrix.empty() || matrix[0].empty()) return false; // 处理空矩阵
        int m = matrix.size(), n = matrix[0].size();
        int l = 0, r = m * n - 1;

        while (l <= r) {
            int mid = l + (r - l) / 2; // 避免潜在的整数溢出
            int val = matrix[mid / n][mid % n];
            if (val == target) {
                return true;
            } else if (val < target) {
                l = mid + 1;
            } else {
                r = mid - 1;
            }
        }
        return false; // 未找到 target
    }
};
#+end_src

**** 复杂度
+ 时间复杂度 ::
+ 空间复杂度 ::
**** 参考
[[https://www.bilibili.com/video/BV1xu411q7qg/?spm_id_from=333.337.search-card.all.click&vd_source=4441bc96046659b39d059d583f36ff52][bilibili]]
* [[https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/?envType=study-plan-v2&envId=top-100-liked][34.在排序数组中查找元素的第一个和最后一个位置]] [/]
** 解法1:二分查找
- 思路 ::
#+begin_src cpp :results output :includes '(<vector> <iostream> <algorithm> <unordered_set>) :main no :namespaces std
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        int left = binSearch(nums, target, true);
        int right = binSearch(nums, target, false);
        return {left, right};
    }

    int binSearch(vector<int>& nums, int target, bool isLeft) {
        int left = 0, right = nums.size() - 1;
        int index = -1;
        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] > target) {
                right = mid - 1;
            } else if (nums[mid] < target) {
                left = mid + 1;
            } else {
                index = mid;
                if (isLeft) {
                    right = mid - 1;
                } else {
                    left = mid + 1;
                }
            }
        }
        return index;
    }
};
#+end_src

**** 复杂度
+ 时间复杂度 ::
+ 空间复杂度 ::
**** 参考
[[https://www.bilibili.com/video/BV1rjSnY4Evi/?spm_id_from=333.337.search-card.all.click&vd_source=4441bc96046659b39d059d583f36ff52][bilibili]]
* [[https://leetcode.cn/problems/search-in-rotated-sorted-array/description/?envType=study-plan-v2&envId=top-100-liked][33.搜索旋转排序数组]]
** 解法1
- 思路 ::
#+begin_src cpp :results output :includes '(<vector> <iostream> <algorithm> <unordered_set>) :main no :namespaces std
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0, right = nums.size() - 1;
        while (left <= right) {
            int mid = left + (right - left)/2;
            if (nums[mid] == target) {
                return mid;
            }

            if (nums[left] <= nums[mid]) {
                if (nums[left] <= target && target < nums[mid]) {
                    right = mid - 1;
                } else {
                    left = mid + 1;
                }
            } else {
                if (target > nums[mid] && target <= nums[right]) {
                    left = mid + 1;
                } else {
                    right = mid - 1;
                }
            }
        }
        return -1;
    }
};
#+end_src

**** 复杂度
+ 时间复杂度 ::
+ 空间复杂度 ::
**** 参考
[[https://www.bilibili.com/video/BV1tz421r7xC/?spm_id_from=333.337.search-card.all.click&vd_source=4441bc96046659b39d059d583f36ff52][bilibili]]
* [[https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/?envType=study-plan-v2&envId=top-100-liked][153.寻找旋转排序数组中的最小值]]
** 解法1
- 思路 ::
#+begin_src cpp :results output :includes '(<vector> <iostream> <algorithm> <unordered_set>) :main no :namespaces std
class Solution {
public:
    int findMin(vector<int>& nums) {
        int left = 0, right = nums.size() - 1;
        int mid = 0;
        while (left <= right) {
            mid = left + (right - left) / 2;
            if (nums[left] <= nums[mid] && nums[mid] <= nums[right]) {
                return nums[left];
            } else if (nums[left] <= nums[mid]) {
                left = mid + 1;
            } else if (nums[right] >= nums[mid]) {
                right = mid;
            }
        }
        return -1;
    }
};
#+end_src

**** 复杂度
+ 时间复杂度 ::
+ 空间复杂度 ::
**** 参考
[[https://www.bilibili.com/video/BV1VC41157ha/?spm_id_from=333.337.search-card.all.click&vd_source=4441bc96046659b39d059d583f36ff52][bilibili]]
* [[https://leetcode.cn/problems/median-of-two-sorted-arrays/?envType=study-plan-v2&envId=top-100-liked][4.寻找两个正序数组的中位数]]
** 解法1
- 思路 ::
#+begin_src cpp :results output :includes '(<vector> <iostream> <algorithm> <unordered_set>) :main no :namespaces std

#+end_src

**** 复杂度
+ 时间复杂度 ::
+ 空间复杂度 ::
**** 参考
* [[https://leetcode.cn/problems/valid-parentheses/?envType=study-plan-v2&envId=top-100-liked][20.有效的括号]]
** 解法1
- 思路 ::
#+begin_src cpp :results output :includes '(<vector> <iostream> <algorithm> <unordered_set>) :main no :namespaces std

#+end_src

**** 复杂度
+ 时间复杂度 ::
+ 空间复杂度 ::
**** 参考
* [[https://leetcode.cn/problems/min-stack/?envType=study-plan-v2&envId=top-100-liked][155.最小栈]]
** 解法1
- 思路 ::
#+begin_src cpp :results output :includes '(<vector> <iostream> <algorithm> <unordered_set>) :main no :namespaces std

#+end_src

**** 复杂度
+ 时间复杂度 ::
+ 空间复杂度 ::
**** 参考
* [[https://leetcode.cn/problems/decode-string/?envType=study-plan-v2&envId=top-100-liked][394.字符串解码]]
** 解法1
- 思路 ::
#+begin_src cpp :results output :includes '(<vector> <iostream> <algorithm> <unordered_set>) :main no :namespaces std

#+end_src

**** 复杂度
+ 时间复杂度 ::
+ 空间复杂度 ::
**** 参考
* [[https://leetcode.cn/problems/daily-temperatures/?envType=study-plan-v2&envId=top-100-liked][739.每日温度]]
** 解法1
- 思路 ::
#+begin_src cpp :results output :includes '(<vector> <iostream> <algorithm> <unordered_set>) :main no :namespaces std

#+end_src

**** 复杂度
+ 时间复杂度 ::
+ 空间复杂度 ::
**** 参考
* [[https://leetcode.cn/problems/largest-rectangle-in-histogram/?envType=study-plan-v2&envId=top-100-liked][84.柱状图中最大的矩阵]]
** 解法1
- 思路 ::
#+begin_src cpp :results output :includes '(<vector> <iostream> <algorithm> <unordered_set>) :main no :namespaces std

#+end_src

**** 复杂度
+ 时间复杂度 ::
+ 空间复杂度 ::
**** 参考
* [[https://leetcode.cn/problems/kth-largest-element-in-an-array/?envType=study-plan-v2&envId=top-100-liked][215.数组中的第K个最大元素]]
** 解法1
- 思路 ::
#+begin_src cpp :results output :includes '(<vector> <iostream> <algorithm> <unordered_set>) :main no :namespaces std

#+end_src

**** 复杂度
+ 时间复杂度 ::
+ 空间复杂度 ::
**** 参考
* [[https://leetcode.cn/problems/top-k-frequent-elements/?envType=study-plan-v2&envId=top-100-liked][347.前K个高频元素]]
** 解法1
- 思路 ::
#+begin_src cpp :results output :includes '(<vector> <iostream> <algorithm> <unordered_set>) :main no :namespaces std

#+end_src

**** 复杂度
+ 时间复杂度 ::
+ 空间复杂度 ::
**** 参考
* [[https://leetcode.cn/problems/find-median-from-data-stream/?envType=study-plan-v2&envId=top-100-liked][295.数据流的中位数]]
** 解法1
- 思路 ::
#+begin_src cpp :results output :includes '(<vector> <iostream> <algorithm> <unordered_set>) :main no :namespaces std

#+end_src

**** 复杂度
+ 时间复杂度 ::
+ 空间复杂度 ::
**** 参考
* [[https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/?envType=study-plan-v2&envId=top-100-liked][121.买卖股票的最佳时机]]
** 解法1
- 思路 ::
#+begin_src cpp :results output :includes '(<vector> <iostream> <algorithm> <unordered_set>) :main no :namespaces std

#+end_src

**** 复杂度
+ 时间复杂度 ::
+ 空间复杂度 ::
**** 参考
* [[https://leetcode.cn/problems/jump-game/?envType=study-plan-v2&envId=top-100-liked][55.跳跃游戏]]
** 解法1
- 思路 ::
#+begin_src cpp :results output :includes '(<vector> <iostream> <algorithm> <unordered_set>) :main no :namespaces std

#+end_src

**** 复杂度
+ 时间复杂度 ::
+ 空间复杂度 ::
**** 参考
* [[https://leetcode.cn/problems/jump-game-ii/?envType=study-plan-v2&envId=top-100-liked][45.跳跃游戏II]]
** 解法1
- 思路 ::
#+begin_src cpp :results output :includes '(<vector> <iostream> <algorithm> <unordered_set>) :main no :namespaces std

#+end_src

**** 复杂度
+ 时间复杂度 ::
+ 空间复杂度 ::
**** 参考
* [[https://leetcode.cn/problems/partition-labels/?envType=study-plan-v2&envId=top-100-liked][763.划分字母区间]]
** 解法1
- 思路 ::
#+begin_src cpp :results output :includes '(<vector> <iostream> <algorithm> <unordered_set>) :main no :namespaces std

#+end_src

**** 复杂度
+ 时间复杂度 ::
+ 空间复杂度 ::
**** 参考
* 1
** 解法1
- 思路 ::
#+begin_src cpp :results output :includes '(<vector> <iostream> <algorithm> <unordered_set>) :main no :namespaces std

#+end_src

**** 复杂度
+ 时间复杂度 ::
+ 空间复杂度 ::
**** 参考
* 1
** 解法1
- 思路 ::
#+begin_src cpp :results output :includes '(<vector> <iostream> <algorithm> <unordered_set>) :main no :namespaces std

#+end_src

**** 复杂度
+ 时间复杂度 ::
+ 空间复杂度 ::
**** 参考
* 1
** 解法1
- 思路 ::
#+begin_src cpp :results output :includes '(<vector> <iostream> <algorithm> <unordered_set>) :main no :namespaces std

#+end_src

**** 复杂度
+ 时间复杂度 ::
+ 空间复杂度 ::
**** 参考
* 1
** 解法1
- 思路 ::
#+begin_src cpp :results output :includes '(<vector> <iostream> <algorithm> <unordered_set>) :main no :namespaces std

#+end_src

**** 复杂度
+ 时间复杂度 ::
+ 空间复杂度 ::
**** 参考
* 1
** 解法1
- 思路 ::
#+begin_src cpp :results output :includes '(<vector> <iostream> <algorithm> <unordered_set>) :main no :namespaces std

#+end_src

**** 复杂度
+ 时间复杂度 ::
+ 空间复杂度 ::
**** 参考

* 1
** 解法1
- 思路 ::
#+begin_src cpp :results output :includes '(<vector> <iostream> <algorithm> <unordered_set>) :main no :namespaces std

#+end_src

**** 复杂度
+ 时间复杂度 ::
+ 空间复杂度 ::
**** 参考
* 1
** 解法1
- 思路 ::
#+begin_src cpp :results output :includes '(<vector> <iostream> <algorithm> <unordered_set>) :main no :namespaces std

#+end_src

**** 复杂度
+ 时间复杂度 ::
+ 空间复杂度 ::
**** 参考
* 1
** 解法1
- 思路 ::
#+begin_src cpp :results output :includes '(<vector> <iostream> <algorithm> <unordered_set>) :main no :namespaces std

#+end_src

**** 复杂度
+ 时间复杂度 ::
+ 空间复杂度 ::
**** 参考
* 1
** 解法1
- 思路 ::
#+begin_src cpp :results output :includes '(<vector> <iostream> <algorithm> <unordered_set>) :main no :namespaces std

#+end_src

**** 复杂度
+ 时间复杂度 ::
+ 空间复杂度 ::
**** 参考
* 1
** 解法1
- 思路 ::
#+begin_src cpp :results output :includes '(<vector> <iostream> <algorithm> <unordered_set>) :main no :namespaces std

#+end_src

**** 复杂度
+ 时间复杂度 ::
+ 空间复杂度 ::
**** 参考
* 1
** 解法1
- 思路 ::
#+begin_src cpp :results output :includes '(<vector> <iostream> <algorithm> <unordered_set>) :main no :namespaces std

#+end_src

**** 复杂度
+ 时间复杂度 ::
+ 空间复杂度 ::
**** 参考
* 1
** 解法1
- 思路 ::
#+begin_src cpp :results output :includes '(<vector> <iostream> <algorithm> <unordered_set>) :main no :namespaces std

#+end_src

**** 复杂度
+ 时间复杂度 ::
+ 空间复杂度 ::
**** 参考
* 1
** 解法1
- 思路 ::
#+begin_src cpp :results output :includes '(<vector> <iostream> <algorithm> <unordered_set>) :main no :namespaces std

#+end_src

**** 复杂度
+ 时间复杂度 ::
+ 空间复杂度 ::
**** 参考
* 1
** 解法1
- 思路 ::
#+begin_src cpp :results output :includes '(<vector> <iostream> <algorithm> <unordered_set>) :main no :namespaces std

#+end_src

**** 复杂度
+ 时间复杂度 ::
+ 空间复杂度 ::
**** 参考


* 1
** 解法1
- 思路 ::
#+begin_src cpp :results output :includes '(<vector> <iostream> <algorithm> <unordered_set>) :main no :namespaces std

#+end_src

**** 复杂度
+ 时间复杂度 ::
+ 空间复杂度 ::
**** 参考
* 1
** 解法1
- 思路 ::
#+begin_src cpp :results output :includes '(<vector> <iostream> <algorithm> <unordered_set>) :main no :namespaces std

#+end_src

**** 复杂度
+ 时间复杂度 ::
+ 空间复杂度 ::
**** 参考

* 1
** 解法1
- 思路 ::
#+begin_src cpp :results output :includes '(<vector> <iostream> <algorithm> <unordered_set>) :main no :namespaces std

#+end_src

**** 复杂度
+ 时间复杂度 ::
+ 空间复杂度 ::
**** 参考
