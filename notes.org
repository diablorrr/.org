#+TAGS: cpp(c) cmake(m) 网络(n) emacs(e) 多线程(p)
#+title: Notes


* Inbox
** [2025-03-20 四]
dir 查看模块、方法
help 查看模块、函数的具体信息

** [2025-03-20 四]
std::set vs std::unordered_set
特性	std::set（红黑树）	std::unordered_set（哈希表）
底层数据结构	红黑树（Red-Black Tree）	哈希表（Hash Table）
元素存储顺序	有序（按 operator< 排序）	无序
插入复杂度
𝑂(log n)
O(logn)
𝑂
(
1
)
O(1) 平均，最坏
𝑂
(
𝑛
)
O(n)
删除复杂度
𝑂
(
log
⁡
𝑛
)
O(logn)
𝑂
(
1
)
O(1) 平均，最坏
𝑂
(
𝑛
)
O(n)
查找复杂度
𝑂
(
log
⁡
𝑛
)
O(logn)
𝑂
(
1
)
O(1) 平均，最坏
𝑂
(
𝑛
)
O(n)
范围查询	支持 (lower_bound() / upper_bound())	不支持
是否允许重复元素	否（可用 std::multiset）	否（可用 std::unordered_multiset）
适用场景	需要排序或范围查询	只需要快速查找

** [2025-03-20 四]
特性	unordered_map	map
底层数据结构	哈希表（Hash Table）	红黑树（Red-Black Tree）
键的顺序	无序存储	按键排序存储
查找时间复杂度	平均
𝑂(1)
O(1)，最坏 𝑂(𝑛)
O(n)
𝑂(log⁡ n)
O(logn)
插入时间复杂度	平均
𝑂(1)
O(1)，最坏 𝑂(𝑛)
O(n)
𝑂(log 𝑛)
O(logn)
删除时间复杂度	平均
𝑂
(
1
)
O(1)，最坏
𝑂
(
𝑛
)
O(n)
𝑂
(
log
⁡
𝑛
)
O(logn)
迭代器性能	遍历无序，性能较低	遍历有序，性能较好
是否支持范围查询	不支持	支持 lower_bound() / upper_bound()
适用场景	适用于快速查找，键无序	适用于有序存储和范围查询

** push_back() vs emplace_back()
| 函数                  | 作用                           | 额外的拷贝/移动    | 适用情况           |
|-----------------------+--------------------------------+--------------------+--------------------|
| push_back(T obj)      | 传入对象并插入 vector 末尾     | 需要一次拷贝或移动 | 适用于已构造的对象 |
| push_back(T&& obj)    | 传入右值对象并插入 vector 末尾 | 需要一次移动       | 适用于右值         |
| emplace_back(args...) | 直接在 vector 末尾构造对象     | 无拷贝/移动        | 适用于构造新对象   |



** lsp
变量lsp-completion-provider
用于选择lsp补全的后端
capf是一组函数，completion-at-point会依次调用capf里的函数
** llfc语录
做任何逻辑的时候 先实现 内存层面 => 缓存层面 => 数据库层面



** [2025-02-19 三]
同步、异步、阻塞、非阻塞 的关系和区别的表格：
| 类型       | 是否等待任务完成 | 调用方是否被挂起（暂停执行）         | 说明                                                                                     | 示例                                                |
|------------+------------------+--------------------------------------+------------------------------------------------------------------------------------------+-----------------------------------------------------|
| 同步阻塞   | 等待             | 线程被挂起，直到任务完成             | 最常见的同步方式，调用方必须等到任务完成后才能继续执行                                   | recv() 阻塞读取数据，直到收到数据才返回             |
| 同步非阻塞 | 等待             | 线程不会挂起，会不断轮询任务是否完成 | 仍然是同步的，但调用方不会被阻塞，而是主动轮询检查状态                                   | while (!done) check(); 轮询检查任务状态             |
| 异步阻塞   | 不等待           | 线程被挂起，任务完成后才恢复         | 任务本身是异步的，但调用方在等待结果时会被阻塞                                           | future.get()，异步任务，但 get() 仍然会阻塞当前线程 |
| 异步非阻塞 | 不等待           | 线程不会挂起，可以继续执行其他任务   | 最常见的异步方式，调用方在发起任务后可以立即继续做其他事，任务完成后用回调或事件通知结果 | aio_read() 进行异步 I/O 读，操作完成后回调通知      |
总结
同步 vs 异步：关注的是 任务是否需要等待完成。
阻塞 vs 非阻塞：关注的是 调用方是否被挂起，无法继续执行。
最优方案：异步非阻塞，因为它既不会等待任务完成，也不会挂起线程，通常用于高性能并发场景（如 事件驱动编程）。

** [2025-02-18 二] 小林
DMA（Direct Memory Access，直接内存访问）=> 允许硬件设备直接与系统内存进行数据传输，而无需 CPU 参与 => 在音频、视频、存储设备或网络传输中，DMA 可提高数据传输效率，减少 CPU 负担

Ring Buffer（环形缓冲区）=> 先进先出（FIFO）的数据结构，逻辑上呈环状，适用于数据流处理，如串口通信、音视频处理等。

NAPI（New API）是 Linux 内核中用于高效处理网络中断的机制 => 用于减少中断开销并提高网络吞吐量 => 中断触发（低负载时），启用轮询（高负载时），恢复中断（负载降低时）

poll 是 Linux 内核和用户空间提供的一种I/O 多路复用机制 => 用于监视多个文件描述符（如网络套接字、管道、设备文件等） => 当其中的某个文件描述符变为可读、可写或发生错误时，poll 能够通知进程进行相应操作

在 Linux 网络协议栈中，Socket 层（BSD Socket API） 充当了用户态应用程序与内核网络协议栈之间的桥梁，使应用程序能够使用统一的接口进行网络通信，而无需关心底层协议的细节

sk_buff（socket buffer）是 Linux 内核网络协议栈中用于存储和管理网络数据包的核心数据结构 => 它是 Linux 内核中的数据包缓冲区，用于存放从网卡接收的数据包（RX）或应用程序发送的数据包（TX）
** [2025-02-07 五]
notify_one()只通知wait()挂起的线程
| 可能阻塞的情况                            | 是否需要 notify_one()   |
|-------------------------------------------+-------------------------|
| 可能因 mutex_ 争用短暂阻塞，但不会 wait() | ❌ 不需要 notify_one() |
| 如果 connections_ 为空，则 wait() 挂起    | ✅ 需要 notify_one()   |


** 为什么构造函数加锁、析构函数不加锁
cpp中，对象的构造是在单线程中进行的，构造函数执行期间，对象还未被其他线程看到或使用；但是析构函数中，对象可能正在被其他多个线程使用



** asio
完成队列、事件循环、执行器、socket之间的关系：
io_context中的完成队列存放着代办任务
io_context启动事件循环来取出任务，执行其中的回调；事件调度
执行器将任务提交给io_context
socket具体的io对象，socket与执行器关联


** [2025-01-19 日]
promise 是用来设置值的，通常在生产者线程中使用。
future 是用来获取值的，通常在消费者线程中使用，可能会阻塞等待结果。

** 主线程退出，主进程就会回收资源；主线程崩溃，主进程就会回收所有资源，子进程崩溃没事


** c++11会把花括号解释成初始化操作

** [2025-01-15 三]
#+begin_src c++
std::string send_msg;
{
	std::lock_guard<std::mutex> lck_gurad(self->_send_mtx);
	self->_send_que.pop();
	if (self->_send_que.empty()) {
		return;
	}
	send_msg = self->_send_que.front();
}
self->SendCallBack(std::move(send_msg));
#+end_src
这段代码里的{}是为了控制锁的范围，lock_guard是RAII风格的锁管理器，在超出作用域后会解锁
** [2025-01-14 二] :emacs:
在 Doom Emacs 中，当你使用 :map 针对特定模式（如 pdf-view-mode）设置快捷键时，这些键绑定仅在该模式的 buffer 中生效，不会影响其他模式的快捷键设置，也不会与全局绑定冲突。

工作原理
全局绑定（如 global-set-key）会在所有 buffer 中生效，但会被局部绑定覆盖。
局部绑定（如 :map <mode>-map）仅在特定模式激活时生效，其他模式不会受到影响。

** [2025-01-14 二]
服务（Service） 和 服务器（Server） 是相关但不同的概念：
服务器（Server）：指运行服务的物理机器或虚拟机，可以是本地服务器、云服务器等。
服务（Service）：指运行在服务器上的软件或进程，提供特定功能，如 Web 服务、数据库服务等。
简单理解：
服务器是“硬件”，服务是“软件”。

** ldconfig更新缓存(刷新环境变量)
比如新安装一个库，使新安装的库可用，确保程序可以找到新的库


** [2025-01-11 六] :网络:
tcp服务器、http服务器、websocket服务器

** [2025-01-11 六] :网络:
在main函数中启动io_context，会有两个线程
主线程(main函数的线程)
运行io_context的线程

** [2025-01-11 六] :网络:
executor 负责定义如何以及在哪里执行异步操作
io_context 自带一个默认的 executor，当我们调用 post() 等操作时，实际上是在使用 io_context 的 executor 来调度任务


** [2025-01-11 六] :网络:
socket：发起网络事件（如数据可读、连接建立等）。
io_context：管理所有异步操作，维护任务队列并调度任务。
任务队列：io_context 中的队列，存储待执行的异步任务（回调函数）。
线程：调用 io_context.run()，从任务队列中取任务并执行。
回调函数：每个异步操作（如读写）对应的处理函数，由线程执行。
strand：确保在多线程环境下，某些操作（回调函数）按顺序在同一线程中执行。
executor：io_context 的执行器，负责任务调度，定义如何分配任务给线程。



** asio服务器并发编程的几种模型 :网络:
- 单线程
- 多线程IOServicePool
- 多线程IOThreadPool
- 协程



** [2025-01-09 四] :多线程:
lock_guard是不能使用条件变量的
要使用条件变量就得用unique_lock

** 线程和协程的使用场景 :多线程:
协程上下文开销更小
- 线程：通常用于计算密集型任务。线程可以在多核CPU上并行执行，适合需要大量计算的任务，比如复杂的数学运算、大规模的数据处理等。通过多线程，可以利用多核处理器的优势，提高计算效率。

- 协程：通常用于I/O密集型任务。协程轻量级，能够在单线程中异步执行多个任务，适合需要等待I/O操作（如网络请求、文件读写等）的场景。协程能够在等待I/O操作时切换执行其他任务，从而提高程序的效率。




** CMake的库文件搜索机制 :cmake:
当你写 target_link_libraries(main jsoncpp) 时，CMake 会按照以下规则来寻找并链接库文件：

默认库路径：CMake 会默认查找系统的标准库路径（如 /usr/lib、/usr/local/lib 等）。因此，如果你的 jsoncpp 库已经安装到这些路径下，它会自动找到并链接该库。

库名称约定：CMake 会根据库的名称来识别库文件。例如，jsoncpp 对应的库文件通常会被命名为 libjsoncpp.so（在 Linux 系统上）或者 libjsoncpp.a（静态库）。所以当你指定 jsoncpp 时，CMake 会在系统的标准库路径中查找与之对应的 libjsoncpp.so 或 libjsoncpp.a 文件。

link_directories：如果库文件位于非标准路径（如 /usr/local/lib），你可以使用 link_directories 显式地告诉 CMake 查找该路径。但如果你的库已经位于标准路径，CMake 会自动找到它。
