#+TAGS: cpp(c) cmake(m) 网络(n) emacs(e) 多线程(p)
#+title: Notes

* Inbox
** [2025-05-30 五]
选中区域，tab，使用snipaste
[[file:~/.org/interview/qt/qt.org::*Q_OBJECT宏展开后有哪些内容？][Q_OBJECT宏展开后有哪些内容？]]
** push_back() vs emplace_back()
| 函数                  | 作用                           | 额外的拷贝/移动    | 适用情况           |
|-----------------------+--------------------------------+--------------------+--------------------|
| push_back(T obj)      | 传入对象并插入 vector 末尾     | 需要一次拷贝或移动 | 适用于已构造的对象 |
| push_back(T&& obj)    | 传入右值对象并插入 vector 末尾 | 需要一次移动       | 适用于右值         |
| emplace_back(args...) | 直接在 vector 末尾构造对象     | 无拷贝/移动        | 适用于构造新对象   |

** lsp
变量lsp-completion-provider
用于选择lsp补全的后端
capf是一组函数，completion-at-point会依次调用capf里的函数
** llfc语录
做任何逻辑的时候 先实现 内存层面 => 缓存层面 => 数据库层面



** [2025-02-19 三]
同步、异步、阻塞、非阻塞 的关系和区别的表格：
| 类型       | 是否等待任务完成 | 调用方是否被挂起（暂停执行）         | 说明                                                                                     | 示例                                                |
|------------+------------------+--------------------------------------+------------------------------------------------------------------------------------------+-----------------------------------------------------|
| 同步阻塞   | 等待             | 线程被挂起，直到任务完成             | 最常见的同步方式，调用方必须等到任务完成后才能继续执行                                   | recv() 阻塞读取数据，直到收到数据才返回             |
| 同步非阻塞 | 等待             | 线程不会挂起，会不断轮询任务是否完成 | 仍然是同步的，但调用方不会被阻塞，而是主动轮询检查状态                                   | while (!done) check(); 轮询检查任务状态             |
| 异步阻塞   | 不等待           | 线程被挂起，任务完成后才恢复         | 任务本身是异步的，但调用方在等待结果时会被阻塞                                           | future.get()，异步任务，但 get() 仍然会阻塞当前线程 |
| 异步非阻塞 | 不等待           | 线程不会挂起，可以继续执行其他任务   | 最常见的异步方式，调用方在发起任务后可以立即继续做其他事，任务完成后用回调或事件通知结果 | aio_read() 进行异步 I/O 读，操作完成后回调通知      |
总结
同步 vs 异步：关注的是 任务是否需要等待完成。
阻塞 vs 非阻塞：关注的是 调用方是否被挂起，无法继续执行。
最优方案：异步非阻塞，因为它既不会等待任务完成，也不会挂起线程，通常用于高性能并发场景（如 事件驱动编程）。

** [2025-02-18 二] 小林
DMA（Direct Memory Access，直接内存访问）=> 允许硬件设备直接与系统内存进行数据传输，而无需 CPU 参与 => 在音频、视频、存储设备或网络传输中，DMA 可提高数据传输效率，减少 CPU 负担

Ring Buffer（环形缓冲区）=> 先进先出（FIFO）的数据结构，逻辑上呈环状，适用于数据流处理，如串口通信、音视频处理等。

NAPI（New API）是 Linux 内核中用于高效处理网络中断的机制 => 用于减少中断开销并提高网络吞吐量 => 中断触发（低负载时），启用轮询（高负载时），恢复中断（负载降低时）

poll 是 Linux 内核和用户空间提供的一种I/O 多路复用机制 => 用于监视多个文件描述符（如网络套接字、管道、设备文件等） => 当其中的某个文件描述符变为可读、可写或发生错误时，poll 能够通知进程进行相应操作

在 Linux 网络协议栈中，Socket 层（BSD Socket API） 充当了用户态应用程序与内核网络协议栈之间的桥梁，使应用程序能够使用统一的接口进行网络通信，而无需关心底层协议的细节

sk_buff（socket buffer）是 Linux 内核网络协议栈中用于存储和管理网络数据包的核心数据结构 => 它是 Linux 内核中的数据包缓冲区，用于存放从网卡接收的数据包（RX）或应用程序发送的数据包（TX）
** [2025-02-07 五]
notify_one()只通知wait()挂起的线程
| 可能阻塞的情况                            | 是否需要 notify_one()   |
|-------------------------------------------+-------------------------|
| 可能因 mutex_ 争用短暂阻塞，但不会 wait() | ❌ 不需要 notify_one() |
| 如果 connections_ 为空，则 wait() 挂起    | ✅ 需要 notify_one()   |


** 为什么构造函数加锁、析构函数不加锁
cpp中，对象的构造是在单线程中进行的，构造函数执行期间，对象还未被其他线程看到或使用；但是析构函数中，对象可能正在被其他多个线程使用

** 主线程退出，主进程就会回收资源；主线程崩溃，主进程就会回收所有资源，子进程崩溃没事

** c++11会把花括号解释成初始化操作

** [2025-01-15 三]
#+begin_src c++
std::string send_msg;
{
	std::lock_guard<std::mutex> lck_gurad(self->_send_mtx);
	self->_send_que.pop();
	if (self->_send_que.empty()) {
		return;
	}
	send_msg = self->_send_que.front();
}
self->SendCallBack(std::move(send_msg));
#+end_src
这段代码里的{}是为了控制锁的范围，lock_guard是RAII风格的锁管理器，在超出作用域后会解锁

** ldconfig更新缓存(刷新环境变量)
比如新安装一个库，使新安装的库可用，确保程序可以找到新的库

** 线程和协程的使用场景 :多线程:
协程上下文开销更小
- 线程：通常用于计算密集型任务。线程可以在多核CPU上并行执行，适合需要大量计算的任务，比如复杂的数学运算、大规模的数据处理等。通过多线程，可以利用多核处理器的优势，提高计算效率。

- 协程：通常用于I/O密集型任务。协程轻量级，能够在单线程中异步执行多个任务，适合需要等待I/O操作（如网络请求、文件读写等）的场景。协程能够在等待I/O操作时切换执行其他任务，从而提高程序的效率。

