#+TAGS: cpp(c) cmake(m) 网络(n) emacs(e) 多线程(p)
#+title: Notes
#+LAST_MODIFIED: 2025-03-14 10:48:52

* Inbox
** llfc语录
做任何逻辑的时候 先实现 内存层面 => 缓存层面 => 数据库层面


** 编译器看到一个声明的类，会自己去找.h和.cpp去找实现
** absl链接失败问题
自己的解决方式 cmake中将编译器clang++改成g++
[[https://blog.csdn.net/witton/article/details/144182568][MSYS2 MinGW64使用Protobuf新版本踩坑]]


** [2025-02-19 三]
同步、异步、阻塞、非阻塞 的关系和区别的表格：
| 类型       | 是否等待任务完成 | 调用方是否被挂起（暂停执行）         | 说明                                                                                     | 示例                                                |
|------------+------------------+--------------------------------------+------------------------------------------------------------------------------------------+-----------------------------------------------------|
| 同步阻塞   | 等待             | 线程被挂起，直到任务完成             | 最常见的同步方式，调用方必须等到任务完成后才能继续执行                                   | recv() 阻塞读取数据，直到收到数据才返回             |
| 同步非阻塞 | 等待             | 线程不会挂起，会不断轮询任务是否完成 | 仍然是同步的，但调用方不会被阻塞，而是主动轮询检查状态                                   | while (!done) check(); 轮询检查任务状态             |
| 异步阻塞   | 不等待           | 线程被挂起，任务完成后才恢复         | 任务本身是异步的，但调用方在等待结果时会被阻塞                                           | future.get()，异步任务，但 get() 仍然会阻塞当前线程 |
| 异步非阻塞 | 不等待           | 线程不会挂起，可以继续执行其他任务   | 最常见的异步方式，调用方在发起任务后可以立即继续做其他事，任务完成后用回调或事件通知结果 | aio_read() 进行异步 I/O 读，操作完成后回调通知      |
总结
同步 vs 异步：关注的是 任务是否需要等待完成。
阻塞 vs 非阻塞：关注的是 调用方是否被挂起，无法继续执行。
最优方案：异步非阻塞，因为它既不会等待任务完成，也不会挂起线程，通常用于高性能并发场景（如 事件驱动编程）。

** [2025-02-18 二] 小林
DMA（Direct Memory Access，直接内存访问）=> 允许硬件设备直接与系统内存进行数据传输，而无需 CPU 参与 => 在音频、视频、存储设备或网络传输中，DMA 可提高数据传输效率，减少 CPU 负担

Ring Buffer（环形缓冲区）=> 先进先出（FIFO）的数据结构，逻辑上呈环状，适用于数据流处理，如串口通信、音视频处理等。

NAPI（New API）是 Linux 内核中用于高效处理网络中断的机制 => 用于减少中断开销并提高网络吞吐量 => 中断触发（低负载时），启用轮询（高负载时），恢复中断（负载降低时）

poll 是 Linux 内核和用户空间提供的一种I/O 多路复用机制 => 用于监视多个文件描述符（如网络套接字、管道、设备文件等） => 当其中的某个文件描述符变为可读、可写或发生错误时，poll 能够通知进程进行相应操作

在 Linux 网络协议栈中，Socket 层（BSD Socket API） 充当了用户态应用程序与内核网络协议栈之间的桥梁，使应用程序能够使用统一的接口进行网络通信，而无需关心底层协议的细节

sk_buff（socket buffer）是 Linux 内核网络协议栈中用于存储和管理网络数据包的核心数据结构 => 它是 Linux 内核中的数据包缓冲区，用于存放从网卡接收的数据包（RX）或应用程序发送的数据包（TX）
** [2025-02-07 五]
notify_one()只通知wait()挂起的线程
| 可能阻塞的情况                            | 是否需要 notify_one()   |
|-------------------------------------------+-------------------------|
| 可能因 mutex_ 争用短暂阻塞，但不会 wait() | ❌ 不需要 notify_one() |
| 如果 connections_ 为空，则 wait() 挂起    | ✅ 需要 notify_one()   |


** 为什么构造函数加锁、析构函数不加锁
cpp中，对象的构造是在单线程中进行的，构造函数执行期间，对象还未被其他线程看到或使用；但是析构函数中，对象可能正在被其他多个线程使用

** [2025-02-07 五]
std::atomic<bool>能够在不依赖锁的情况下，提供安全的并发访问保证
不同于bool，std::atomic<bool>具有原子性

** [2025-02-05 三]
ldd app  # Linux: 检查可执行文件的动态库依赖

** asio
完成队列、事件循环、执行器、socket之间的关系：
io_context中的完成队列存放着代办任务
io_context启动事件循环来取出任务，执行其中的回调；事件调度
执行器将任务提交给io_context
socket具体的io对象，socket与执行器关联


** [2025-01-24 五] :cpp:
右值引用是右值具名，只是代表右值，用于减少复制构造，本身是左值
** [2025-01-24 五] :cpp:
decltype推断表达式的类型

** [2025-01-19 日]
promise 是用来设置值的，通常在生产者线程中使用。
future 是用来获取值的，通常在消费者线程中使用，可能会阻塞等待结果。

** 主线程退出，主进程就会回收资源；主线程崩溃，主进程就会回收所有资源，子进程崩溃没事


** c++11会把花括号解释成初始化操作

** [2025-01-15 三]
#+begin_src c++
std::string send_msg;
{
	std::lock_guard<std::mutex> lck_gurad(self->_send_mtx);
	self->_send_que.pop();
	if (self->_send_que.empty()) {
		return;
	}
	send_msg = self->_send_que.front();
}
self->SendCallBack(std::move(send_msg));
#+end_src
这段代码里的{}是为了控制锁的范围，lock_guard是RAII风格的锁管理器，在超出作用域后会解锁
** [2025-01-14 二] :emacs:
在 Doom Emacs 中，当你使用 :map 针对特定模式（如 pdf-view-mode）设置快捷键时，这些键绑定仅在该模式的 buffer 中生效，不会影响其他模式的快捷键设置，也不会与全局绑定冲突。

工作原理
全局绑定（如 global-set-key）会在所有 buffer 中生效，但会被局部绑定覆盖。
局部绑定（如 :map <mode>-map）仅在特定模式激活时生效，其他模式不会受到影响。

** [2025-01-14 二]
服务器 服务

** ldconfig更新缓存(刷新环境变量)
比如新安装一个库，使新安装的库可用，确保程序可以找到新的库





** pdf中高亮勾画区域 :emacs:
pdf-annot-add-highlight-markup-annotation

pdf-tools使用鼠标勾画的细粒度设置
在pdf鼠标右键 => Select style

*


** [2025-01-08 三] :网络:
*** protobuf
效率高，可读性差
服务器和服务器通信
*** jsoncpp
效率低，简单，可读性好
客户端和服务器通信
** [2025-01-11 六] :网络:
tcp服务器、http服务器、websocket服务器

** [2025-01-11 六] :网络:
在main函数中启动io_context，会有两个线程
主线程(main函数的线程)
运行io_context的线程

** [2025-01-11 六] :网络:
executor 负责定义如何以及在哪里执行异步操作
io_context 自带一个默认的 executor，当我们调用 post() 等操作时，实际上是在使用 io_context 的 executor 来调度任务
** [2025-01-11 六] :cpp:
cpp 20标准引入协程



** [2025-01-11 六] :网络:
socket：发起网络事件（如数据可读、连接建立等）。
io_context：管理所有异步操作，维护任务队列并调度任务。
任务队列：io_context 中的队列，存储待执行的异步任务（回调函数）。
线程：调用 io_context.run()，从任务队列中取任务并执行。
回调函数：每个异步操作（如读写）对应的处理函数，由线程执行。
strand：确保在多线程环境下，某些操作（回调函数）按顺序在同一线程中执行。
executor：io_context 的执行器，负责任务调度，定义如何分配任务给线程。



** asio服务器并发编程的几种模型 :网络:
- 单线程
- 多线程IOServicePool
- 多线程IOThreadPool
- 协程



** [2025-01-09 四] :多线程:
lock_guard是不能使用条件变量的
要使用条件变量就得用unique_lock

** 线程和协程的使用场景 :多线程:
协程上下文开销更小
- 线程：通常用于计算密集型任务。线程可以在多核CPU上并行执行，适合需要大量计算的任务，比如复杂的数学运算、大规模的数据处理等。通过多线程，可以利用多核处理器的优势，提高计算效率。

- 协程：通常用于I/O密集型任务。协程轻量级，能够在单线程中异步执行多个任务，适合需要等待I/O操作（如网络请求、文件读写等）的场景。协程能够在等待I/O操作时切换执行其他任务，从而提高程序的效率。




** CMake的库文件搜索机制 :cmake:
当你写 target_link_libraries(main jsoncpp) 时，CMake 会按照以下规则来寻找并链接库文件：

默认库路径：CMake 会默认查找系统的标准库路径（如 /usr/lib、/usr/local/lib 等）。因此，如果你的 jsoncpp 库已经安装到这些路径下，它会自动找到并链接该库。

库名称约定：CMake 会根据库的名称来识别库文件。例如，jsoncpp 对应的库文件通常会被命名为 libjsoncpp.so（在 Linux 系统上）或者 libjsoncpp.a（静态库）。所以当你指定 jsoncpp 时，CMake 会在系统的标准库路径中查找与之对应的 libjsoncpp.so 或 libjsoncpp.a 文件。

link_directories：如果库文件位于非标准路径（如 /usr/local/lib），你可以使用 link_directories 显式地告诉 CMake 查找该路径。但如果你的库已经位于标准路径，CMake 会自动找到它。
