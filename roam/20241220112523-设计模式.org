:PROPERTIES:
:ID:       2664db9d-1e4e-4ced-acb7-9e3b3d3962d1
:NOTER_DOCUMENT: /home/yoshiki01/Documents/3-(软件工程)设计模式v1.31（全部）.pdf
:NOTER_PAGE: 39
:VERSION: 1.0
:END:
#+title: 设计模式
#+filetags: book
#+EXPORT_FILE_NAME: ~/export/

* TODO 什么是设计模式
:PROPERTIES:
:NOTER_PAGE: 5
:END:
- 定义：设计模式是一套经过反复使用，多人知晓的，经过分类编目的 *代码设计经验的总结*
** 设计模式和框架
:PROPERTIES:
:NOTER_PAGE: 6
:END:
可复用面向对象软件系统，分为3类：
1. 应用程序：平时开发的具体软件
2. 工具箱：Java的API属于工具箱
3. 框架：一组相互协作的类
** 面向对象的三个基本特征：封装、继承、多态
- 封装：隐藏实现细节
- 继承：代码的重用与扩展，is-a的关系
- 多态：[[id:a222dfec-4f8e-48be-8629-b0ab2aa9f361][接口]]重用，使得可以调用"家谱"中任意类的实例的某一属性
** UML类图（依赖、关联(聚合、组合)、泛化、实现） :ATTACH:
:PROPERTIES:
:NOTER_PAGE: 35
:ID:       2c75a978-0a8e-417c-ab76-ca3ce8878af1
:ORG-IMAGE-ACTUAL-WIDTH: 700
:END:
[[attachment:_20241221_155903screenshot.png]]
*** 依赖
- 定义： *两个独立对象* ，有下面三种表现形式之一时。在类的四种关系中耦合最小的。
**** 使用
# 以Water类和Animal类为例，Animal依赖于Water
1. Water是全局类，则Animal类可以调用它
2. Water类是Animal类 *某个方法中的变量*
3. Water类是Animal类中 *某个方法的参数或返回值*
*** 关联
- 定义： *两个独立对象* ，其中一个对象的 *实例* 作为另一个对象的 *成员属性* 时。
**** 单向关联和双向关联
- 单向关联：如定义里所述
- 双向关联：两个独立对象，双方类中都有对方的实例
**** 聚合关系和组合关系
- 聚合、组合都是特殊的关联关系。
  # 即都是B类的实例作为A类的 成员属性。
***** 区别
1. 构造函数不同
   - 组合：在对象A的构造函数中创建对象B的实例
   - 聚合：在对象A之外创建了对象B的实例，创建后，作为对象A构造函数的参数传入
     # 由此可见聚合中B类的实例可以脱离A类存在，而组合中的A、B类同生死
2. 信息封装性不同(?)
*** 泛化(继承)
- 定义：B类继承A类所有描述，且可以对A类进行扩展。体现 *Is-A* 的关系。
**** 作用
1. 实现 代码复用
2. 实现 多态
*** 实现
- 定义：针对接口和抽象类而言，实现接口和抽象类的类必须实现它们的方法
  # 上述为Java的说法。
  # 在C++中，使用抽象类代替接口，使用泛化关系代替实现关系。
** 面向对象软件设计原则（设计模式的七大原则）
|-------------------+--------------------------------------------------------------------------------+--------|
| 名称              | 简介                                                                           | 重要性 |
|-------------------+--------------------------------------------------------------------------------+--p------|
| 单一职责原则(SRP) | 类的职责要单一，不能将太多职责放入同一个类中                                   | OOOOX  |
| 开闭原则(OCP)     | 软件实体对扩展开放，对修改关闭。不修改一个软件实体的基础上去扩展其功能         | OOOOO  |
| 里氏代换原则(LSP) | 一个可以接受基类对象的地方必然可以接受一个子类对象                             | OOOOX  |
| 依赖倒转原则(DIP) | 针对抽象层编程，不要针对具体类编程                                             | OOOOO  |
| 接口隔离原则(ISP) | 使用多个专门的接口来取代一个统一的接口                                         | OOXXX  |
| 合成复用原则(CRP) | 尽量多用组合和聚合关联关系，少用继承                                           | OOOOX  |
| 迪米特法则(LoD)   | 如果两个类不必彼此直接通信，它们就不该发生直接交互，而应该通过第三者来间接交互 | OOOXX  |
|-------------------+--------------------------------------------------------------------------------+--------|
# 设计模式 就是实现上面的原则，达到代码复用、增加可维护性。
*** 单一职责原则
“高内聚，低耦合”思想
**** 实现方式
- (一般情况) 类级别的单一职责原则：一个类方法不多的情况下，可只增加方法，而不拆分为多个类，否则拆分为多个类。
- (特殊情况) 方法级别的单一职责原则：一个方法逻辑不复杂，可以修改方法实现，否则拆分为两个方法。
*** 开闭原则
- 目的：建立稳定(对修改关闭)且灵活(对扩展开放)的系统
# 此原则是一个 总原则与终极目标
**** 实现方式
- 核心思想：面向抽象(接口)编程
*** 里氏代换原则
:PROPERTIES:
:NOTER_PAGE: 67
:END:
- 目的：增强程序健壮性，版本升级时也能保持好的兼容性
# 此原则是实现开闭原则的重要方式之一
**** 实现方式
对对象的定义尽量使用基类类型。运行时再确定其子类类型，用子类对象来替换父类对象。
**** 四个子原则
1. 子类可以实现父类的抽象方法，但不能重写(Overriding)父类的非抽象方法
2. 子类中可以增加自己特有的方法
3. 重载(Overload)父类方法时，输入参数要等于或大于父类的输入参数
   # 方法的形参比父类方法的输入参数更宽松
4. 重写(Override)父类方法时，输出结果可以被缩小
*** 依赖倒置原则
:PROPERTIES:
:NOTER_PAGE: 90
:END:
- 作用：解决了底层模块变动，高层模块也得改动的问题
**** 依赖倒置的两个原则
:PROPERTIES:
:NOTER_PAGE: 93
:END:
1. 高层模块不应该依赖于底层模块，二者都该依赖于抽象
2. 抽象不应该依赖于细节，细节应该依赖于抽象
**** 实现方式
- 将高层对低层的依赖，改为：高层对抽象的依赖，低层对抽象的实现
*** 合成复用原则(组合/聚合复用原则)
:PROPERTIES:
:NOTER_PAGE: 106
:END:
**** 实现方式
1. 类的复用，优先使用组合/聚合等关联关系，其次继承关系
2. 使用继承关系，需遵循里氏替换原则
**** 类复用的两种方式
1. “黑箱复用”：即组合/聚合复用，维持了封装性
   # 维持封装性：类内对象的细节看不到
2. “白箱复用”：即继承，破坏了封装性
   # 破坏封装性：子类可以看到父类的细节
*** 接口隔离原则
:PROPERTIES:
:NOTER_PAGE: 126
:END:
**** 实现方式
不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少
**** 接口和抽象类
- 接口：这个对象能做什么(一个体系对外的功能，是暴露出来的规则)
- 抽象类：这个对象是什么(一个继承体系中的共性内容)
***** 如何选择
- 关注事物本质时，用抽象类
- 关注一个操作时，用接口
*** 迪米特法则
:PROPERTIES:
:NOTER_PAGE: 140
:END:
- 作用：减少类之间的耦合度，增加类内封装与内聚性
**** 软件设计与编程的目标
低耦合、高内聚
- 耦合性：块间联系
- 内聚性：块内联系
# 面向对象中，软件模块包括类、包、软件子系统等
+ 本质上是 *类之间* *类包之间* *子系统之间* *系统之间* 的低耦合、高内聚要求
# 类之间用得最多：类内高内聚，类间低耦合
**** 迪米特法则的两个要义
***** 要义一
被调用者角度：设计相关类时，确定方法/属性的权限(只暴露必要的方法/属性)
****** 具体实现
- 不公开的类方法/属性就private，对类属性可以private，提供get或set方法供外部调用
***** 要义二
调用者角度：只和直接朋友们通信，不和“陌生人”说话
***** 类之间的朋友关系
:PROPERTIES:
:NOTER_PAGE: 146
:END:
1. 朋友关系：两个对象之间存在耦合关系
2. 直接朋友关系
   # 直接朋友出现的地方，大部分情况可以使用 依赖倒置原则
   1) 类对象本身(this)
   2) 类属性 中的成员变量对象
   3) 类方法 中作为 *参数、返回值* 的类对象
   4) 构造函数 创建的其他类对象
3. 非直接朋友
   1) 类方法 中 *声明* 的外部类对象
   2) 类方法 中 *创建* 的外部类对象
***** 类之间四种关系(依赖 关联 泛化 实现)对应的耦合关系
:PROPERTIES:
:NOTER_PAGE: 147
:END:
|                    | 朋友关系? | 直接朋友关系? | 耦合度 |
|--------------------+-----------+---------------+--------|
| 依赖               | 是        | 部分          | 中     |
| 关联(含聚合、组合) | 是        | 是            | 中     |
| 泛化               | 是        | 是            | 高     |
| 实现               | 是        | 是            | 低     |
**** 迪米特法则在设计模式中的应用场景
:PROPERTIES:
:NOTER_PAGE: 157
:END:
1. 门面(外观)模式
2. 中介者模式
*** TODO 面向对象技术中如何实现低耦合、高内聚
:PROPERTIES:
:NOTER_PAGE: 161
:END:
**** 耦合性从强到弱
**** 内聚性从低到高
*** 面向对象软件设计要点总结 :ATTACH:
:PROPERTIES:
:NOTER_PAGE: 165
:ID:       5ce803ff-8a22-4c09-bbb5-23e72a25bd12
:ORG-IMAGE-ACTUAL-WIDTH: 700
:END:
[[attachment:_20241218_191440screenshot.png]]
** 设计模式的分类
:PROPERTIES:
:NOTER_PAGE: 170
:END:
- 两种分类法：模式目的、模式作用范围
*** 根据模式目的划分
- 根据模式是用来完成什么样的工作来划分
**** 创建型模式
- 作用：描述怎么创建对象
- 特点：将对象的创建与使用分离
**** 结构型模式
- 作用：描述将类或对象按某种布局组成更大的结构
**** 行为型模式
- 作用：描述类或对象之间怎么互相协作共同完成单个对象无法单独完成的任务，以及怎样分配职责
*** 根据模式的作用范围划分 :ATTACH:
:PROPERTIES:
:ID:       77c4e70c-92da-418a-8680-740e5061b675
:ORG-IMAGE-ACTUAL-WIDTH: 500
:END:
- 根据模式是用于类上还是用户对象上来划分
  [[attachment:_20241218_194646screenshot.png]]
**** 类模式
- 处理 *类与子类* 之间的关系，这些关系通过 *继承* 来建立，是 *静态* 的，在 *编译时* 就确定了
**** 对象模式
- 处理 *对象* 之间的关系，这些关系通过 *组合或聚合* 来实现，是 *动态* 的，在 *运行时刻* 是可以变化的

** 23种设计模式功能
:PROPERTIES:
:NOTER_PAGE: 174
:END:
*** 单例(Singleton)模式
- 某个类 *只能生成一个实例* ，该类提供了一个全局访问点，供外部获取该实例，其拓展是有限多个实例。
*** 原型(Prototype)模式
- 将一个对象作为 *原型* ，通过对其进行 *复制而克隆* 出多个和原型类似的新实例。
*** 工厂(Factory Method)方法
- 定义一个用户 *创建产品的接口* ，由 *子类决定生产什么产品*
*** 抽象(Abstract Factory)工厂
- 提供一个 *创建产品族的接口* ，其 *每个子类可以生产一系列相关的产品* 。
*** 建造者(Builder)模式
- 将一个 *复杂对象分解* 成多个相对简单的部分，然后根据不同需要 *分别创建* 它们，最后构建成该复杂对象。
*** 代理(Proxy)模式
- 为某个对象提供一种 *代理以控制对对象的访问* 。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特征。
*** 适配器(Adapter)模式
- 将一个类的 *接口转换* 成客户希望的 *另一个接口* ，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。
*** 桥接(Bridge)模式
- 将抽象与实现分离，使它们可以独立变化。它是用 *组合关系代替继承关系* 来实现，从而降低 抽象和实现这两个可变维度的耦合度。
*** 装饰(Decorator)模式
- 给一个 *对象增加额外的功能*
*** 外观(Facade)模式
- 为多个复杂的子系统提供一个 *一致的接口* ，使这些子系统更加容易被访问。
*** 享元(Flyweight)模式
- 运用 *共享技术* 来有效地支持 *大量细粒度对象的复用* 。
*** 组合(Composite)模式
- 将对象组合成 *树状层次结构* ，使用户对 *单个对象和组合对象* 具有 *一致的访问性* 。
*** 模板方法(Template Method)模式
- 定义一个操作中的 *算法骨架* ，而将 *算法的一些步骤延迟到子类* 中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特点步骤。
*** 策略(Strategy)模式
- 定义一系列算法，将每个算法封装起来，使它们 *可以相互替换* ，且算法的改变不会影响算法的客户。
*** 命令(Command)模式
- *将一个请求封装为一个对象* ，使发出请求的责任和执行请求的责任分割开。
*** 职责链(Chain of Responsibility)模式
- *将请求从链中的一个对象传到下一个对象* ，直到请求被响应为止。通过这个方式去除对象之间的耦合。
*** 状态(State)模式
- 允许一个对象在其 *内部状态发生改变时改变其行为* 能力。
*** 观察者(Observer)模式
- 多个对象间存在一对多的关系，当 *一个对象发生改变时通知其他多个对象* ，从而 *影响其它对象的行为* 。
*** 中介者(Mediator)模式
- 定义一个 *中介对象来简化原有对象之间的交互关系* ，降低系统中对象的耦合度，使原有对象之间不必户互了解。
*** 迭代器(Iterator)模式
- 提供一种方法来 *顺序访问聚合对象中的一系列数据* ,而 *不暴露聚合对象的内部表示* 。
*** 访问者(Visitor)模式
- 在 *不改变集合元素* 的前提下，为一个集合中的每个元素 *提供多种访问方式* ，即每个元素有多个访问者对象。
*** 备忘录(Memento)模式
- 在 *不破坏封装性* 的前提下， *获取并保存一个对象的内部状态* ，以便 *以后恢复* 它。
*** 解释器(Interpreter)模式
- 提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。
* 创建型设计模式
** 创建型设计模式简介
- 符合 *单一职责原则*
- 主要关注： *怎么创建对象* ，即
  1. 创建什么
  2. 由谁创建
  3. 何时创建
- 创建模式分类：
  1. 类的创建模式
  2. 对象的创建模式
*** 类的创建模式
使用 *继承* ，将类的创建延迟到子类(里氏替换原则)
1. 简单工厂模式(非设计模式中的一种，算是工厂方法模式的特例)
2. 工厂方法模式
*** 对象的创建模式
一般通过 *组合或聚合* 方式，对象的创建模式把对象的创建过程动态地委托给另一个对象
1. 抽象工厂模式
2. 建造模式
3. 原型模式
4. 单例模式
** 简单工厂模式、工厂方法模式、抽象工厂模式
:PROPERTIES:
:NOTER_PAGE: 184
:END:
*** 简单工厂模式 :ATTACH:
:PROPERTIES:
:NOTER_PAGE: 185
:ID:       c6b44f98-ec44-4059-bbab-91b0db642065
:ORG-IMAGE-ACTUAL-WIDTH: 500
:END:
[[attachment:_20241220_115423screenshot.png]]
[[attachment:_20241220_115706screenshot.png]]
- 分析：由图可知 简单工厂模式 *不符合开闭原则中的对修改关闭* ，每次增加新的产品都需要修改工厂类的逻辑判断
- 符合 *依赖倒置原则* *里氏代换原则*
*** 工厂方法模式 :ATTACH:
:PROPERTIES:
:ID:       1717a2de-9088-4c8a-92aa-148d79e9ff2d
:ORG-IMAGE-ACTUAL-WIDTH: 500
:END:
[[attachment:_20241220_120234screenshot.png]]
- 分析：由图可知 此时 *符合开闭原则中的对修改关闭，对扩展开放* ，增加新产品时，我们无需在父工厂中修改逻辑，而是扩展子工厂。 *但是每个具体工厂对应一种具体产品* 。
- 符合 *依赖倒置原则* *里氏代换原则*
*** TODO 抽象工厂模式
:PROPERTIES:
:NOTER_PAGE: 202
:END:
**** 抽象工厂模式中的两个概念
1. 产品等级结构
   - 即产品的继承结构。如：抽象类是电视机，子类有海尔电视机、海信电视机、TCL电视机等。
2. 产品族
   - 同一个工厂生产的，位于不同产品等级结构中的一组产品。如：海尔工厂生产海尔电视机、海尔电冰箱等。
*** 三种工厂模式的区别 :ATTACH:
:PROPERTIES:
:NOTER_PAGE: 231
:ID:       93805e0d-71d3-4abb-b701-7093e10b19a8
:ORG-IMAGE-ACTUAL-WIDTH: 500
:END:
[[attachment:_20241220_125312screenshot.png]]
** 单例模式
:PROPERTIES:
:NOTER_PAGE: 237
:END:
- *单一职责原则* 的体现
*** 动机
- 一些类的实例化对象只需要一个
*** 实现的四个基本要求
1. 构造方法私有化
2. 类内部通过 私有静态变量 存储其唯一实例
3. 公有静态方法对外调用，返回实例
4. 确保对象实例只有一个
*** 实现 :ATTACH:
:PROPERTIES:
:NOTER_PAGE: 248
:ID:       51a81362-12ff-4e70-97f1-e28ca041f555
:ORG-IMAGE-ACTUAL-WIDTH: 500
:END:
[[attachment:_20241220_132414screenshot.png]]
*** 面向对象语言中推荐的三种单例模式 :ATTACH:
:PROPERTIES:
:NOTER_PAGE: 272
:ID:       80f6995b-634b-4b55-84f3-732b7f730cb2
:ORG-IMAGE-ACTUAL-WIDTH: 500
:END:
[[attachment:_20241220_132624screenshot.png]]
** 建造者模式
:PROPERTIES:
:NOTER_PAGE: 278
:END:
*** 动机
1. 需要生成复杂对象，由多个部件组成，且部件未来可能会更新换代
   # 与工厂的区别：建造者用于复杂对象生成；工厂用于简单对象生成
2. 部件之间相互依赖，需要一定的生成顺序
*** 实现 :ATTACH:
:PROPERTIES:
:ID:       f142943c-80fb-4b9e-8700-c18872901bfc
:ORG-IMAGE-ACTUAL-WIDTH: 500
:END:
[[attachment:_20241220_134710screenshot.png]]
- Director：规定一个对象所需的步骤和次序
- Builder：提供完成这些步骤的方法
- ConcreteBuilder：提供这些方法的具体实现
通常和 *组合模式* 结合使用
*** 变体
1. 省略抽象建造者角色
2. 省略指导者角色
3. 合并建造者角色和产品角色
* 结构型模型
** 结构型模式简述
:PROPERTIES:
:NOTER_PAGE: 307
:END:
- 作用：将类/对象按某种布局组成更大的结构
根据 *合成复用原则* ，因此大部分结构型模式都是 *对象结构型模型*
*** 类结构型模式
- 多个类组合成一个更大的系统
- 使用 *继承、实现*
**** 有哪些？
1. (类)适配器模式
*** 对象结构型模式
- 类和对象组合成一个更大的系统
- 使用 *关联(组合或聚合)*
**** 有哪些？
1. (对象)适配器模式
2. 装饰模式
3. 桥接模式
4. 代理模式
5. 外观模式
6. 享元模式
** 适配器模式
:PROPERTIES:
:NOTER_PAGE: 310
:END:
*** 动机 :ATTACH:
:PROPERTIES:
:ID:       ee50c4c0-3a4e-4565-9564-2fefe87a6eef
:ORG-IMAGE-ACTUAL-WIDTH: 500
:END:
- 将不能一起工作的两样东西通过转换，让它们可以一起工作
[[attachment:_20241220_143941screenshot.png]]
*** 类适配器
**** 类适配器的实现条件与限制
:PROPERTIES:
:NOTER_PAGE: 319
:END:
**** 实现 :ATTACH:
:PROPERTIES:
:ID:       1def7514-f230-43a4-8849-3bbca6c5fe50
:ORG-IMAGE-ACTUAL-WIDTH: 500
:END:
[[attachment:_20241220_144302screenshot.png]]
- (目标)Target：客户期待的类/接口
- (源)Adaptee：需要适配的类/接口
- (适配器)Adapter：把源类转换成目标类
*** 对象适配器
**** 实现 :ATTACH:
:PROPERTIES:
:ID:       d3ff364f-9504-4505-b4ea-cfb00fab84ca
:ORG-IMAGE-ACTUAL-WIDTH: 500
:END:
[[attachment:_20241220_144622screenshot.png]]
- (目标)Target：客户期待的类/接口
- (源)Adaptee：需要适配的类/接口
- (适配器)Adapter：把源类转换成目标类
*** 适配器模式的优缺点 :ATTACH:
:PROPERTIES:
:ID:       76233c5b-77c7-4dd2-aca1-a46a55de71c0
:ORG-IMAGE-ACTUAL-WIDTH: 500
:END:
[[attachment:_20241220_145230screenshot.png]]
- *对象适配器* 更通用，且符合 *合成复用原则*
** 装饰者模式
:PROPERTIES:
:NOTER_PAGE: 346
:END:
*** 动机
- 不改变现有对象结构的情况下，动态给该对象增加一些额外功能
- 符合 *开闭原则* *组合复用原则* *里氏代换原则*
*** 实现 :ATTACH:
:PROPERTIES:
:ID:       a9c9b862-ac71-469d-b16f-26c250194a5b
:ORG-IMAGE-ACTUAL-WIDTH: 500
:END:
[[attachment:_20241220_151105screenshot.png]]
- (抽象被装饰对象)Compontent：规范被添加额外功能的对象
- (具体被装饰对象)ConcreteComponent：接收额外功能的具体对象
- (抽象装饰类)Decorator：
- (具体装饰对象)ConcreteDecorator：
*** TODO 工作机制
*** 装饰者、适配器、代理模式的区别
:PROPERTIES:
:NOTER_PAGE: 359
:END:
**** 装饰器、适配器的区别
- 装饰者：保持接口并增加对象的功能
- 适配器：改变对象的接口，并不一定改变对象的功能
**** 装饰器、代理模式的区别
- 装饰者：为单个对象动态增加功能，不会影响该类其他的对象
- 代理模式：给类的所有对象增加功能，影响该类的所有对象
# 装饰器可以和代理模式一起使用
*** 装饰器模式的扩展与简化
**** 扩展：装饰者模式和工厂模式的组合
- 将装饰者模式中的装饰视为工厂模式中的产品
  # 装饰者模式意味着我们需要管理更多的类，且创建对象还是硬编码new出来的
**** 三种简化
:PROPERTIES:
:NOTER_PAGE: 361
:END:
1. 只有一个具体装饰者，没有抽象装饰者
2. 只有一个具体构件，没有抽象构件
3. 只有一个具体构件和一个具体装饰者，所有抽象角色都不要
** 桥接模式
:PROPERTIES:
:NOTER_PAGE: 374
:END:
*** 动机
- 让抽象和实现分离，使它们可以独立变化
*** 实现 :ATTACH:
:PROPERTIES:
:ID:       8c7b696b-c08a-4e90-88e0-33d1961a4039
:ORG-IMAGE-ACTUAL-WIDTH: 500
:END:
[[attachment:_20241220_205147screenshot.png]]
* 行为型模式
:PROPERTIES:
:NOTER_PAGE: 406
:END:
** 行为型模式综述
- 作用：描述类或对象之间如何相互协作共同完成单个对象无法单独完成的任务，以及怎样分配职责
  # 不仅关注类和对象的结构，还重点关注它们之间的相互作用
*** 十一种行为模式的重要程度
  1. 模板方法(3)
  2. 策略(4)
  3. 命令(4)
  4. 职责链(3)
  5. 状态(3)
  6. 观察者(4)
  7. 中介者(2)
  8. 迭代器(4)
  9. 访问者(1)
  10. 备忘录模式(2)
  11. 解释器(1)
*** 行为型模式按技术特征分类
- 算法封装：模板方法、策略、命令模式
- 对象去耦：中介、观察者模式
- 抽象集合：迭代器模式
- 行为扩展：访问者、责任链模式
- 对象状态：状态模式
** 策略模式
:PROPERTIES:

:NOTER_PAGE: 408
:END:
*** 动机
- 某对象具备某个行为，在不同场景中，该行为有不同的实现
*** 实现 :ATTACH:
:PROPERTIES:
:ID:       dbc97976-414f-4f09-804b-42f2b3208556
:ORG-IMAGE-ACTUAL-WIDTH: 500
:END:
[[attachment:_20241221_133510screenshot.png]]
- (抽象策略角色)Strategy：规定策略或算法的行为
- (具体策略角色)ConcreteStrategy：具体的策略或算法的行为
- (上下文角色)Context：操作策略的上下文
*** 策略模式的问题与改进
:PROPERTIES:
:NOTER_PAGE: 420
:END:
- 问题：Context的职责本是隔离客户端与策略类的耦合，但在代码中我们发现客户端内部需自己指定要哪种策略，使得客户端和具体策略类耦合
- 改进：可以将Context用简单工厂模式或工厂方法模式改造
** 责任链模式
:PROPERTIES:
:NOTER_PAGE: 434
:END:
*** 动机
- 将请求与处理解耦，让请求在处理链中能进行处理或者被传递
# 有些if-else就能用责任链改写，好处是：增加新内容时，符合开闭原则
*** 实现 :ATTACH:
:PROPERTIES:
:ID:       741a531c-3d4d-451a-a892-78e0a43c6c38
:ORG-IMAGE-ACTUAL-WIDTH: 500
:END:
[[attachment:_20241221_143125screenshot.png]]
- (抽象处理者)Handler：定义一个处理请求的接口，包含抽象处理方法和一个后继连接
- (具体处理者)Concrete Handler：实现抽象处理者的处理方法，判断能否处理这次请求，若可，处理之，否则，将该请求转给它的后继者
- (客户类)Client：创建处理链，向链头的具体处理者对象提交请求
**** 客户端设置责任链 :ATTACH:
:PROPERTIES:
:ID:       e78b62d1-42b3-44cb-ac7d-85141a9765fb
:ORG-IMAGE-ACTUAL-WIDTH: 500
:END:
[[attachment:_20241221_143442screenshot.png]]
- 责任链中的链表采用1:1的自关联关系来实现，且由Client端根据需要自行组装(初始化)该链表
*** 扩展
:PROPERTIES:
:NOTER_PAGE: 461
:END:
- 纯的职责链模式：处理者处理请求或转交给下家处理
- 不纯的职责链模式：处理者可以处理部分请求，将剩余部分传给下家处理
** 观察者模式
:PROPERTIES:
:NOTER_PAGE: 462
:END:
*** 动机
- 一个对象(被观察者或主题)的状态发生变化(事件)时，所有依赖它的对象(观察者)都会收到通知，并自动更新
- 符合 *开闭原则* *依赖倒置原则* *迪米特法则*
*** 实现 :ATTACH:
:PROPERTIES:
:ID:       c6e1b696-758b-44bb-9e0c-2e91adf83917
:ORG-IMAGE-ACTUAL-WIDTH: 500
:END:
[[attachment:_20241221_150531screenshot.png]]
- (抽象主题)Subject：也叫抽象目标类。提供保存观察者对象的聚集类和增加、删除观察者对象的方法，以及通知所有观察者的抽象方法
- (具体主题)Concrete Subject：也叫具体目标类。实现抽象目标中的通知方法，当具体主题的内部状态发生改变时，通知所有注册过的观察者对象
- (抽象观察者)Observer：含有一个更新自己的抽象方法，当接到具体主题的更改通知时被调用
- (具体观察者)Concrete Observer：实现抽象观察者中定义的抽象方法，在得到目标的更改通知时更新自身的状态
