:PROPERTIES:
:ID:       4012acd2-c162-4270-8c93-9922a3502f50
:END:
#+title: qt

* 事件系统
用于实现程序对 各种外部/内部变化 的响应机制，事件系统可以简单理解为： =事件系统 = 产生 + 循环 + 过滤 + 分发 + 处理=

*工作流程* ：[fn:7]
1. 系统产生事件被放入系统事件队列，qt取出系统事件队列中的事件封装为qt事件放入qt事件队列，qt也会产生事件并放入qt事件队列
2. 事件循环会取出qt事件队列中的事件确定事件的目标对象，事件先经过全局事件过滤器（若app对象安装），再经过目标对象的事件过滤器（若目标对象安装），具体来说会调用事件过滤器的eventFilter()方法，若该方法返回true则拦截事件不再继续传递到目标对象，若该方法返回false则继续传递到目标对象
3. 目标对象接收到事件后会调用事件处理的入口（event()方法），event()默认会根据事件类型调用对应的事件处理函数

** 图:事件系统之事件产生、循环、过滤、分发、处理 :ATTACH:
:PROPERTIES:
:ID:       f488468e-c836-44a2-b8a7-46d2738bc7fc
:END:
[[attachment:_20250916_140415screenshot.png]]


* 对象树
1. 对象树是qt的内存管理机制，是以QObject为根节点，按对象间父子关系构建的树状结构，当树中某个对象销毁时，会自动销毁所有直接子对象，直接子对象又销毁其直接子对象，形成链式销毁。避免内存泄漏
2. 一个对象销毁时，相关的信号槽连接会自动断开


* 信号槽
用于 类对象间的通信，具体来说一个对象发出信号会触发另一个对象的槽函数，要使用信号槽功能 类得继承 QObject，并在类声明中增加 Q_OBJECT宏

*特点* ：
- 松耦合 :: 信号发送者只需要发送信号，不需要知道接收者的存在；接收者只需关联信号，实现槽函数逻辑，无需了解发送者细节
- 类型安全 :: （qt5）元对象系统会在编译期检查信号和槽的参数类型是否匹配
- 灵活性 ::
  1. 一个信号 连接 一个槽
  2. 一个信号 连接 多个槽
  3. 一个信号 连接 另一个信号
  4. 多个信号 连接 一个槽

*信号槽的连接写法* ：
#+begin_example cpp
// 1. 基于字符串
connect(sender, SIGNAL(valueChanged(int)), receiver, SLOT(onValueChanged(int)));


// 2. 基于函数指针（qt5新增）
connect(sender, &Sender::valueChanged, receiver, &Receiver::onValueChanged);

// 2.1 支持连接到lambda表达式
connect(sender, &Sender::valueChanged, [](int value) {
    qDebug() << "Value changed:" << value;
});
#+end_example

*connection连接方式（第5个参数）* ：
- Qt::AutoConnection（默认）   :: 自动连接
  sender 和 receiver 在同一线程 ? 直接连接 : 队列连接

- Qt::DirectConnection         :: 直接连接
  信号触发时，立即调用发送者线程中的槽函数

- Qt::QueuedConnection         :: 队列连接
  信号触发时，qt会将信号打包成 qt事件，放入接收者线程的事件队列，接收者线程运行事件循环从事件队列中取出事件并执行槽函数

- Qt::BlockingQueuedConnection :: 阻塞队列连接
  类似队列连接，发送信号的线程会阻塞吗，直到槽u函数处理完毕

- Qt::UniqueConnection         :: 唯一连接
  用于确保 同一信号和槽之间不会建立重复连接，与其他连接方式组合使用
  #+begin_example cpp
  connect(sender, &Sender::signal, receiver, &Receiver::slot, Qt::AutoConnection | Qt::UniqueConnection);
  #+end_example

信号槽机制实现依赖 *元对象系统*

** 信号槽底层原理
1. 元对象编译器（moc）扫描声明了Q_OBJECT宏的类的信号槽和其他元信息，生成名为 moc_XXX.cpp 文件
2. 运行时，程序运行到 QObject::connect，调用 发送者和接收者关联的moc文件中的 qt_static_metacall 方法，走 的QMetaObject::IndexOfMethod分支，根据信号和槽函数分别返回对应元索引，最后将 “发送者指针、信号索引、接收者指针、槽函数索引” 等信息存入内存中的QObject内部连接列表
3. 信号触发时，调用发送者的moc文件中的信号函数实现，信号函数实现内部调用 QMetaObject::activate() ，QMetaObject::activate() 在内存中的QObject内部连接列表里找到与当前信号连接的所有 “接收者-槽”对，根据connection连接类型，对每个 “接收者-槽”对 进行处理，将槽函数的元索引传入接收者的 qt_static_metacall 中调用
4. qt_static_metacall 走的 QMetaObject::InvokeMetaMethod 分支，根据槽函数的元索引找到槽函数并调用

相关代码见：[fn:1]
#+begin_example cpp
Tom::miao() → QMetaObject::activate() → 查找连接列表 → 找到 jerry 和其槽索引 → 调用 Jerry::qt_static_metacall() → 执行 Jerry::runAway()
#+end_example


* TODO 动态属性系统

* QObject的构造和析构顺序
- 代码片段1
  #+begin_src c++
  int main(){
      QWidget window;
      QPushButton quit("Quit", &window);
      ...
  }
  #+end_src
- 代码片段2
  #+begin_src c++
  int main()
  {
      QPushButton quit("Quit");
      QWidget window;
      quit.setParent(&window);
      ...
  }
  #+end_src




* Qt Style Sheet
:PROPERTIES:
:ID:       f9dc39e4-1bcf-4677-aeea-e1f99bbc9f90
:ROAM_REFS: https://doc.qt.io/qt-6/stylesheet-syntax.html
:END:

** 语法
- style rule = selector + declaration
  #+begin_src qss
  QPushButton { color: red }
  #+end_src
  # QPushButton是selector；color: red是declaration

** 选择器类型
[[https://doc.qt.io/qt-6/stylesheet-syntax.html#selector-types][选择器类型]]


* QApplication
- 用于管理应用程序的 *全局设置* 和控制 *事件循环*
  - 全局设置 :: 应用程序的名称、图标、样式等
  - 事件循环 :: 处理用户交互、窗口更新等

* QDialog
- 模态：对话框弹出后会阻塞其他窗口（如：只有先关闭对话框才能再关闭其他窗口
- 非模态：对话框弹出后不会阻塞其他窗口


* QObject
| 函数        | 作用                                                                     |
|-------------+--------------------------------------------------------------------------|
| [[https://doc.qt.io/qt-6/qobject.html#setProperty][setProperty]] | 动态设置对象的属性(运行时对对象的属性进行操作，即使这些属性在编译时未知) |


** QMainWindow :ATTACH:
:PROPERTIES:
:ID:       9aa6e879-c71d-43fc-a774-5c6a73c8f34a
:END:
- 用于管理主窗口，QMainWindow有自己的布局
  [[attachment:_20250101_002022screenshot.png]]
1. Central Widget区域可以被任何种类的widget占用
2. 其余区域分别有对应的widget
   # QMenuBar，QToolBar，QDockWidget，QStatusBar
   | 函数             | 作用                           |
   |------------------+--------------------------------|
   | [[https://doc.qt.io/qt-6/qmainwindow.html#setCentralWidget][setCentralWidget]] | 设置Central Widget位置的widget |


* Qt Namespace
[[https://doc.qt.io/qt-6/qt.html#WindowType-enum][enum Qt::WindowType(flags Qt::WindowFlags)]]：用于设置widget的窗口系统属性


* QStyle
| 函数     | 作用                   |
|----------+------------------------|
| [[https://doc.qt.io/qt-6/qstyle.html#polish][polish]]   | 初始化widget的外观     |
| unpolish | 取消初始化widget的外观 |
# 一般和qss联动使用


* QFile
#+begin_src c++
QFile qss(":/style/stylesheet.qss");
#+end_src
在qt中，路径前的:符号表示资源文件的路径


* exec()
#+begin_src c++
int main(int argc,char * argv[])
{
    QApplication a(argc,argv);
    MainWindow w;
    w.show();
    return a.exec();
}
#+end_src
exec()作用：启动一个局部事件循环，等待用户操作完成后返回结果
# main函数返回后交给系统处理，因此可以猜到exec()和系统处理有关。
# `QApplication a(argc,argv);`将main函数中的参数传到a中，所以控制权从main转到Qt
# `return a.exec()`是进入循环等待事件的状态，等待用户和系统的消息并进行处理
# return 0;的话，就直接退出程序了
# return a.exec()就是进行循环等待事件的状态


* exec()和show()的区别
作用和区别：都是用于显示对话框，区别在于 运行机制 和 返回值
- exec()：当前线程中显示对话框，阻塞当前进程，直到用户关闭对话框。也就是说会开启一个事件循环，知道对话框关闭事件被触发
- show()：当前线程中显示对话框并返回，不会阻塞当前线程，因此程序可以执行其他代码
应用场景：
- exec()：用于显示模态对话框
- show()：用于显示 模态 和 非模态对话框


* tr()
作用：国际化使用
所有传入tr函数的文本，都可以用工具提取出来翻译成其他语言。


* C++中局部变量的销毁顺序
是按照逆序销毁
- 该例中QPushButon父类是QWidget，QWidget的父类是QObject
#+begin_src c++
int main()
{
    QWidget window;
    QPushButton quit("Quit", &window);
    ...
}
#+end_src
正确：先调用子类析构（QPushButton）后调用父类析构（QWidget）
#+begin_src c++
int main()
{
    QPushButton quit("Quit", &window);
    QWidget window;

    quit.setParent(&window);
    ...
}
#+end_src
有问题：先调用父类析构，父类析构造接着调用子类析构。然后又在销毁子类局部对象时，又调用了一次子类的析构函数


* 未处理
 只有父窗口关闭，才会回收子窗口
# 假设父窗口有一个按钮a，点击a触发槽函数，进而在堆中产生一个子窗口，我们关闭子窗口，其实子窗口是隐藏了。随着点击和关闭 重复进行，窗口会越来越多。
# 解决方法：
# 在主窗口的构造函数中 创建子窗口，析构函数中 回收子窗口，槽函数只用来控制子窗口的显示

代码片段1正确。代码片段2错误：析构顺序和构造顺序相反，先是window先析构它的children quit，然后析构自己；接下来又析构quit


* Footnotes

[fn:1]
#+name: Tom.h
#+begin_example cpp
class Tom : public QObject
{
    Q_OBJECT
public:
    Tom(QObject *parent = nullptr) : QObject(parent) { }
    void miaow() {
        qDebug() <<  u8"喵!" ;
        emit miao();
    }

signals:
    void miao();
};
#+end_example

#+name: Jerry.h
#+begin_example cpp
class Jerry : public QObject
{
    Q_OBJECT
public:
    Jerry(QObject *parent = nullptr) : QObject(parent) {}

public slots:
    void runAway() {
        qDebug() << u8"那只猫又来了，快溜！" ;
    }
};
#+end_example

#+name: main.cpp
#+begin_example cpp
#include "Tom.h"
#include "Jerry.h"
int main(int argc, char *argv[]) {
    QCoreApplication a(argc, argv);
    Tom tom;
    Jerry jerry;

    QObject::connect(&tom, &Tom::miao, &jerry, &Jerry::runAway);
    tom.miaow();

    return a.exec();
}
#+end_example

#+name: Q_OBJECT宏
#+begin_example cpp
public: \
    QT_WARNING_PUSH \
    Q_OBJECT_NO_OVERRIDE_WARNING \
    static const QMetaObject staticMetaObject; \
    virtual const QMetaObject *metaObject() const; \
    virtual void *qt_metacast(const char *); \
    virtual int qt_metacall(QMetaObject::Call, int, void **); \
    QT_TR_FUNCTIONS \
private: \
    Q_OBJECT_NO_ATTRIBUTES_WARNING \
    Q_DECL_HIDDEN_STATIC_METACALL static void qt_static_metacall(QObject *, QMetaObject::Call, int, void **); \
    QT_WARNING_POP \
    struct QPrivateSignal {}; \
    QT_ANNOTATE_CLASS(qt_qobject, "")
/******************关键部分***********************/
static const QMetaObject staticMetaObject;
virtual const QMetaObject *metaObject() const;
virtual void *qt_metacast(const char *);
virtual int qt_metacall(QMetaObject::Call, int, void **);
static void qt_static_metacall(QObject *, QMetaObject::Call, int, void **)
#+end_example


#+name: moc_Tom.cpp
#+begin_example cpp
#include "../../TomJerry/Tom.h"
/*省略一些内容*/
struct qt_meta_stringdata_Tom_t {
    QByteArrayData data[3];
    char stringdata0[10];
};

#define QT_MOC_LITERAL(idx, ofs, len) \
    Q_STATIC_BYTE_ARRAY_DATA_HEADER_INITIALIZER_WITH_OFFSET(len, \
    qptrdiff(offsetof(qt_meta_stringdata_Tom_t, stringdata0) + ofs \
        - idx * sizeof(QByteArrayData)) \
    )

static const qt_meta_stringdata_Tom_t qt_meta_stringdata_Tom = {
    {
QT_MOC_LITERAL(0, 0, 3), // "Tom"
QT_MOC_LITERAL(1, 4, 4), // "miao"
QT_MOC_LITERAL(2, 9, 0) // ""

    },
    "Tom\0miao\0"
};
#undef QT_MOC_LITERAL

// Tom的元数据数组，qt运行时通过解析它可以知道 属性、方法等数量信息
static const uint qt_meta_data_Tom[] = {

 // content:
       8,       // 0    ：revision（版本）
       0,       // 1    ：classname（类名索引）
       0,    0, // 2-3  ：classinfo（类信息数量及偏移）
       1,   14, // 4-5  ：methods（方法数量及偏移）-> 该类有一个方法（信号/槽/普通成员函数），方法详细信息从数组索引14开始
       0,    0, // 6-7  ：properties（属性数量及偏移）-> 该类无属性
       0,    0, // 8-9  ：enums/sets（枚举/集合数量及偏移）-> 该类无枚举
       0,    0, // 10-11：constructors（自定义构造函数数量及偏移）-> 该类无自定义构造函数
       0,       // 12   ：flags（类的标志位）
       1,       // 13   ：signalCount（信号数量）-> 该类有一个信号

 // signals: name, argc, parameters, tag, flags
       1,    0,   19,    2, 0x06 /* Public */,     // 14-18：信号的具体描述

 // signals: parameters
    QMetaType::Void,                               // 19   ：信号参数信息（返回值类型）

       0                                           // 20   ：eod
};

// NOTE 3. InvokeMetaMethod：根据元索引方法；IndexOfMethod：根据方法查元索引
void Tom::qt_static_metacall(QObject *_o, QMetaObject::Call _c, int _id, void **_a)
{
    if (_c == QMetaObject::InvokeMetaMethod) {
        auto *_t = static_cast<Tom *>(_o);     // 将参数中的QObject对象 转换成 Tom类
        Q_UNUSED(_t)
        switch (_id) {
        case 0: _t->miao(); break;             // 然后调用Tom类的miao()函数，在代码末尾 void Tom::miao()
        default: ;
        }
    } else if (_c == QMetaObject::IndexOfMethod) {
                                                      // 当外部查询Tom类中miao方法的元索引时，返回其索引值0
        int *result = reinterpret_cast<int *>(_a[0]);
        {
            using _t = void (Tom::*)();
            if (*reinterpret_cast<_t *>(_a[1]) == static_cast<_t>(&Tom::miao)) {
                *result = 0;
                return;
            }
        }
    }
    Q_UNUSED(_a);
}

QT_INIT_METAOBJECT const QMetaObject Tom::staticMetaObject = { {
    &QObject::staticMetaObject,
    qt_meta_stringdata_Tom.data,
    qt_meta_data_Tom,    // Tom的元信息数组：这个类的信号、槽、类名等元信息
    qt_static_metacall,  // 静态函数 qt_static_metacall
    nullptr,
    nullptr
} };


const QMetaObject *Tom::metaObject() const
{
    return QObject::d_ptr->metaObject ? QObject::d_ptr->dynamicMetaObject() : &staticMetaObject;
}

void *Tom::qt_metacast(const char *_clname)
{
    if (!_clname) return nullptr;
    if (!strcmp(_clname, qt_meta_stringdata_Tom.stringdata0))
        return static_cast<void*>(this);
    return QObject::qt_metacast(_clname);
}

int Tom::qt_metacall(QMetaObject::Call _c, int _id, void **_a)
{
    _id = QObject::qt_metacall(_c, _id, _a);
    if (_id < 0)
        return _id;
    if (_c == QMetaObject::InvokeMetaMethod) {
        if (_id < 1)
            qt_static_metacall(this, _c, _id, _a);
        _id -= 1;
    } else if (_c == QMetaObject::RegisterMethodArgumentMetaType) {
        if (_id < 1)
            *reinterpret_cast<int*>(_a[0]) = -1;
        _id -= 1;
    }
    return _id;
}

// NOTE 1. 信号触发调用
// SIGNAL 0
void Tom::miao()
{
    QMetaObject::activate(this, &staticMetaObject, 0, nullptr); // 0 代表 miao()这个函数的索引号
    // NOTE 2. QMetaObject::activate的大致实现：找出与当前信号连接的所有“接收者-槽”对；根据connection连接类型，对每个 “接收者-槽”对 进行处理；通过槽函数的元索引（qt_meta_data数组中）调用接收者类的 qt_static_metacall 函数
}
QT_WARNING_POP
QT_END_MOC_NAMESPACE
#+end_example





#+begin_example cpp

#+end_example


[fn:7]
#+begin_example cpp
#include <QApplication>
#include <QWidget>
#include <QMouseEvent>
#include <QDebug>

// 事件过滤器对象
class EventFilter : public QObject {
    Q_OBJECT
protected:
    bool eventFilter(QObject *watched, QEvent *event) override {
        // 过滤鼠标按下事件
        if (event->type() == QEvent::MouseButtonPress) {
            qDebug() << "事件过滤器：拦截到鼠标按下事件";
            // 返回false表示事件继续传递
            return false;
        }
        return QObject::eventFilter(watched, event);
    }
};

// 自定义窗口（事件目标对象）
class MyWidget : public QWidget {
    Q_OBJECT
protected:
    // 事件分发器
    bool event(QEvent *event) override {
        if (event->type() == QEvent::MouseButtonPress) {
            qDebug() << "事件分发器：收到鼠标按下事件，准备调用处理函数";
            // 调用父类实现，会自动分发到mousePressEvent
            return QWidget::event(event);
        }
        return QWidget::event(event);
    }

    // 具体事件处理函数
    void mousePressEvent(QMouseEvent *event) override {
        qDebug() << "事件处理函数：处理鼠标按下事件，位置："
                 << event->x() << "," << event->y();
        QWidget::mousePressEvent(event);
    }
};

int main(int argc, char *argv[]) {
    QApplication app(argc, argv);

    MyWidget widget;
    EventFilter filter;

    // 为窗口安装事件过滤器
    widget.installEventFilter(&filter);

    widget.resize(300, 200);
    widget.show();

    qDebug() << "进入事件循环";
    // 启动事件循环
    return app.exec();
}

#include "main.moc"
#+end_example




