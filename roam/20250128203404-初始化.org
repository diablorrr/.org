:PROPERTIES:
:ID:       819c9ef5-5220-4678-994a-3122d7d17ab7
:END:
#+title: 初始化
#+filetags: cpp

*Best practice* ：使用 列表初始化，且始终初始化变量

* 初始化 [[https://www.learncpp.com/cpp-tutorial/variable-assignment-and-initialization/][learncpp1.4]]
1. cpp 中初始化方式有多种
   - 现代初始化 :: 基于 *列表初始化* ，用 ={}= 表示；引出：列表直接初始化 、列表拷贝初始化、值初始化
   - 古代初始化 :: 使用 =()= 表示 *直接初始化* ， === 表示 *拷贝初始化* ；没有初始化值的是 *默认初始化*
   #+begin_src cpp :results output :namespaces std :includes <iostream>

   // 现代初始化：基于 列表初始化
   int d {};      // value-initialization (empty braces)
   int e { 7 };   // direct-list-initialization (initial value in braces)
   int f = { 6 }; // copy-list-initialization

   // 古代初始化
   int a;         // default-initialization (no initializer)
   int b = 5;     // copy-initialization (initial value after equals sign)
   int c ( 6 );   // direct-initialization (initial value in parenthesis)

   #+end_src

2. *列表初始化* 有以下特点
   1) 不允许 窄化转换（精度缺失的转换），否则报错；见：[[id:1b0646eb-ed64-4b37-a394-4974750aaf7a][类型转换]]
      #+begin_src cpp :results output :namespaces std :includes <iostream>
      int w1 { 4.5 }; // compile error: list-init does not allow narrowing conversion
      int w2 = 4.5;   // compiles: w2 copy-initialized to value 4
      int w3 (4.5);   // compiles: w3 direct-initialized to value 4
      #+end_src
   2) 无初始化值的初始化 更统一（使用 {}空花括号 会进行 值初始化：0、nullptr、类默认构造）；古代的默认初始化在不同位置定义，行为不一样

3. *[[id:d85053ba-baae-419d-9902-edc51e53198e][全局变量]]的初始化顺序* ：在 main() 调用之前，静态初始化 -> 动态初始化
