:PROPERTIES:
:ID:       de2b315b-cd05-419b-98f3-dbd79f03087a
:END:
#+title: 拷贝控制
#+LAST_MODIFIED: 2025-01-28 23:49:41
#+filetags: cpp del

* 拷贝控制
** 拷贝控制
*** 拷贝构造函数
:PROPERTIES:
:NOTER_PAGE: 466
:END:
- 简介 ::
  1. 控制对象如何初始化
  2. 构造函数的第一个参数是自身类类型的引用(为什么是引用[fn:1])
     一般写法：const T&
  3. 任何额外参数都有默认值
**** 合成拷贝构造函数
- 简介 :: 用户未定义拷贝构造函数时，编译器会生成合成拷贝构造函数
- 特点 :: 是 *浅拷贝*
- 实现 ::
  + 类类型成员 :: 使用其拷贝构造函数来拷贝
  + 内置类型成员 :: 直接拷贝
  + 数组类型成员 :: 逐元素地拷贝一个数组类型成员
**** 拷贝构造函数调用时机
 1. 用=定义变量
 2. 值传递方式 传参、返回值
 3. 花括号列表 初始化一个数组中的元素或一个聚合类中的成员
*** 拷贝赋值运算符
:PROPERTIES:
:NOTER_PAGE: 469
:END:
- 简介 :: 控制对象如何赋值
- 特点 :: 返回一个指向其左侧运算对象的引用
- 注意 :: 正确处理自赋值
**** 合成拷贝赋值运算符
- 简介 :: 用户未定义拷贝赋值运算符时，编译器会生成合成拷贝赋值运算符 => 浅拷贝
- 实现 ::
  + 类类型成员 :: 将右侧运算对象的每个非static成员赋予左侧运算对象的对应成员 => 通过成员类型的拷贝赋值运算符实现
  + 数组类型成员 :: 逐个赋值数组元素
**** 拷贝赋值运算符调用时机
1. 赋值操作符调用：当两个相同类型的对象之间使用 = 时

*** 合成的拷贝控制成员可能是删除的
:PROPERTIES:
:NOTER_PAGE: 476
:END:
不能拷贝构造、拷贝赋值或析构类的成员时[fn:3] => 类的拷贝控制成员被定义为删除的
# 具体看书上部分
** 移动操作
:PROPERTIES:
:NOTER_PAGE: 496
:END:
- 简介 :: 相比拷贝控制，提升性能
  + 分析 :: 拷贝对象，拷贝后销毁 => 对象可能很大，拷贝代价就很高
*** std::move()
- 简介 :: 将左值转换为对应的右值引用
- 附加 ::
  + 右值引用 :: 用于支持移动操作，只能绑定到一个将要销毁的对象
*** 移动构造函数、移动赋值运算符
:PROPERTIES:
:NOTER_PAGE: 499
:END:
- 注意 ::
  1. 移动赋值运算符应正确处理自赋值
  2. 如果不抛出异常，应该标记为noexcept
*** 合成的移动操作
-  简介 :: 类 *没定义自己版本的拷贝控制成员* ，且每个非static数据成员都可以移动构造和移动赋值，编译器会合成合成移动构造、移动赋值
*** 合成的移动操作可能是删除的
:PROPERTIES:
:NOTER_PAGE: 502
:END:
*** 成员函数和右值引用
:PROPERTIES:
:NOTER_PAGE: 507
:END:
- 简介 :: 一个成员函数可以同时提供拷贝和移动版本
- 实现  :: 实现重载
  1. 拷贝版本：const T&
  2. 移动版本：T&&
    # 从实参"窃取"数据 => 移动版本不能定义为const的
** 移动、拷贝的匹配规则
:PROPERTIES:
:NOTER_PAGE: 503
:END:
适用于构造、赋值
- 移动右值，拷贝左值 :: 类有移动构造/赋值、拷贝构造/赋值的情况下
- ✨无移动构造函数，右值也被拷贝 :: 有拷贝构造函数的情况下，即使试图调用std::move()也一样
