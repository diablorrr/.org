:PROPERTIES:
:ID:       de2b315b-cd05-419b-98f3-dbd79f03087a
:END:
#+title: 拷贝控制
#+LAST_MODIFIED: 2025-01-28 23:49:41
#+filetags: cpp

* 拷贝控制
** 拷贝控制
*** 拷贝构造函数
:PROPERTIES:
:NOTER_PAGE: 466
:END:
- 简介 ::
  1. 控制对象如何初始化
  2. 构造函数的第一个参数是自身类类型的引用(为什么是引用[fn:1])
     一般写法：const T&
  3. 任何额外参数都有默认值
**** 合成拷贝构造函数
- 简介 :: 用户未定义拷贝构造函数时，编译器会生成合成拷贝构造函数
- 特点 :: 是 *浅拷贝*
- 实现 ::
  + 类类型成员 :: 使用其拷贝构造函数来拷贝
  + 内置类型成员 :: 直接拷贝
  + 数组类型成员 :: 逐元素地拷贝一个数组类型成员
**** 拷贝构造函数调用时机
 1. 用=定义变量
 2. 值传递方式 传参、返回值
 3. 花括号列表 初始化一个数组中的元素或一个聚合类中的成员
**** 示例
1) explicit的拷贝构造函数
#+begin_src c++
// 直接初始化
string dots(10, '.');
string s(dots);
// 拷贝初始化
string s2 = dots;
stirng null_book = "9-99-999";
string nines = string(100, '9');

// 假设f为explicit的拷贝构造函数
f(10);                // 错误
f(vector<int>(10));   // 正确
#+end_src
*** 拷贝赋值运算符
:PROPERTIES:
:NOTER_PAGE: 469
:END:
- 简介 :: 控制对象如何赋值
- 特点 :: 返回一个指向其左侧运算对象的引用
- 注意 :: 正确处理自赋值
**** 合成拷贝赋值运算符
- 简介 :: 用户未定义拷贝赋值运算符时，编译器会生成合成拷贝赋值运算符 => 浅拷贝
- 实现 ::
  + 类类型成员 :: 将右侧运算对象的每个非static成员赋予左侧运算对象的对应成员 => 通过成员类型的拷贝赋值运算符实现
  + 数组类型成员 :: 逐个赋值数组元素
**** 拷贝赋值运算符调用时机
1. 赋值操作符调用：当两个相同类型的对象之间使用 = 时
*** 析构函数
:PROPERTIES:
:NOTER_PAGE: 471
:END:
- 简介 :: 释放对象使用的资源，并销毁对象的非static数据成员
- 原理 :: 首先执行函数体，然后销毁成员。成员按初始化顺序的逆序销毁
  - ✨分析 :: 析构函数自身不直接销毁对象 => 成员在析构函数体之后隐含的析构阶段中被销毁 => 析构函数体是作为成员销毁步骤之外的另一部分进行的
- 实现 ::
  + 类类型成员 :: 执行自己的析构函数 => 智能指针析构阶段自动销毁
  + 内置类型 :: 无析构函数 => 什么也不会做 => *普通指针* 不会自己销毁
**** 合成析构函数
- 简介 :: 类未自定义自己的析构函数时，编译器会为它定义一个合成析构函数
  合成析构函数的函数体为空 => (空)析构函数体执行完后，成员会被自动销毁
**** 什么时候会调用析构函数
对象被销毁 => 自动调用析构函数
- 实现 ::
  + 局部对象 :: 离开作用域
  + 临时对象 :: 创建它的表达式结束后
  + 动态分配的对象 :: 显式delete
  + 类对象 :: 被销毁 => 其成员被销毁
  + 容器(标准库容器、数组) :: 被销毁 => 其元素被销毁
*** 合成的拷贝控制成员可能是删除的
:PROPERTIES:
:NOTER_PAGE: 476
:END:
不能拷贝构造、拷贝赋值或析构类的成员时[fn:3] => 类的拷贝控制成员被定义为删除的
# 具体看书上部分
** 移动操作
:PROPERTIES:
:NOTER_PAGE: 496
:END:
- 简介 :: 相比拷贝控制，提升性能
  + 分析 :: 拷贝对象，拷贝后销毁 => 对象可能很大，拷贝代价就很高
*** std::move()
- 简介 :: 将左值转换为对应的右值引用
- 附加 ::
  + 右值引用 :: 用于支持移动操作，只能绑定到一个将要销毁的对象
*** 移动构造函数、移动赋值运算符
:PROPERTIES:
:NOTER_PAGE: 499
:END:
- 注意 ::
  1. 移动赋值运算符应正确处理自赋值
  2. 如果不抛出异常，应该标记为noexcept
*** 合成的移动操作
-  简介 :: 类 *没定义自己版本的拷贝控制成员* ，且每个非static数据成员都可以移动构造和移动赋值，编译器会合成合成移动构造、移动赋值
*** 合成的移动操作可能是删除的
:PROPERTIES:
:NOTER_PAGE: 502
:END:
*** 成员函数和右值引用
:PROPERTIES:
:NOTER_PAGE: 507
:END:
- 简介 :: 一个成员函数可以同时提供拷贝和移动版本
- 实现  :: 实现重载
  1. 拷贝版本：const T&
  2. 移动版本：T&&
    # 从实参"窃取"数据 => 移动版本不能定义为const的
**** 引用限定符
:PROPERTIES:
:NOTER_PAGE: 509
:END:
- 简介 :: 阻止旧标准可以对右值赋值(s1 + s2 = "wow";)
- 实现 :: &或&&分别限定函数只能用于左值或右值
- 特点 :: 可用于区分重载版本
** 移动、拷贝的匹配规则
:PROPERTIES:
:NOTER_PAGE: 503
:END:
适用于构造、赋值
- 移动右值，拷贝左值 :: 类有移动构造/赋值、拷贝构造/赋值的情况下
- ✨无移动构造函数，右值也被拷贝 :: 有拷贝构造函数的情况下，即使试图调用std::move()也一样
** 三/五法则[fn:2]
:PROPERTIES:
:NOTER_PAGE: 473
:END:
1. 需要析构函数的类也需要拷贝和赋值操作
   - 分析 :: 需要析构函数 => 类中有指针类型的成员(否则合成析构函数就够用) => 浅拷贝问题：合成拷贝和赋值操作 => 多次析构：多个对象的指针成员指向同一片内存
2. 需要拷贝操作的类也需要赋值操作，反之亦然
3. 析构函数不能是删除的
   - 分析 :: 类或类某个成员的类型的析构函数被删除 => 无法销毁此类型的对象 => 不能定义该类的变量或临时对象：编译器不允许
4. 类定义了任何一个拷贝操作，就应该定义所有五个操作(P505)
5. 类有const或引用成员，则不能使用默认拷贝赋值操作[fn:4]
   - 分析 :: const或引用成员只在初始化时被赋值一次，之后不能更改
** =default和=delete
- =default :: 用于显式要求编译器生成合成的版本
- =delete :: 用于定义删除的函数，通知编译器我们不希望定义这些成员
