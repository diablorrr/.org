:PROPERTIES:
:ID:       183c9f25-d3a3-4a95-baa1-5e1a3b201a11
:END:
#+title: CMakeLists.txt
#+STARTUP show2levels



* 使用
** 设置cpp17标准智能感知
1. CMakeLists.txt编写如下
   #+begin_src cmake
   cmake_minimum_required(VERSION 3.10)
   project(MyProject CXX)

   set(CMAKE_CXX_STANDARD 17)  # 设置 C++17 标准
   set(CMAKE_CXX_STANDARD_REQUIRED ON)  # 强制使用 C++17，不允许降级
   set(CMAKE_CXX_EXTENSIONS OFF)  # 使用纯 C++17 标准，不使用编译器扩展
   set(CMAKE_EXPORT_COMPILE_COMMANDS ON)

   add_executable(myapp main.cpp)
   target_compile_features(myapp PRIVATE cxx_std_17)  # 为 myapp 启用 C++17
   #+end_src
2. mkdir build && cd build
3. cmake ..
4. cmake --build .

** 没有[[id:c4819291-b93f-4864-b210-aa436634ac22][.cmake]]配置文件的package
- 做法 :: 我们会先包含库文件目录，将目录里我们需要的文件存到一个变量里，然后目标再去链接
- 示例 ::
#+begin_src cmake
include_directories(/usr/lib)
file(GLOB absl_libs "/usr/lib/libabsl_*.so")
target_link_libraries(main ${absl_libs})
#+end_src


* 查询
** 术语
- 目标 :: 可执行文件、库
** 语法
:PROPERTIES:
:VISIBILITY: show2levels
:END:
*** cmake_minimum_required :: 设置最低[[id:c651b8b0-bc76-451d-acac-0ea55329f0e8][cmake]]版本
*** project :: 定义项目名称
*** set :: 定义、修改变量
 - 设置cpp标准 ::
   #+begin_src cmake
   set(CMAKE_CXX_STANDARD 17)
   set(CMAKE_CXX_STANDARD_REQUIRED ON)
   #+end_src
 - 设置cpp编译选项 ::
   #+begin_src cmake
   set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -g")
   #+end_src

*** file :: 处理文件系统相关操作
 - 获取文件列表 ::
   #+begin_src cmake
   file(GLOB <variable> [RELATIVE <path>] <glob_pattern>...)
   file(GLOB_RECURSE <variable> [RELATIVE <path>] <glob_pattern>...)
   #+end_src
   + GLOB :: glob(通配符匹配的意思)的文件(不递归子目录)
   + GLOB_RECURSE :: 递归获取子目录中的符合模式的文件
   + <variable> :: 存储匹配文件路径的变量
   + <glob_pattern> :: 通配符模式，通常是文件扩展名，如 *.cpp、*.h

*** add_executable :: 添加可执行文件
*** target_include_directories :: 头文件搜索路径
  #+begin_src cmake
  target_include_directories(<target> <INTERFACE|PUBLIC|PRIVATE> [<directory>...])
  #+end_src

*** target_link_libraries :: 链接静态/动态库
  #+begin_src cmake
  target_link_libraries(<target> <INTERFACE|PUBLIC|PRIVATE> <library>...)
  #+end_src
*** install :: 指定文件复制到哪个文件夹
#+begin_src cmake
install(TARGETS target1 target2 ...
        [EXPORT <export-name>]
        [RUNTIME DESTINATION <dir>] # 可执行文件
        [LIBRARY DESTINATION <dir>] # 动态库
        [ARCHIVE DESTINATION <dir>] # 静态库
        [INCLUDES DESTINATION <dir>]
        [OPTIONAL])
#+end_src
- 安装路径 :: CMAKE_INSTALL_PREFIX 控制，默认是 /usr/local
- 🐂注意 :: install(...)的代码，只有在cmake --install .后才会执行
**** 示例
#+begin_src cmake
add_executable(myapp main.cpp)
install(TARGETS myapp DESTINATION bin)
#+end_src
- 安装到：${CMAKE_INSTALL_PREFIX}/bin/myapp
*** add_library :: 创建一个库(动态库、静态库)
*** set_target_properties :: 设置目标的属性
#+begin_src cmake
set_target_properties(<target> PROPERTIES <prop1> <value1> [<prop2> <value2> ...])
#+end_src
**** 示例
***** 设置运行时查找库路径
#+begin_src cmake
# 告诉cmake，在运行时去$ORIGIN/../lib找动态库
set_target_properties(MyApp PROPERTIES
  BUILD_WITH_INSTALL_RPATH TRUE
  INSTALL_RPATH "$ORIGIN/../lib"
)
#+end_src
- $ORIGIN :: 表示当前执行的可执行文件的目录
*** ExternalProject_Add :: 构建外部项目(子项目)
#+begin_src cmake
ExternalProject_Add(<name>
    [URL <url> | SOURCE_DIR <path>] # 网络源码 | 本地源码
    [BINARY_DIR <path>]             # 编译目录：默认${name}-build
    [INSTALL_DIR <path>]            # 安装路径
    [CMAKE_ARGS <arg1> <arg2> ...]  # 传给外部项目的cmake参数
    [BUILD_COMMAND <cmd>]           # 自定义构建命令
    [INSTALL_COMMAND <cmd>]         # 自定义安装命令
    [LOG_CONFIGURE 1]
    [LOG_BUILD 1]
    [LOG_INSTALL 1]
    ...
)

#+end_src
- 什么时候运行 :: 构建主项目时，cmake会
  1. 构建子项目
  2. 安装子项目
*** add_subdirectory :: 在主CMakeLists.txt中添加子目录
*** add_custom_command :: 构建过程中添加自定义的命令
仅定义add_custom_command()是不会自动执行的，必须有target使用它的输出
- 以下示例中的proto_srcs和grpc_srcs都是add_custom_command()的输出
  1. 示例1
   #+begin_src cmake
   add_executable(my_app main.cpp ${proto_srcs} ${grpc_srcs})
   #+end_src
  2. 示例2
   #+begin_src cmake
   add_library(proto_files
     ${proto_srcs}
     ${grpc_srcs}
   )
   #+end_src
  3. 示例3
   #+begin_src cmake
   add_dependencies(proto_files
     ${proto_srcs} ${grpc_srcs}
   )
   #+end_src

*** [[id:2e20f81d-56f0-4af5-a00c-b77fce675287][find_package()]] ::
  #+begin_src cmake
  find_package(<package> [version] [EXACT] [QUIET] [REQUIRED] [CONFIG|NO_MODULE] [MODULE])
  #+end_src
  + <package> :: 包的名称
  + [REQUIRED] :: 包未找到，CMake会停止并报错
  + [CONFIG] :: 查找 <Package>Config.cmake
  + [MODULE] :: 查找 Find<Package>.cmake
  + [version] :: 包的版本要求（可选）
  + [EXACT] :: 要求精确匹配指定的版本
  + [QUIET] :: 不会显示找不到包的警告信息。即使包未找到，CMake也不会发出警告
*** pkg_check_modules :: 使用[[id:0867edf9-0f48-48ed-92be-e197f1546b05][pkg-config]]查找库
#+begin_src cmake
pkg_check_modules(<prefix> [REQUIRED] <package> [<version>])
#+end_src
- <prefix> :: 指定一个前缀，CMake 将使用这个前缀为库的相关变量命名。通常是大写的库名称，如 HIREDIS。
- [REQUIRED] :: 如果找不到指定的库，CMake会报错并停止构建
- <package> :: 库的名称，和 pkg-config 的 .pc 文件名相同
- [<version>] :: 指定库版本

- 示例 :: prefix设置为HIREDIS => 所以hiredis的头文件目录为HIREDIS_INCLUDE_DIRS、库文件路径变为HIREDIS_LIBRARIES
#+begin_src cmake
find_package(PkgConfig REQUIRED)
pkg_check_modules(HIREDIS REQUIRED hiredis)
...
target_include_directories(test_redis PRIVATE ${HIREDIS_INCLUDE_DIRS})
target_link_libraries(test_redis PRIVATE ${HIREDIS_LIBRARIES})
#+end_src
*** message :: 输出消息到控制台
  #+begin_src cmake
  message([<mode>] "message" ...)
  #+end_src
 - <mode> :: 指定消息的类型
   + STATUS :: 输出正常状态消息

*** <INTERFACE|PUBLIC|PRIVATE>关键字
- 作用 :: 控制对目标的可见性
  + PRIVATE :: 仅对当前目标可见，不会传递给链接到此目标的其他目标
  + PUBLIC :: 不仅对当前目标可见，还会传递给链接到此目标的其他目标
  + INTERFACE :: 对当前目标不可见，只会传递给链接到此目标的其他目标
*** 预定义变量
- CMAKE_CURRENT_SOURCE_DIR :: 当前CMakeLists.txt文件所在的目录
- CMAKE_CXX_STANDARD :: 设置cpp标准
- CMAKE_CXX_STANDARD_REQUIRED :: 强制编译器使用标准


* 概念
- 简介 ::
  1. 是 [[id:c651b8b0-bc76-451d-acac-0ea55329f0e8][cmake]] 的配置文件
  2. 用于定义如何构建 c/[[id:8ab4df56-e11f-42b8-87f8-4daa2fd045db][cpp]] 项目
  3. [[id:c651b8b0-bc76-451d-acac-0ea55329f0e8][cmake]] 通过解析 CMakeLists.txt 生成 Makefile、Ninja 文件或 Visual Studio 项目，适配不同的构建系统
