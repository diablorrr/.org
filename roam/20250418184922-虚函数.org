:PROPERTIES:
:ID:       b23cd926-82ec-489e-ad8f-96b86e5559c2
:END:
#+title: 虚函数
#+filetags: cpp

* 虚函数 [[https://www.learncpp.com/cpp-tutorial/virtual-functions/][learncpp25.2]]
1. =virtual= 声明的成员函数，允许派生类 *重写* 其实现，实现 [[id:a3778673-5028-4637-b8f2-85b1bf798587][运行时多态]]；通过基类的 *指针或引用* 调用虚函数时（通过基类直接调用虚函数，调用的是该对象相同类型的成员），调用的是对象的 *实际类型* 的函数的 *最派生版本*
   [✨ *BP* ：基类虚函数用 virtual，派生类不用]
   #+begin_src cpp :results output :namespaces std :includes <iostream> <string_view>
   class A {
   public:
     virtual std::string_view getName() const { return "A"; }};

   class B: public A {
   public:
       virtual std::string_view getName() const { return "B"; }};

   class C: public B {
   public:
     virtual std::string_view getName() const { return "C"; }};

   int main() {
       C c {};
       // 通过基类 指针或引用调用 虚函数时，调用的是对象的实际类型的最派生版本
       A& rBase{ c };
       std::cout << "rBase is a " << rBase.getName() << '\n';
       A* pBase{ &c };
       std::cout << "pBase is a " << pBase->getName() << '\n';

       // 通过基类 直接调用 虚函数时，调用的是对象的相同类型的版本
       A a { c };
       std::cout << " Base is a " << a.getName();
   }
   #+end_src

   #+RESULTS:
   : rBase is a C
   : pBase is a C
   :  Base is a A

2. *工作原理* ：[[id:74b3a07c-d965-4a3d-aa07-eb49d5a08b7e][虚函数实现]]

3. 一个函数是 =virtual= ，则 *派生类中重写的函数都是 =virtual= 函数* （即使没有显式标记）

4. *重写* [[https://www.learncpp.com/cpp-tutorial/the-override-and-final-specifiers-and-covariant-return-types/][learncpp25.3]]
   [✨ *BP* ：派生类重写函数 使用 override，不用 virtual（包括虚析构）]
   1) 派生类的 *签名（名称、函参、是否const）、返回类型* 与 基类相同（与重载规则不同）
   2) =override= ：声明这个重写的函数，编译器会检查
   3) *协变返回类型* ：基类虚函数 返回类的指针/引用，重写函数返回指向派生类的指针/引用 -> 视为重写（即使重写函数返回类型不同）[fn:3]
   #+begin_src cpp :results output :namespaces std :includes <iostream> <string_view>
   class A {
   public:
     virtual int getValue() const { return 5; }
     virtual std::string_view getName1(int x) { return "A"; }
     virtual std::string_view getName2(int x) { return "A"; }
     virtual std::string_view getName3(int x) { return "A"; }};

   class B : public A {
   public:
     virtual double getValue() const { return 6.78; }}; // 没有重写：返回类型不同
     std::string_view getName1(short int x) override { return "B"; } // FIXME 重写失败：函参不同
     std::string_view getName2(int x) const override { return "B"; } // FIXME 重写失败：const
     std::string_view getName3(int x) override { return "B"; }       // ok
   #+end_src

5. *使用场景* ：函数参数 [[https://www.learncpp.com/cpp-tutorial/pointers-and-references-to-the-base-class-of-derived-objects/][learncpp25.1]]
   #+begin_src cpp :results output :namespaces std :includes <iostream>
   class Animal {}
   class Cat : public Animal {}
   class Dog : public Animal {}
   // 参数使用 指向基类的引用/指针，可以传入派生类
   void report(const Animal& rAnimal) { }
   #+end_src

6. =final= [[https://www.learncpp.com/cpp-tutorial/the-override-and-final-specifiers-and-covariant-return-types/][learncpp25.3]]
   1) 不希望重写虚函数：在函数后使用 [fn:1]
   2) 禁止从类继承：在类名后使用 [fn:2]

7. 基类 [[id:be44b0c2-d234-409f-b1a6-b447e365db37][析构函数]] 应该设置为 =virtual= ，防止[[id:6782179f-792b-4eb6-807c-4f95aba88169][内存泄漏]] [fn:4] [[https://www.learncpp.com/cpp-tutorial/virtual-destructors-virtual-assignment-and-overriding-virtualization/][learncpp25.4]]
   #+begin_example
   基类指针指向派生类对象，delete基类指针，没有虚析构将不会释放派生类对象
   #+end_example

8. *面试题* 能不能在 构造函数或析构函数 中调用虚函数？ 可以，但不建议，因为可能没法触发多态，无法达到我们的目的
   #+begin_example
   构造派生类，先构造基类，基类构造函数中调用虚函数，希望触发派生类版本，但派生类还没构造，只能触发基类版本
   析构派生类，先析构派生类，后析构基类，基类中调用虚函数，希望触发派生类版本，但派生类已经析构了，只能触发基类版本
   #+end_example

9. 在有虚函数的继承体系中 向上转型和向下转型：[[id:728c2647-c601-4b7e-97dd-d5b21ea45e11][std::dynamic_cast]]

* Footnotes
[fn:4]
#+begin_src cpp :results output :namespaces std :includes <iostream>
class Base
{
public:
    virtual ~Base() // 设置为 virtual，若没有，则 delete Base类型的指针时，派生类析构函数不会调用
    {
        std::cout << "Calling ~Base()\n";
    }
};

class Derived: public Base
{
private:
    int* m_array {};

public:
    Derived(int length)
      : m_array{ new int[length] }
    {
    }

    ~Derived() // 基类是 virtual，因此隐式的为 virtual
    {
        std::cout << "Calling ~Derived()\n";
        delete[] m_array;
    }
};

int main()
{
    Derived* derived { new Derived(5) };
    Base* base { derived };

    delete base;

    return 0;
}
#+end_src

#+RESULTS:
: Calling ~Derived()
: Calling ~Base()


[fn:3]
#+begin_src cpp :results output :namespaces std :includes <iostream> <string_view>
class Base
{
public:
	// 返回类的指针/引用：Base*
	virtual Base* getThis() { std::cout << "called Base::getThis()\n"; return this; }
	void printType() { std::cout << "returned a Base\n"; }
};

class Derived : public Base
{
public:
  // 返回派生类的指针/引用：Derived*
	Derived* getThis() override { std::cout << "called Derived::getThis()\n";  return this; }
	void printType() { std::cout << "returned a Derived\n"; }
};

int main()
{
	Derived d{};
	Base* b{ &d };
	d.getThis()->printType();
	b->getThis()->printType();
}
#+end_src

#+RESULTS:
: called Derived::getThis()
: returned a Derived
: called Derived::getThis()
: returned a Base

[fn:2]
#+begin_src cpp :results output :namespaces std :includes <iostream> <string_view>
class A {
public:
  virtual std::string_view getName() const { return "A"; }};

// 使用 final
class B final : public A {
public:
  std::string_view getName() const override { return "B"; }};

// FIXME：不能继承 final 类
class C : public B {
public:
  std::string_view getName() const override { return "C"; }};
#+end_src


[fn:1]
#+begin_src cpp :results output :namespaces std :includes <iostream> <string_view>
class A {
public:
  virtual std::string_view getName() const { return "A"; }
};

class B : public A {
public:
  // 使用 final
  std::string_view getName() const override final { return "B"; } // okay, 重写 A::getName()
};

class C : public B {
public:
  std::string_view getName() const override { return "C"; } // FIXME 不能重写 getName()；因为是 final
};
#+end_src
