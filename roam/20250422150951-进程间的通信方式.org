:PROPERTIES:
:ID:       eea0107c-ac34-4210-be33-534585e20915
:END:
#+title: 进程间的通信方式
#+filetags: operating_system

* 管道
*管道* ：本质是操作系统管理的内核空间的内存中的 *缓冲区* ，通过暴露两个文件描述符，让进程可以对这块缓冲区读写，实现进程间通信；分为：匿名管道、命名管道
1. *匿名管道* ：通过 =int pipe(int fd[2])= 创建 代表读端（ =fd[0]= ）和写端（ =fd[1]= ）的文件描述符实现通信
   #+begin_comment 具体做法
   父进程调用 =fork()= 创建子进程，子进程会复制父进程的文件描述符，一端使用读，另一端使用写
   #+end_comment
   因此，匿名管道用于 *血缘关系进程间通信*
2. *命名管道* ：通过创建 =类型为管道的设备文件= 进行通信，进程只要使用这个文件就能实现通信
   因此，命名管道可以用于 *任意进程间的通信*

*优缺点* ：
1. 没有消息边界，需要消息解析逻辑（管道是面向字节流的）
2. 用户态内核态数据拷贝开销、状态转换开销（系统调用 + 缓冲区在内核）
   # 管道    ：进程A产生数据 -> 数据拷贝（用户态 -> 内核态） -> 数据拷贝（内核态 -> 用户态）-> 数据B接收数据 [两次拷贝]
   # 共享内存：进程A产生数据 -> 数据B接收数据


* 消息队列
*消息队列* ：本质是操作系统管理的内核空间的内存中的 *消息链表*

*优缺点* ：
1. [改进] 解决了 管道 中的消息边界问题
2. 用户态内核态数据拷贝开销、状态转换开销（系统调用 + 缓冲区在内核）
3. 通信不及时（系统调用 + 缓冲区在内核）
   # 消息队列：发送方 将数据放到队列，接收方 需要从队列中取
   # 共享内存：发送方 将数据放入共享内存，接收方无需取


* 共享内存
*共享内存* ：多个进程的虚拟内存地址 映射到 同一物理内存

*优缺点* ：
1. [改进] 无用户态内核态数据拷贝开销、状态转换开销
2. [改进] 通信最快
3. 缺少同步机制，可能数据混乱


* 信号量
*[[id:5b709163-a1e7-49cf-8e66-d6cfe35a38c3][信号量]]* ：本质是一个 *整数* ，表示资源的数量；通过 *PV操作* 实现进程间 *互斥* 和 *同步*  [fn:1]
- 互斥 :: =初始信号量=1=
- 同步 :: =初始信号量=0=
- P    :: =信号量-1= ；P后信号量<0 ，说明资源已经被占用，阻塞
- V    :: =信号量+1= ；V后信号量<=0，说明有进程在等待，唤醒队首进程


* 信号
*信号* ：操作系统向进程发送的异步通知；通知进程发生了某个事件(如：中断、挂起、终止等)，进程进行相应处理
- 处理方式 ::
  1. 执行信号默认操作
  2. 捕获信号，执行自定义操作
  3. 忽略信号


* Socket
*Socket* ：（套接字）用于在 同一/不同网络 的进程之间通信


* Footnotes

[fn:1]
#+begin_src c
struct semaphore {
    int count;              // 当前可用资源数
    queue wait_queue;       // 阻塞进程的等待队列
};

void P(semaphore S) {
    S.count--;              // 尝试占用资源
    if (S.count < 0) {      // 资源不足
        // 将当前进程加入等待队列
        enqueue(S.wait_queue, current_process);
        block(current_process); // 阻塞进程
    }
}

void V(semaphore S) {
    S.count++;              // 释放资源
    if (S.count <= 0) {     // 有进程在等待
        // 从等待队列唤醒一个进程
        process = dequeue(S.wait_queue);
        wakeup(process);    // 唤醒进程
    }
}
#+end_src
