:PROPERTIES:
:ID:       eea0107c-ac34-4210-be33-534585e20915
:END:
#+title: 进程间的通信方式

* 概念
- 进程间的通信方式有以下六种 ::
** 管道
:PROPERTIES:
:ID:       326bb126-a270-4bf8-9070-b941b2edb63f
:END:
- 简介 :: [[id:ec7aef91-2628-4ba9-b300-16652314877f][linux]]基于[[id:7f527111-b093-4516-bff4-27c6282c3522][内核缓冲区]]的 单向字节流[fn:1] 通信机制，允许进程通过[[id:642dbcb1-86f4-466a-9938-cb074939db43][文件描述符]]进行通信
- 缺点 :: 效率低[fn:2]
*** 匿名管道
- 简介 :: 血缘关系进程进行通信
- 实现进程间通信的原理 ::
  1. 父子通信：通过系统调用pipe创建管道并返回两个fd(读、写)，通过[[id:6df148db-bb3c-4c5f-abb7-0fa63679a676][fork()]]创建子进程，关闭父进程读fd，打开写fd；关闭子进程写fd，打开读fd
  2. 兄弟通信：父进程[[id:6df148db-bb3c-4c5f-abb7-0fa63679a676][fork()]]两个子进程，关闭父读、写fd；两子进程，一个打开读fd，关写fd，另一个相反
- 生命周期 :: 随进程 => 进程销毁时结束
*** 命名管道
- 简介 :: 不相关进程间通信
- 实现进程间通信的原理 :: 创建了类型为管道的设备文件，只要进程里使用了这个设备文件，就能互相通信

** 消息队列
:PROPERTIES:
:ID:       4841caac-7d5e-429e-910d-60b91bb6418f
:END:
- 简介 :: [[id:ec7aef91-2628-4ba9-b300-16652314877f][linux]][[id:7f527111-b093-4516-bff4-27c6282c3522][内核缓冲区]]中的一个链表结构，支持跨进程通信
- 通信方式 :: A进程给B进程发消息，A将数据放入消息队列后返回，B在需要时读取数据
- 生命周期 :: 随内核 => 没有释放消息队列或关闭操作系统，就会一直存在
- 缺点 :: 效率低[fn:3]

** 共享内存
:PROPERTIES:
:ID:       80059f4d-d2fa-481e-9017-b30b47cebdfd
:END:
- 简介 :: 多个进程的虚拟内存地址映射到相同的物理内存中
- 缺点 :: 缺少同步机制
** 信号量
:PROPERTIES:
:VISIBILITY: show2levels
:END:
- 简介 ::
  1. 是一个整型的计数器，表示资源的数量，用于进程间[[id:80c358c2-7001-413d-b794-50ba2289f13f][互斥]]和[[id:df779374-d30b-4e22-842d-ccf7b690e6eb][同步]]
  2. 与[[id:80059f4d-d2fa-481e-9017-b30b47cebdfd][共享内存]]搭配使用
- 实现互斥/同步的原理 ::
  1. p减1信号量，v加1信号量
  2. 进行p操作后，信号量 < 0时[fn:5]，会阻塞
  3. 进行v操作后，信号量 <= 0时[fn:4]，唤醒队首进程
- 互斥 :: 信号量初始为1
- 阻塞 :: 信号量初始为0[fn:6]，
*** 示例代码
**** 示例1:信号量与PV
:PROPERTIES:
:ID:       0be859dd-70b9-4342-bd0d-7235fe0b6f37
:END:
#+begin_src c
struct semaphore {
    int count;              // 当前可用资源数
    queue wait_queue;       // 阻塞进程的等待队列
};

void P(semaphore S) {
    S.count--;              // 尝试占用资源
    if (S.count < 0) {      // 资源不足
        // 将当前进程加入等待队列
        enqueue(S.wait_queue, current_process);
        block(current_process); // 阻塞进程
    }
}

void V(semaphore S) {
    S.count++;              // 释放资源
    if (S.count <= 0) {     // 有进程在等待
        // 从等待队列唤醒一个进程
        process = dequeue(S.wait_queue);
        wakeup(process);    // 唤醒进程
    }
}
#+end_src

** 信号
:PROPERTIES:
:ID:       119412de-0d27-4fcf-bf3f-31abbc5d6657
:END:
- 简介 :: [[id:ec7aef91-2628-4ba9-b300-16652314877f][linux]]中内核或进程发送的 异步通知[fn:7]，用于通知进程发生了某些事件；属于软件中断
- 处理方式 ::
  1. 执行默认操作
  2. 捕获信号
  3. 忽略信号
** socket
:PROPERTIES:
:ID:       5a28bf2b-fdfe-4793-9975-3159aad12598
:END:
- socket(套接字) ::
  1. 一个套接字就是网络上进程通信的一端，用于 同一/不同 网络的进程之间通信












* Footnotes
[fn:7] 可以在任何时候发送信号给某一进程
[fn:6] 也称同步信号量
[fn:5] 说明资源已经被占用
[fn:4] 说明有进程在等待
[fn:3] 1.通信不及时；2.消息大小限制；3.用户态内核态之间数据拷贝开销
[fn:2] 用户态内核态之间数据拷贝开销：如写入：用户进程 => [[id:7f527111-b093-4516-bff4-27c6282c3522][内核缓冲区]] => 管道缓冲区
       IO阻塞：缓冲区满，进程阻塞，无法写入；缓冲区空，进程阻塞，无法读取
[fn:1] 先进先出
