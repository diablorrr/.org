:PROPERTIES:
:ID:       ac154a46-7700-4286-96aa-a45f8d93c6b6
:END:
#+title: ç§»åŠ¨æ„é€ å‡½æ•°ã€ç§»åŠ¨èµ‹å€¼
#+filetags: cpp

* ç§»åŠ¨æ„é€ å‡½æ•°ã€ç§»åŠ¨èµ‹å€¼ [[https://www.learncpp.com/cpp-tutorial/move-constructors-and-move-assignment/][learncpp22.3]]
1. æ„é€ æˆ–èµ‹å€¼ çš„å‚æ•°æ˜¯å³å€¼ï¼ˆå­—é¢é‡æˆ–ä¸´æ—¶å€¼ï¼‰æ—¶ *è°ƒç”¨* ï¼Œé€šè¿‡ [[id:78a7c695-510d-4b03-a1e1-055d32a034cf][å³å€¼å¼•ç”¨]] è¯†åˆ«å³å€¼ï¼ˆä¸´æ—¶å¯¹è±¡ï¼‰ï¼Œå®ç° [[id:0512d335-6d3f-4ebc-9021-88424c326876][ç§»åŠ¨è¯­ä¹‰]]ï¼ˆå¯ä»¥ä½¿ç”¨ [[id:d4285c38-cefe-4bb5-8ebf-0625bd976fa1][std::move]] æ¿€æ´»ç§»åŠ¨è¯­ä¹‰ï¼‰ï¼šé€šè¿‡èµ„æºè½¬ç§»è€Œéå¤åˆ¶æé«˜æ•ˆç‡
3. *éšå¼* ç§»åŠ¨æ„é€ å’Œç§»åŠ¨èµ‹å€¼ åˆæˆæ¡ä»¶ï¼š
   1) æ²¡æœ‰ç”¨æˆ·å£°æ˜çš„ [[id:828d1a9b-3ab1-4471-8906-1cf535ea8e7d][æ‹·è´æ„é€ å‡½æ•°ã€æ‹·è´èµ‹å€¼]] ã€[[id:be44b0c2-d234-409f-b1a6-b447e365db37][ææ„]]ã€ç§»åŠ¨æ„é€ ã€ç§»åŠ¨èµ‹å€¼
   2) å¯ç§»åŠ¨çš„ç§»åŠ¨ï¼Œå…¶ä½™å¤åˆ¶
4. ä»å‡½æ•° *å€¼è¿”å›çš„å·¦å€¼* ï¼Œå¦‚æœç§»åŠ¨å¯ç”¨å°±ç”¨ï¼›å½“ç„¶ä¹Ÿå¯èƒ½å‘ç”Ÿ [[id:3cc311ac-4ed0-4e9c-af58-5b1daed5ec94][æ‹·è´çœç•¥]]ï¼ˆä¸æ‹·è´å’Œç§»åŠ¨ï¼Œå¤åˆ¶æ„é€ ã€ç§»åŠ¨æ„é€ éƒ½ä¸ä¼šè¢« è°ƒç”¨ï¼‰

5. *å¯ç§»åŠ¨ä¸å¯æ‹·è´çš„ç±»* ï¼Œä½¿ç”¨ [[id:5aea3bf8-964d-4925-91bf-c5cf83f88753][=delete]] åˆ é™¤ [[id:828d1a9b-3ab1-4471-8906-1cf535ea8e7d][æ‹·è´æ„é€ å‡½æ•°ã€æ‹·è´èµ‹å€¼]]
6. ğŸ”¥ *å¯æ‹·è´ä¸å¯ç§»åŠ¨çš„ç±»* ï¼šä½¿ç”¨ [[id:5aea3bf8-964d-4925-91bf-c5cf83f88753][=delete]] åˆ é™¤ ç§»åŠ¨æ„é€ å‡½æ•°ã€ç§»åŠ¨èµ‹å€¼ï¼›ä½† [[id:3cc311ac-4ed0-4e9c-af58-5b1daed5ec94][æ‹·è´çœç•¥]] ä¸é€‚ç”¨æ—¶ï¼Œç±»æ— æ³•æŒ‰å€¼è¿”å›
   - åˆ é™¤çš„ç§»åŠ¨å‡½æ•°ï¼Œä¾æ—§æ˜¯å·²å£°æ˜çš„å‡½æ•°ï¼Œç¬¦åˆé‡è½½è§£ææ¡ä»¶ï¼Œåœ¨å‡½æ•°è¿”å›æ—¶ ç§»åŠ¨è§†ä¸ºå¯ç”¨ï¼Œå› æ­¤ä¼šè°ƒç”¨åˆ é™¤çš„ç§»åŠ¨å‡½æ•°
     #+begin_src cpp :results output :namespaces std :includes <iostream> <string> <string_view>
     class Name
     {
     private:
         std::string m_name {};
     public:
         Name(std::string_view name) : m_name{ name } { }

         Name(const Name& name) = default;
         Name& operator=(const Name& name) = default;

         // åˆ é™¤ ç§»åŠ¨æ„é€ ï¼Œä¾æ—§æ˜¯å·²å£°æ˜çš„å‡½æ•°ï¼Œä¾æ—§èƒ½ å‡½æ•°é‡è½½è§£æï¼Œcppè§„åˆ™ï¼šå‡½æ•°å€¼è¿”å›ï¼Œæœ‰ç§»åŠ¨ç”¨ç§»åŠ¨
         Name(Name&& name) = delete;
         Name& operator=(Name&& name) = delete;

         const std::string& get() const { return m_name; }
     };

     Name getJoe()
     {
         Name joe{ "Joe" };
         return joe; // FIXME è°ƒç”¨ åˆ é™¤çš„ç§»åŠ¨æ„é€ 
     }

     int main()
     {
         Name n{ getJoe() };
         std::cout << n.get() << '\n';
         return 0;
     }
     #+end_src

7. *ç§»åŠ¨è¯­ä¹‰ å’Œ std::swap*
   ä½¿ç”¨ std::swap() å®ç°ç§»åŠ¨æ„é€ ã€ç§»åŠ¨èµ‹å€¼
   - å­˜åœ¨çš„é—®é¢˜ :: æ— é™é€’å½’ï¼Œstd::swap() ä¼˜å…ˆè°ƒç”¨ ç§»åŠ¨æ„é€ ã€ç§»åŠ¨èµ‹å€¼ [fn:1]
   - è§£å†³ :: ä½¿ç”¨è‡ªå®šä¹‰çš„ swap() [fn:2]


* Footnotes
[fn:2]
#+begin_src cpp :results output :namespaces std :includes <iostream>
#include <iostream>
#include <string>
#include <string_view>

class Name
{
private:
    std::string m_name {};

public:
    Name(std::string_view name) : m_name{ name }
    {
    }

    Name(const Name& name) = delete;
    Name& operator=(const Name& name) = delete;

    // Create our own swap friend function to swap the members of Name
    friend void swap(Name& a, Name& b) noexcept
    {
        // We avoid recursive calls by invoking std::swap on the std::string member,
        // not on Name
        std::swap(a.m_name, b.m_name);
    }

    Name(Name&& name) noexcept
    {
        std::cout << "Move ctor\n";

        swap(*this, name); // Now calling our swap, not std::swap
    }

    Name& operator=(Name&& name) noexcept
    {
        std::cout << "Move assign\n";

        swap(*this, name); // Now calling our swap, not std::swap

        return *this;
    }

    const std::string& get() const { return m_name; }
};

int main()
{
    Name n1{ "Alex" };
    n1 = Name{"Joe"}; // invokes move assignment

    std::cout << n1.get() << '\n';

    return 0;
}
#+end_src


[fn:1]
#+begin_src cpp :results output :namespaces std :includes <iostream> <string> <string_view>
class Name
{
private:
    std::string m_name {}; // std::string is move capable

public:
    Name(std::string_view name) : m_name{ name }
    {
    }

    Name(const Name& name) = delete;
    Name& operator=(const Name& name) = delete;

    Name(Name&& name) noexcept
    {
        std::cout << "Move ctor\n";

        std::swap(*this, name); // bad!
    }

    Name& operator=(Name&& name) noexcept
    {
        std::cout << "Move assign\n";

        std::swap(*this, name); // bad!

        return *this;
    }

    const std::string& get() const { return m_name; }
};

int main()
{
    Name n1{ "Alex" };
    n1 = Name{"Joe"}; // invokes move assignment

    std::cout << n1.get() << '\n';

    return 0;
}
#+end_src
