:PROPERTIES:
:ID:       40c9dfcd-6bcb-4bec-8160-89b3187c4997
:END:
#+title: std::shared_ptr
#+filetags: cpp

* std::shared_ptr [[https://www.learncpp.com/cpp-tutorial/stdshared_ptr/][learncpp22.6]]
1. cpp11， *共享资源* 的智能指针，多个指针共同管理资源
   - 内部 ::
     1) 指针指向 资源
     2) 指针指向 *控制块* ：控制块内部有
        - 强引用计数（ =use_count= ） ：表示管理资源的共享指针数量，管理资源生命周期；
          每增加一个共享指针管理资源：use_count+1；每减少：use_count-1；use_count=0 时，销毁资源
        - 弱引用计数（ =weak_count= ）：表示观察资源的 [[id:eb06d6f0-46b3-4793-836e-6bd8e3a4814e][std::weak_ptr]] 数量，管理控制块生命周期；
          每增加一个弱指针观察资源：weak_count+1；每减少：weak_count-1；当 use_count=0时：weak_count-1；weak_count=0 时，销毁控制块
        #+begin_comment 控制块示例
        *场景1*
        shared指针A指向资源R：控制块use_count=1、weak_count=1
        shared指针B指向R    ：use_count=2、weak_count=1
        销毁B               ：use_count=1、weak_count=1
        销毁A               ：use_count=0、weak_count=0

        *场景2*
        shared指针A指向资源R：控制块use_count=1、weak_count=1
        shared指针B指向R    ：use_count=2、weak_count=1
        weak指针W指向R      ：use_count=2、weak_count=2
        销毁B               ：use_count=1、weak_count=2
        销毁A               ：use_count=0、weak_count=1
        #+end_comment

2. 🔥 常见错误：某个资源被 std::shared_ptr 管理，另一个 std::shared_ptr 不使用拷贝的方式一起管理资源，而是使用资源直接初始化 -> 导致两个指针有各自的 控制块，引用计数不同步 [fn:1]

3. *循环引用* 问题：见 [[id:eb06d6f0-46b3-4793-836e-6bd8e3a4814e][std::weak_ptr]]

4. 可以用 =std::make_shared()= 初始化智能指针，简单安全

5. 创建返回智能指针的函数，选择 *返回 std::unique_ptr* ，因为
   - 可以 [[id:02ce83ed-31b4-4906-89e4-271bbf432834][std::unique_ptr]]  --转换-->  std::shared_ptr
   - 不能 std::shared_ptr  --转换-->  std::unique_ptr


* Footnotes

[fn:1]
#+name: 从资源初始化share指针
#+begin_src cpp :results output :namespaces std :includes <iostream> <memory>
class Resource
{
public:
  Resource() { std::cout << "Resource acquired\n"; }
  ~Resource() { std::cout << "Resource destroyed\n"; }
};

int main()
{
 Resource* res { new Resource };
 std::shared_ptr<Resource> ptr1 { res };   // 直接初始化 ptr1（从资源初始化）
 {
   std::shared_ptr<Resource> ptr2 { res }; // FIXME 直接初始化 ptr2（从资源初始化）
   std::cout << "Killing one shared pointer\n";
 } // ptr2 超出作用域
 std::cout << "Killing another shared pointer\n";
 return 0;
} // ptr1 超出作用域
#+end_src

#+name: 正确做法
#+begin_src cpp :results output :namespaces std :includes <iostream> <memory>
class Resource
{
public:
  Resource() { std::cout << "Resource acquired\n"; }
  ~Resource() { std::cout << "Resource destroyed\n"; }
};

int main()
{
  Resource* res { new Resource };
  std::shared_ptr<Resource> ptr1{ res };     // 直接初始化 ptr1 （用资源直接初始化）
  {
    std::shared_ptr<Resource> ptr2 { ptr1 }; // 拷贝初始化 ptr2 （复制的形式初始化）
    std::cout << "Killing one shared pointer\n";
  } // ptr2 超出作用域
  std::cout << "Killing another shared pointer\n";
  return 0;
} // ptr1超出作用域
#+end_src
