:PROPERTIES:
:ID:       eb06d6f0-46b3-4793-836e-6bd8e3a4814e
:END:
#+title: std::weak_ptr
#+filetags: cpp

* std::weak_ptr [[https://www.learncpp.com/cpp-tutorial/circular-dependency-issues-with-stdshared_ptr-and-stdweak_ptr/][learncpp22.7]] [[https://www.bilibili.com/video/BV1MCN6eeEDV?spm_id_from=333.788.videopod.sections&vd_source=4441bc96046659b39d059d583f36ff52][bilibili-码农Mark]]
1. cpp11，用于解决 [[id:40c9dfcd-6bcb-4bec-8160-89b3187c4997][std::shared_ptr]] 产生的 *循环引用* 问题，因为它是资源的 *观察者* ，不是所有者， *不会增加引用计数* ，内部结构见：[[id:40c9dfcd-6bcb-4bec-8160-89b3187c4997][std::shared_ptr]]、[[id:f8158484-8008-4cb1-86a6-f9a86e5501ae][图:shared_ptr和weak_ptr内部结构]]
   - 循环引用 :: 两个对象内部的 std::shared_ptr 互相指向对象 -> 引用计数无法归 0，内存泄漏 [fn:3] [[https://www.learncpp.com/cpp-tutorial/circular-dependency-issues-with-stdshared_ptr-and-stdweak_ptr/][learncpp22.7]]
     （可以是 a -> b、b -> a；也能是三个对象：a -> b、b -> c、c -> a）
   - 解决     :: 将其中一个类内部指针改为 std::weak_ptr [fn:4]

2. std::weak_ptr 不能直接使用（没有 =operator->= ），必须使用 =lock()= 将其转为 std::shared_ptr [fn:1]

3. 因为 std::weak_ptr 只是观察者，因此需要避免 *悬空引用* ，使用 =expired()= 判断是否指向无效对象（是为true，反之false）[fn:2]


** 图:shared_ptr和weak_ptr内部结构 :ATTACH:
:PROPERTIES:
:ID:       f8158484-8008-4cb1-86a6-f9a86e5501ae
:END:
[[attachment:_20250810_170251screenshot.png]]



* Footnotes
[fn:4]
#+begin_src cpp :results output :namespaces std :includes <iostream> <memory> <string>
class Person
{
  std::string m_name;
  std::weak_ptr<Person> m_partner; // 内部改为 std::weak_ptr
public:
  Person(const std::string &name): m_name(name) { std::cout << m_name << " created\n"; }
  ~Person() { std::cout << m_name << " destroyed\n"; }
  friend bool partnerUp(std::shared_ptr<Person> &p1, std::shared_ptr<Person> &p2)
  {
    if (!p1 || !p2)
      return false;
    p1->m_partner = p2; // std::weak_ptr 是观察者，不是所有者，因此不会增加 引用计数
    p2->m_partner = p1;
    std::cout << p1->m_name << " is now partnered with " << p2->m_name << '\n';
    return true;
  }
};

int main()
{
  auto lucy { std::make_shared<Person>("Lucy") };
  auto ricky { std::make_shared<Person>("Ricky") };
  partnerUp(lucy, ricky);
  return 0;
} // Lucy、Ricky 正常销毁
#+end_src

[fn:3]
#+begin_src cpp :results output :namespaces std :includes <iostream> <memory> <string>
class Person
{
  std::string m_name;
  std::shared_ptr<Person> m_partner; // 指向 Person 的指针
public:
  Person(const std::string &name): m_name(name) { std::cout << m_name << " created\n"; }
  ~Person() { std::cout << m_name << " destroyed\n"; }
  friend bool partnerUp(std::shared_ptr<Person> &p1, std::shared_ptr<Person> &p2)
  {
    if (!p1 || !p2)
      return false;
    p1->m_partner = p2; // p1 内部的共享指针指向 p2
    p2->m_partner = p1; // p2 内部的共享指针指向 p1
    std::cout << p1->m_name << " is now partnered with " << p2->m_name << '\n';
    return true;
  }
};

int main()
{
  auto lucy { std::make_shared<Person>("Lucy") };  // lucy 指向 Person类（Lucy）
  auto ricky { std::make_shared<Person>("Ricky") }; // lucy 指向 Person类（Ricky）
  partnerUp(lucy, ricky); // Lucy 和 Ricky 互指
                          // Lucy 被两个指针指向：lucy、Ricky 内部的 m_partner；Ricky同理被两个指针指
  return 0;
} // 此时释放了两个指针：lucy、ricky；但 Lucy 和 Ricky 还被指针指向（Ricky、Lucy 内部的 m_partner），因此都不会释放
#+end_src

[fn:2]
#+begin_src cpp :results output :namespaces std :includes <iostream> <memory>
// h/t to reader Waldo for an early version of this example
class Resource
{
public:
	Resource() { std::cerr << "Resource acquired\n"; }
	~Resource() { std::cerr << "Resource destroyed\n"; }
};

// Returns a std::weak_ptr to an invalid object
std::weak_ptr<Resource> getWeakPtr()
{
	auto ptr{ std::make_shared<Resource>() };
	return std::weak_ptr<Resource>{ ptr };
} // ptr goes out of scope, Resource destroyed

// Returns a dumb pointer to an invalid object
Resource* getDumbPtr()
{
	auto ptr{ std::make_unique<Resource>() };
	return ptr.get();
} // ptr goes out of scope, Resource destroyed

int main()
{
	auto dumb{ getDumbPtr() };
	std::cout << "Our dumb ptr is: " << ((dumb == nullptr) ? "nullptr\n" : "non-null\n");

	auto weak{ getWeakPtr() };
	std::cout << "Our weak ptr is: " << ((weak.expired()) ? "expired\n" : "valid\n"); // 用 expired() 判断是否指向无效对象

	return 0;
}
#+end_src


[fn:1]
#+begin_src cpp :results output :namespaces std :includes <iostream> <memory> <string>
class Person
{
	std::string m_name;
	std::weak_ptr<Person> m_partner; // note: This is now a std::weak_ptr

public:

	Person(const std::string &name) : m_name(name)
	{
		std::cout << m_name << " created\n";
	}
	~Person()
	{
		std::cout << m_name << " destroyed\n";
	}

	friend bool partnerUp(std::shared_ptr<Person> &p1, std::shared_ptr<Person> &p2)
	{
		if (!p1 || !p2)
			return false;

		p1->m_partner = p2;
		p2->m_partner = p1;

		std::cout << p1->m_name << " is now partnered with " << p2->m_name << '\n';

		return true;
	}
  // NOTE 使用 lock() 将  weak_ptr 转换为 shared_ptr
	std::shared_ptr<Person> getPartner() const { return m_partner.lock(); }

	const std::string& getName() const { return m_name; }
};

int main()
{
	auto lucy { std::make_shared<Person>("Lucy") };
	auto ricky { std::make_shared<Person>("Ricky") };

	partnerUp(lucy, ricky);

	auto partner = ricky->getPartner(); // get shared_ptr to Ricky's partner
	std::cout << ricky->getName() << "'s partner is: " << partner->getName() << '\n';

	return 0;
}
#+end_src

#+RESULTS:
: Lucy created
: Ricky created
: Lucy is now partnered with Ricky
: Ricky's partner is: Lucy
: Ricky destroyed
: Lucy destroyed
