:PROPERTIES:
:ID:       728c2647-c601-4b7e-97dd-d5b21ea45e11
:END:
#+title: std::dynamic_cast
#+filetags: cpp

* std::dynamic_cast [[https://www.learncpp.com/cpp-tutorial/dynamic-casting/][learncpp25.10]]
1. 有虚函数的继承体系中才能使用，用于向下转型，有运行时检查，转型失败（eg：对派生类使用）返回空指针[fn:1]；最佳实践如下
   - 向上转型 :: 派生类 -> 基类，选择 =std::static_cast=
   - 向下转型 :: 基类 -> 派生类，选择 =std::dynamic_cast=
   #+begin_src cpp :results output :namespaces std :includes <iostream>
   struct Base {
       virtual ~Base() {} // 有虚函数
   };
   struct Derived : Base {};

   Base* b = new Derived;
   Derived* d = dynamic_cast<Derived*>(b); // ok

   struct NonPolyBase {}; // 没有虚函数
   struct NonPolyDerived : NonPolyBase {};

   NonPolyBase* npb = new NonPolyDerived;
   // FIXME 不是有虚函数的继承体系，无法使用 std::dynamic_cast
   // NonPolyDerived* npd = dynamic_cast<NonPolyDerived*>(npb);
   #+end_src

2. *使用 std::static_cast 进行向下转型* 可能的问题：没有运行时检查且无法判断是否成功 -> 对着派生类使用向下转型导致转型失败，接着访问派生类成员可能导致未定义行为

3. std::dynamic_cast 进行 *向下转型失效* 的情况
   1) protected 或 private 继承
   2) 不是有虚函数的继承体系

4. 向下转型 和 [[id:b23cd926-82ec-489e-ad8f-96b86e5559c2][虚函数]] *选择*
   优先 虚函数，以下情况使用 向下转型：
   1) 需要访问特定于派生类的内容（eg：仅在派生类中定义的函数）
   2) 无法修改基类以添加虚函数（eg：基类是标准库一部分）

* Footnotes

[fn:1]
#+begin_src cpp :results output :namespaces std :includes <iostream>
int main()
{
  Base* b{ getObject(true) };
  Derived* d{ dynamic_cast<Derived*>(b) }; // 使用 std::dynamic_cast

  if (d) // 检查向下转型是否成功
    std::cout << "The name of the Derived is: " << d->getName() << '\n';

  delete b;
}
#+end_src
