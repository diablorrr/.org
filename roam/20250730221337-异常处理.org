:PROPERTIES:
:ID:       4a8dd90d-37f5-4224-a212-6df329902aa2
:END:
#+title: 异常处理(exceptions)
#+filetags: cpp

* 异常处理(exceptions) [[https://www.learncpp.com/cpp-tutorial/basic-exception-handling/][learncpp27.2]]
1. 为什么要有异常处理？[fn:1]

2. =throw= ：（抛出）异常
   #+begin_src cpp :results output :namespaces std :includes <iostream>
   throw -1;                 // 抛出 整型字面量
   throw ENUM_INVALID_INDEX; // 抛出 枚举值
   throw "Can not take square root of negative number"; // 抛出 C风格字符串
   throw dX;                 // 抛出 double类型变量
   throw MyException("Fatal Error"); // 抛出 MyException类对象
   #+end_src
3. =try= ：（尝试）寻找异常
   #+begin_src cpp :results output :namespaces std :includes <iostream>
   try {                     // try语句用于查找 {}代码块 中的异常
       throw -1;
   }
   #+end_src
4. =catch= ：（捕获）异常并处理
   1) 类似函数参数，可以按 值/引用捕获，不使用参数值可以只放类型名
   #+begin_src cpp :results output :namespaces std :includes <iostream>
   catch (int x) {
       // 处理 int 类型异常
       std::cerr << "We caught an int exception with value" << x << '\n';}

   // 不使用参数值 -> 只放类型名
   catch (double) {std::cerr << "We caught an exception of type double\n";}
   #+end_src

5. 当异常抛出时，会沿着调用栈向上抛出（这是 *栈展开* 的过程[fn:4]，会销毁展开函数的局部变量），直到找到处理异常的代码；若没找到[fn:2]，则调用 =std::terminate()= ，栈不会展开（这就是为什么我们调试 core dump文件，可以看到完整调用栈的原因），且局部变量不会销毁 [[https://www.learncpp.com/cpp-tutorial/exceptions-functions-and-stack-unwinding/][learncpp27.3]]；
   栈展开过程中，异常对象被复制到调用栈外的某个内存区域，在异常得到处理前，会一直在（因此异常必须是可复制的）

6. *通用异常处理程序* ：用 =...= 捕获任何类型的异常，放在异常处理的最后；通常用于包装 =main()= 函数内容，使用后 调试信息会丢失，可以使用 条件编译 解决[fn:3] [[https://www.learncpp.com/cpp-tutorial/uncaught-exceptions-catch-all-handlers/][learncpp27.4]]
   #+begin_src cpp :results output :namespaces std :includes <iostream>
   try {
     throw 5;         // 抛出int类型异常
   }
   catch (double x) { // 捕获double类型异常
     std::cout << "We caught an exception of type double: " << x << '\n';
   }
   catch (...) { // 捕获所有类型异常
     std::cout << "We caught an exception of an undetermined type\n";
   }
   #+end_src

   #+RESULTS:
   : We caught an exception of an undetermined type

7. *异常类* [[https://www.learncpp.com/cpp-tutorial/exceptions-classes-and-inheritance/][learncpp27.5]]
   1) 背景：基本数据类型（eg：int）作为异常类型：含义模糊 [fn:11] -> 异常类名就含有关于异常信息的含义[fn:12]
   2) 继承：派生类可以传入参数为基类引用/指针的 catch子句，且按catch顺序捕获 -> 因此基类放最后 [fn:13]
   3) =std::exception= 类 是所有异常类的基类（接口类），可以用它作为 catch的参数捕获所有异常，使用 =what()= 查看异常描述文本，但一般常用其派生类 =std::runtime_error= [fn:14]
   4) 可以从 std::exception 或其他异常类 *派生自己的类，并重写 =what()= 函数* [fn:15]

8. *重新抛出异常* ：自身不处理，将异常沿着调用栈向上传递 [[https://www.learncpp.com/cpp-tutorial/rethrowing-exceptions/][learncpp27.6]]
   （✨ *BP* ：使用 throw 而不是 throw <新异常> 来抛出捕获的异常）
   - throw <新异常> :: 抛出的新异常（不同于 捕获的异常），出现问题（eg：类切片[fn:6]）
   - throw          :: 抛出的捕获的异常[fn:7]

9. *函数try块* ：用于函数内部捕获异常 [fn:16] [[https://www.learncpp.com/cpp-tutorial/function-try-blocks/][learncpp27.7]]
   1) 可以捕获 基类和当前类的异常 [fn:16]
   2) 构造函数catch块的限制：对于析构函数、其他函数，见下图：[[id:2c7e49f0-9051-4f89-a7b2-a34da2e4b872][函数try块的限制]]
      a. 不允许 处理异常
      b. 不允许 返回语句
      c. catch块末尾隐式重新抛出异常

10. 异常发生时 *清理资源* 的处理 [[https://www.learncpp.com/cpp-tutorial/exception-dangers-and-downsides/][learncpp27.8]]
    1) 清理资源的函数放 try-catch 外[fn:8]
    2) 动态内存
       a. 在 try-catch 外 delete [fn:9]
       b. try 中使用 RAII（eg：智能指针）[fn:10]

11. 类构造函数发生异常，所有已构造类成员会被析构 [fn:5]；析构函数抛出异常，程序终止，因此在析构函数内不使用 try-catch，而是写入日志 [[https://www.learncpp.com/cpp-tutorial/exception-dangers-and-downsides/][learncpp27.8]]

12. 承诺函数不会抛出异常/不会失败，以使编译器能进行优化：使用 [[id:54dd1cc2-2d5f-4971-97cd-57541ddcef10][noexcept]]

13. *何时使用* 异常？异常会增加可执行文件大小，导致运行速度变慢，但以下场景可以使用
    - 错误很严重，执行无法继续
    - 正在处理的错误可能很少发生
    - 错误无法在发生位置处理
    - 没有好的方法将错误码返回给调用者



** 函数try块的限制 :ATTACH:
:PROPERTIES:
:ID:       2c7e49f0-9051-4f89-a7b2-a34da2e4b872
:END:
[[attachment:_20250731_161322screenshot.png]]


* Footnotes
[fn:16]
#+begin_src cpp :results output :namespaces std :includes <iostream>
class A
{
private:
	int m_x;
public:
	A(int x) : m_x{x}
	{
		if (x <= 0)
			throw 1; // 从基类抛出异常：A 的构造函数
	}
};

class B : public A
{
public:
	B(int x) try : A{x} // 这里使用 函数try块
	{
    // if (x <= 0)    // 从当前类抛出异常
		//    throw 1;
	}
	catch (...) // note this is at same level of indentation as the function itself
	{
                // Exceptions from member initializer list or
                // from constructor body are caught here

                std::cerr << "Exception caught\n";

                throw; // rethrow the existing exception
	}
};

int main()
{
	try
	{
		B b{0};
	}
	catch (int)
	{
		std::cout << "Oops\n";
	}
}
#+end_src


[fn:15]
#+begin_src cpp :results output :namespaces std :includes <iostream> <string> <string_view>
#include <exception> // for std::exception

class ArrayException : public std::exception // 派生自己的异常类
{
private:
	std::string m_error{}; // handle our own string

public:
	ArrayException(std::string_view error)
		: m_error{error}
	{
	}

	// 重写 std::exception::what()
	const char* what() const noexcept override { return m_error.c_str(); }
};

class IntArray
{
private:
	int m_data[3] {}; // assume array is length 3 for simplicity

public:
	IntArray() {}

	int getLength() const { return 3; }

	int& operator[](const int index)
	{
		if (index < 0 || index >= getLength())
			throw ArrayException("Invalid index");

		return m_data[index];
	}

};

int main()
{
	IntArray array;

	try
	{
		int value{ array[5] };
	}
	catch (const ArrayException& exception) // derived catch blocks go first
	{
		std::cerr << "An array exception occurred (" << exception.what() << ")\n";
	}
	catch (const std::exception& exception)
	{
		std::cerr << "Some other std::exception occurred (" << exception.what() << ")\n";
	}
}
#+end_src

[fn:14]
#+begin_src cpp :results output :namespaces std :includes <iostream>
#include <exception> // for std::exception
#include <stdexcept> // for std::runtime_error

int main()
{
	try
	{
		throw std::runtime_error("Bad things happened");
	}
	// This handler will catch std::exception and all the derived exceptions too
	catch (const std::exception& exception)
	{
		std::cerr << "Standard exception: " << exception.what() << '\n';
	}

	return 0;
}
#+end_src


[fn:13]
#+begin_src cpp :results output :namespaces std :includes <iostream>
class Base
{
public:
    Base() {}
};

class Derived: public Base
{
public:
    Derived() {}
};

int main()
{
    try
    {
        throw Derived();
    }
    catch (const Derived& derived) // 若这行代码和 catch (const Base& base) 交换，则异常将永远无法被 Derived这行catch代码捕获
    {
        std::cerr << "caught Derived";
    }
    catch (const Base& base)
    {
        std::cerr << "caught Base";
    }

    return 0;
}
#+end_src

[fn:12]
#+begin_src cpp :results output :namespaces std :includes <iostream> <string> <string_view>
// 自定义异常类：数组异常
class ArrayException
{
private:
	std::string m_error;

public:
	ArrayException(std::string_view error)
		: m_error{ error }
	{
	}

	const std::string& getError() const { return m_error; }
};

class IntArray
{
private:
	int m_data[3]{}; // assume array is length 3 for simplicity

public:
	IntArray() {}

	int getLength() const { return 3; }

	int& operator[](const int index)
	{
		if (index < 0 || index >= getLength())
			throw ArrayException{ "Invalid index" }; //使用自定义异常类

		return m_data[index];
	}

};

int main()
{
	IntArray array;

	try
	{
		int value{ array[5] }; // out of range subscript
	}
	catch (const ArrayException& exception)
	{
		std::cerr << "An array exception occurred (" << exception.getError() << ")\n";
	}
}
#+end_src


[fn:11]
#+begin_src cpp :results output :namespaces std :includes <iostream>
// Using the IntArray overloaded operator[] above

try
{
    int* value{ new int{ array[index1] + array[index2]} };
}
catch (int value)
{
    // What are we catching here?
}
#+end_src

[fn:10]
#+begin_src cpp :results output :namespaces std :includes <iostream> <memory>
try
{
    auto* john { new Person("John", 18, PERSON_MALE) };
    std::unique_ptr<Person> upJohn { john }; // 使用智能指针管理

    ProcessPerson(john);

    // ProcessPerson抛出异常，超出作用域时，智能指针自动清理
}
catch (const PersonException& exception)
{
    std::cerr << "Failed to process person: " << exception.what() << '\n';
}
#+end_src


[fn:9]
#+begin_src cpp :results output :namespaces std :includes <iostream>
Person* john{ nullptr };

try
{
    john = new Person("John", 18, PERSON_MALE);
    processPerson(john);
    // delete john; FIXME 这里使用 processPerson 抛出异常，会没法 delete
}
catch (const PersonException& exception)
{
    std::cerr << "Failed to process person: " << exception.what() << '\n';
}

delete john; // ok
#+end_src

[fn:8]
#+begin_src cpp :results output :namespaces std :includes <iostream>
try
{
    openFile(filename);
    writeFile(filename, data);
    // closeFile(filename); FIXME 放这里，若 writeFile 抛出异常，则没法关闭文件
}
catch (const FileException& exception)
{
    std::cerr << "Failed to write to file: " << exception.what() << '\n';
}

// ok
closeFile(filename);
#+end_src


[fn:7]
#+begin_src cpp :results output :namespaces std :includes <iostream>
class Base
{
public:
    Base() {}
    virtual void print() { std::cout << "Base"; }
};

class Derived: public Base
{
public:
    Derived() {}
    void print() override { std::cout << "Derived"; }
};

int main()
{
    try
    {
        try
        {
            throw Derived{};
        }
        catch (Base& b)
        {
            std::cout << "Caught Base b, which is actually a ";
            b.print();
            std::cout << '\n';
            throw; // 重新抛出，没有发生对象切片
        }
    }
    catch (Base& b)
    {
        std::cout << "Caught Base b, which is actually a ";
        b.print();
        std::cout << '\n';
    }

    return 0;
}
#+end_src

#+RESULTS:
: Caught Base b, which is actually a Derived
: Caught Base b, which is actually a Derived


[fn:6]
#+begin_src cpp :results output :namespaces std :includes <iostream>
class Base
{
public:
    Base() {}
    virtual void print() { std::cout << "Base"; }
};

class Derived: public Base
{
public:
    Derived() {}
    void print() override { std::cout << "Derived"; }
};

int main()
{
    try
    {
        try
        {
            throw Derived{}; // 抛出 派生类 异常
        }
        catch (Base& b)      // ok：以基类引用 捕获 异常 -> Base引用 指向 Derived对象
        {
            std::cout << "Caught Base b, which is actually a ";
            b.print();
            std::cout << '\n';
            throw b; // 抛出 Base新异常，该异常 通过 复制b初始化，发生对象切片
        }
    }
    catch (Base& b)
    {
        std::cout << "Caught Base b, which is actually a ";
        b.print();
        std::cout << '\n';
    }

    return 0;
}
#+end_src

#+RESULTS:
: Caught Base b, which is actually a Derived
: Caught Base b, which is actually a Base


[fn:5]
#+begin_src cpp :results output :namespaces std :includes <iostream>
class Member
{
public:
      Member() {
          std::cerr << "Member allocated some resources\n"; }

      ~Member() {
          std::cerr << "Member cleaned up\n";}
};

class A
{
private:
      int m_x {};
      Member m_member;

public:
      A(int x) : m_x{x}
      {
          if (x <= 0)
              throw 1;
      }

      ~A() {
          std::cerr << "~A\n"; // should not be called
      }
};


int main() {
      try {
          A a{0};      // m_x 构造失败，所有成员都会被析构
      }
      catch (int) {
          std::cerr << "Oops\n";
      }
}

// 输出：
// Member allocated some resources
// Member cleaned up
// Oops
#+end_src

[fn:4]
#+begin_src cpp :results output :namespaces std :includes <iostream>
void D() { // called by C()
    std::cout << "Start D\n";
    std::cout << "D throwing int exception\n";

    throw - 1;

    std::cout << "End D\n"; // skipped over
}

void C() { // called by B()
    std::cout << "Start C\n";
    D();
    std::cout << "End C\n";
}

void B() { // called by A()
    std::cout << "Start B\n";

    try {
        C();
    }
    catch (double) // not caught: exception type mismatch
    {
        std::cerr << "B caught double exception\n";
    }

    try{ }
    catch (int) // not caught: exception not thrown within try
    {
        std::cerr << "B caught int exception\n";
    }

    std::cout << "End B\n";
}

void A() // called by main()
{
    std::cout << "Start A\n";

    try {
        B();
    }
    catch (int) // exception caught here and handled
    {
        std::cerr << "A caught int exception\n";
    }
    catch (double) // not called because exception was handled by prior catch block
    {
        std::cerr << "A caught double exception\n";
    }

    // execution continues here after the exception is handled
    std::cout << "End A\n";
}

int main() {
    std::cout << "Start main\n";

    try {
        A();
    }
    catch (int) // not called because exception was handled by A
    {
        std::cerr << "main caught int exception\n";
    }
    std::cout << "End main\n";

    return 0;
}
#+end_src

#+RESULTS:
: Start main
: Start A
: Start B
: Start C
: Start D
: D throwing int exception
: End A
: End main


[fn:3]
#+begin_src cpp :results output :namespaces std :includes <iostream>
struct GameSession {
    // Game session data here
};

void runGame(GameSession&) {
    throw 1;
}

void saveGame(GameSession&) {
    // Save user's game here
}

class DummyException // a dummy class that can't be instantiated
{
    DummyException() = delete;
};

int main() {
    GameSession session{};

    try
    {
        runGame(session);
    }
#ifndef NDEBUG       // 2. 加入 条件编译指令，使得调试版本能正确调试
    catch(...)
    {
        std::cerr << "Abnormal termination\n";
    }
#else
    catch(DummyException)
    {
    }
#endif

    saveGame(session); // 1.捕获异常后，保存用户信息；代价是：不适合 debug，因为栈全都展开了

    return 0;
}
#+end_src

[fn:2]
#+begin_src cpp :results output :namespaces std :includes <iostream> <cmath>
double mySqrt(double x) {
    if (x < 0.0)
        throw "Can not take sqrt of negative number"; // 抛出异常

    return std::sqrt(x);
}

int main() {
    std::cout << "Enter a number: ";
    double x;
    std::cin >> x;

    // 没有异常处理程序：会导致调用 std::terminate()
    std::cout << "The sqrt of " << x << " is " << mySqrt(x) << '\n';
}
#+end_src


[fn:1]
#+name: 背景
#+begin_example
函数进行错误处理的难处：函数有自身的返回值，又要返回错误码 -> 错误码是数字的话晦涩难懂，又要和代码紧密相连影响代码本身的布局（为了错误检测增加了代码）
#+end_example

#+name: 不使用错误码
#+begin_src cpp :results output :namespaces std :includes <iostream>
double divide(int x, int y) {
    return static_cast<double>(x)/y;
}
#+end_src

#+name: 使用错误码
#+begin_src cpp :results output :namespaces std :includes <iostream>
double divide(int x, int y, bool& outSuccess) {
    if (y == 0) {
        outSuccess = false;
        return 0.0;
    }
    outSuccess = true;
    return static_cast<double>(x)/y;
}
#+end_src
