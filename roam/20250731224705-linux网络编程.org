:PROPERTIES:
:ID:       5c1b500f-331f-4f72-acb0-a14120c1fc0a
:END:
#+title: socket编程(linux网络编程)
#+filetags: linux network

* socket
1. 套接字，通过系统调用 =socket()= 创建并返回 *用于网络通信的文件描述符* （fd），后续网络通信的操作都是基于此fd
   - 文件描述符 :: 与打开文件关联的整数；这个文件可以是
     1) 网络连接
     2) 管道
     3) 终端
     4) ...

2. socket编程的 *基本流程*
   - 服务端： =socket= ：创建并返回用于网络通信的 fd -> =bind= ：绑定 socket 到本地IP端口 -> =listen= ：监听 -> =accept= ：接受连接，返回新的socket的文件描述符 -> =recv/send= ：收发数据
   - 客户端： =socket= -> =connect= -> =send/recv=


* htons、htonl、ntohs、ntohl
1. 用于 主机/网络 字节序转换
2. 字节序 分为 [[id:6fd1734a-d124-4cec-b323-95c6c188c1a1][大端序和小端序]]
3. 字节序转换
   #+begin_src C
   htons()  // 主机到网络short格式
   htonl()  // 主机到网络long格式
   ntohs()  // 网络到主机short格式
   ntohl()  // 网络到主机long格式
   #+end_src


* inet_pton、inet_ntop
# p 为 print，n 为 network
C风格字符串 转为 sa.sin_addr（字符串 -> 二进制）

#+begin_src C
struct sockaddr_in sa;   // IPv4
struct sockaddr_in6 sa6; // IPv6

// 错误返回 -1，地址有误返回 0，结果无误返回 >0
inet_pton(AF_INET, "10.12.110.57", &(sa.sin_addr));
inet_pton(AF_INET6, "2001:db8:63b3:1::3490", &(sa6.sin6_addr));

// IPv4:
char ip4[INET_ADDRSTRLEN];  // space to hold the IPv4 string
struct sockaddr_in sa;      // pretend this is loaded with something
inet_ntop(AF_INET, &(sa.sin_addr), ip4, INET_ADDRSTRLEN);
printf("The IPv4 address is: %s\n", ip4);

// IPv6:
char ip6[INET6_ADDRSTRLEN]; // space to hold the IPv6 string
struct sockaddr_in6 sa6;    // pretend this is loaded with something
inet_ntop(AF_INET6, &(sa6.sin6_addr), ip6, INET6_ADDRSTRLEN);
printf("The address is: %s\n", ip6);
#+end_src


* socket相关的数据结构
** addrinfo 结构体
配置信息去查询内容，返回的实际内容在 sockaddr（调用 getaddrinfo() 填充该结构体，并以链表形式返回）
#+begin_src C
struct addrinfo {
    int              ai_flags;     // AI_PASSIVE, AI_CANONNAME, etc.
    int              ai_family;    // AF_INET, AF_INET6, AF_UNSPEC（设置IPv4、IPv6、任意）相当于是我要求返回的协议族，实际返回的协议族在 sockaddr中
    int              ai_socktype;  // SOCK_STREAM, SOCK_DGRAM
    int              ai_protocol;  // use 0 for "any"
    size_t           ai_addrlen;   // size of ai_addr in bytes
    struct sockaddr *ai_addr;      // struct sockaddr_in or _in6
    char            *ai_canonname; // full canonical hostname

    struct addrinfo *ai_next;      // 指向下一个链表节点
};
#+end_src

** sockaddr 结构体
通用地址结构体；保存套接字地址信息，但是 sa_data 是 char[14] 不够直观，因此使用 sockaddr_in、sockaddr_in6 替代
可以和 struct sockaddr_in* 互转
#+begin_src C
struct sockaddr {
    unsigned short    sa_family;    // address family, AF_xxx（设置IPv4、IPv6、任意）
    char              sa_data[14];  // 14 bytes of protocol address（套接字目标地址和端口号）
};
#+end_src

** sockaddr_in 结构体
IPv4 专用地址结构体，比 sockaddr 更直观
#+begin_src C
struct sockaddr_in {
    short int          sin_family;  // Address family, AF_INET（协议族）
    unsigned short int sin_port;    // Port number（端口）使用 htons转网络字节序
    struct in_addr     sin_addr;    // Internet address（IP地址）
    unsigned char      sin_zero[8]; // 用于填充该结构体的长度：与 struct sockaddr 一致，使用 memset() 设置全0
};

// Internet address (a structure for historical reasons)
struct in_addr {
    uint32_t s_addr; // that's a 32-bit int (4 bytes)
};
#+end_src

** sockaddr_in6 结构体
IPv6 专用地址结构体，比 sockaddr 更直观
#+begin_src C
struct sockaddr_in6 {
    u_int16_t       sin6_family;   // address family, AF_INET6
    u_int16_t       sin6_port;     // port, Network Byte Order
    u_int32_t       sin6_flowinfo; // IPv6 flow information
    struct in6_addr sin6_addr;     // IPv6 address
    u_int32_t       sin6_scope_id; // Scope ID
};

struct in6_addr {
    unsigned char   s6_addr[16];   // IPv6 address
};
#+end_src

** sockaddr_storage 结构体


* epoll相关的数据结构
** epoll_event
epoll事件的数据结构

#+begin_src C
typedef union epoll_data
{
  void *ptr;
  int fd;
  uint32_t u32;
  uint64_t u64;
} epoll_data_t;

struct epoll_event
{
  uint32_t events;    // 关注的事件类型
  epoll_data_t data;  // 用户数据
} __EPOLL_PACKED;
#+end_src

关注的事件类型：
- EPOLLIN      :: 数据可读
- EPOLLOUT     :: 数据可写
- EPOLLERR     :: 错误条件
- EPOLLHUP     :: 连接完全断开（读写都断开）
- EPOLLRDHUP   :: 对端写关闭
- EPOLLPRI     :: 紧急数据
- EPOLLET      :: 边缘触发模式（默认是水平触发）
- EPOLLONESHOT :: 单次触发后禁用监控


* getaddrinfo
解析主机名和服务名，返回地址信息结构链表（自动填充addrinfo结构体，并以链表形式返回）

#+begin_src C
int getaddrinfo
(const char *nodename,
const char *servname,
const struct addrinfo *hints,
struct addrinfo ​**​res)
#+end_src
- nodename :: 要连接的 主机名或IP地址字符串（如"example.com"或"192.0.2.1"）
- servname :: 服务名或端口号字符串（如"http"或"80"）
- hints :: 指向已填写相关信息的 struct addrinfo
- res :: 用于存储返回结果链表的指针地址

#+name: 监听主机IP地址（端口为 3490）
#+begin_src C
int status;
struct addrinfo hints;      // 手动填写期望的内容
struct addrinfo *servinfo;  // 指向结果

memset(&hints, 0, sizeof hints); // make sure the struct is empty
hints.ai_family = AF_UNSPEC;     // don't care IPv4 or IPv6
hints.ai_socktype = SOCK_STREAM; // TCP stream sockets
hints.ai_flags = AI_PASSIVE;     // 将本地主机的地址分配给套接字结构体

if ((status = getaddrinfo(NULL, "3490", &hints, &servinfo)) != 0) {
    fprintf(stderr, "gai error: %s\n", gai_strerror(status));
    exit(1);
}

// servinfo now points to a linked list of 1 or more
// struct addrinfos

// ... do everything until you don't need servinfo anymore ....

freeaddrinfo(servinfo); // free the linked-list
#+end_src

#+name: 连接到特定服务器
#+begin_src C
int status;
struct addrinfo hints;
struct addrinfo *servinfo;  // will point to the results

memset(&hints, 0, sizeof hints); // make sure the struct is empty
hints.ai_family = AF_UNSPEC;     // don't care IPv4 or IPv6
hints.ai_socktype = SOCK_STREAM; // TCP stream sockets

// get ready to connect
status = getaddrinfo("www.example.net", "3490", &hints, &servinfo);

// servinfo now points to a linked list of 1 or more
// struct addrinfos

// etc.
#+end_src


* socket
创建并返回一个用于网络通信的套接字描述符（文件描述符）

#+begin_src C
int socket
(int domain,
int type,
int protocol)
#+end_src
- domain :: 指定通信域（如AF_INET对应IPv4，AF_INET6对应IPv6）
- type :: 指定套接字类型（如SOCK_STREAM对应TCP，SOCK_DGRAM对应UDP）
- protocol :: 指定使用的协议（通常设为0表示自动选择）

#+begin_src C
int s;
struct addrinfo hints, *res;

getaddrinfo("www.example.com", "http", &hints, &res);

s = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
#+end_src


* connect
连接指定服务器

#+begin_src C
int connect
(int sockfd,
struct sockaddr *serv_addr,
int addrlen)
#+end_src
- sockfd :: 已创建的套接字文件描述符
- serv_addr :: 指向目标服务器地址结构的指针（包含IP和端口）
- addrlen :: 服务器地址结构的长度（通常为sizeof(struct sockaddr)）

#+begin_src C
struct addrinfo hints, *res;
int sockfd;

// first, load up address structs with getaddrinfo():
memset(&hints, 0, sizeof hints);
hints.ai_family = AF_UNSPEC;
hints.ai_socktype = SOCK_STREAM;

getaddrinfo("www.example.com", "3490", &hints, &res);

// make a socket:
sockfd = socket(res->ai_family, res->ai_socktype, res->ai_protocol);

// connect!
connect(sockfd, res->ai_addr, res->ai_addrlen);


// 古代
int sock = socket(AF_INET, SOCK_STREAM, 0); // 创建TCP套接字
struct sockaddr_in server_addr;
server_addr.sin_family = AF_INET;
server_addr.sin_port = htons(80); // HTTP端口
inet_pton(AF_INET, "192.0.2.1", &server_addr.sin_addr); // 设置IP

connect(sock, (struct sockaddr*)&server_addr, sizeof(server_addr)); // 连接服务器
// 连接成功后可以开始发送/接收数据
close(sock); // 关闭连接
#+end_src


* bind
将套接字绑定到指定的本地地址和端口

#+begin_src C
int bind
(int sockfd,
struct sockaddr *my_addr,
int addrlen)
#+end_src
- sockfd :: 要绑定的套接字文件描述符
- my_addr :: 指向要绑定的本地地址结构体的指针
- addrlen :: 地址结构体的长度（通常为sizeof(struct sockaddr)）

#+begin_src C
struct addrinfo hints, *res;
int sockfd;

// first, load up address structs with getaddrinfo():
memset(&hints, 0, sizeof hints);
hints.ai_family = AF_UNSPEC;  // use IPv4 or IPv6, whichever
hints.ai_socktype = SOCK_STREAM;
hints.ai_flags = AI_PASSIVE;     // fill in my IP for me

getaddrinfo(NULL, "3490", &hints, &res);

// make a socket:
sockfd = socket(res->ai_family, res->ai_socktype, res->ai_protocol);

// bind it to the port we passed in to getaddrinfo():
bind(sockfd, res->ai_addr, res->ai_addrlen);


// 古代
int sock = socket(AF_INET, SOCK_STREAM, 0); // 创建TCP套接字
struct sockaddr_in addr;
memset(&addr, 0, sizeof(addr));
addr.sin_family = AF_INET;
addr.sin_port = htons(8080); // 绑定到8080端口
addr.sin_addr.s_addr = INADDR_ANY; // 绑定到所有本地接口

if (bind(sock, (struct sockaddr*)&addr, sizeof(addr)) < 0) {
perror("bind failed"); // 绑定失败处理
exit(EXIT_FAILURE);
}
// 绑定成功后可以开始监听连接
close(sock); // 关闭套接字
#+end_src


* listen
将套接字设置为监听状态，准备接受连接请求

#+begin_src C
int listen
(int sockfd,
int backlog)
#+end_src
- sockfd :: 已绑定的套接字文件描述符
- backlog :: 队列最大长度（里面存放等待处理的连接，直到 accept() 处理）

#+begin_src C
int sock = socket(AF_INET, SOCK_STREAM, 0);
struct sockaddr_in addr = {0};
addr.sin_family = AF_INET;
addr.sin_port = htons(8080);
addr.sin_addr.s_addr = INADDR_ANY;

bind(sock, (struct sockaddr*)&addr, sizeof(addr));
listen(sock, 5); // 开始监听，最多允许5个连接排队等待

// 之后可以调用accept()接受连接
close(sock);
#+end_src


* accept
接受客户端连接请求并创建新的通信套接字

#+begin_src C
int accept
(int sockfd,
struct sockaddr *addr,
socklen_t *addrlen)
#+end_src
- sockfd :: 处于监听状态（listen）的套接字描述符
- addr :: 用于存储客户端地址信息的缓冲区指针（可为NULL）
- addrlen :: 输入时为addr缓冲区大小，输出时为实际地址长度（可为NULL）

#+begin_src C
#include <string.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netdb.h>

#define MYPORT "3490"  // the port users will be connecting to
#define BACKLOG 10     // how many pending connections queue holds

int main(void)
{
    struct sockaddr_storage their_addr;
    socklen_t addr_size;
    struct addrinfo hints, *res;
    int sockfd, new_fd;

    // !! don't forget your error checking for these calls !!
    // first, load up address structs with getaddrinfo():
    memset(&hints, 0, sizeof hints);
    hints.ai_family = AF_UNSPEC;  // use IPv4 or IPv6, whichever
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_flags = AI_PASSIVE;     // fill in my IP for me

    getaddrinfo(NULL, MYPORT, &hints, &res);

    // make a socket, bind it, and listen on it:
    sockfd = socket(res->ai_family, res->ai_socktype,
                                                 res->ai_protocol);
    bind(sockfd, res->ai_addr, res->ai_addrlen);
    listen(sockfd, BACKLOG);

    // now accept an incoming connection:
    addr_size = sizeof their_addr;
    new_fd = accept(sockfd, (struct sockaddr *)&their_addr, &addr_size);
    // ready to communicate on socket descriptor new_fd!
}
#+end_src


* accept4
接受一个套接字连接并可选地设置非阻塞和 close-on-exec 标志

#+begin_src C
int accept4
(int sockfd,
struct sockaddr *addr,
socklen_t *addrlen,
int flags)
#+end_src

- sockfd :: 监听中的套接字文件描述符
- addr :: 用于存储客户端地址信息的缓冲区（可为 NULL）
- addrlen :: 指向地址结构长度的指针（输入时为缓冲区大小，输出时为实际长度）
- flags :: 控制套接字行为的标志（如 SOCK_NONBLOCK、SOCK_CLOEXEC）
- 返回值 :: 新连接的文件描述符，错误时返回 -1

#+begin_src C
int connfd = accept4(sockfd, NULL, NULL, SOCK_NONBLOCK); // 接受新连接并设为非阻塞
#+end_src 


* send
通过已连接的套接字发送数据

#+begin_src C
int send
(int sockfd,
const void *msg,
int len,
int flags)
#+end_src
- sockfd :: 已建立连接的套接字描述符
- msg :: 要发送数据的缓冲区指针
- len :: 要发送数据的长度（字节数）
- flags :: 控制发送行为的标志位（通常设为0）

#+begin_src C
int sock = socket(AF_INET, SOCK_STREAM, 0);
// ...连接(connect)操作...

const char *message = "Hello Server!";
int bytes_sent = send(sock, message, strlen(message), 0); // 发送数据

if (bytes_sent < 0) {
perror("send failed");
exit(EXIT_FAILURE);
}
close(sock);
#+end_src


* recv
从已连接的套接字接收数据

#+begin_src C
int recv
(int sockfd,
void *buf,
int len,
int flags)
#+end_src
- sockfd :: 已建立连接的套接字描述符
- buf :: 用于存储接收数据的缓冲区指针
- len :: 缓冲区最大容量（字节数）
- flags :: 控制接收行为的标志位（通常设为0）

#+begin_src C
int sock = socket(AF_INET, SOCK_STREAM, 0);
// ...连接(connect)操作...

char buffer[1024];
int bytes_received = recv(sock, buffer, sizeof(buffer)-1, 0); // 接收数据

if (bytes_received < 0) {
perror("recv failed");
exit(EXIT_FAILURE);
}
buffer[bytes_received] = '\0'; // 确保字符串终止
close(sock);
#+end_src


* sendto
通过无连接套接字发送数据到指定地址

#+begin_src C
int sendto
(int sockfd,
const void *msg,
int len,
unsigned int flags,
const struct sockaddr *to,
socklen_t tolen)
#+end_src
- sockfd :: 已创建的套接字描述符（通常为SOCK_DGRAM类型）
- msg :: 要发送数据的缓冲区指针
- len :: 要发送数据的长度（字节数）
- flags :: 控制发送行为的标志位（通常设为0）
- to :: 指向目标地址结构体的指针
- tolen :: 目标地址结构体的长度

#+begin_src C
int sock = socket(AF_INET, SOCK_DGRAM, 0); // 创建UDP套接字
struct sockaddr_in dest_addr;
memset(&dest_addr, 0, sizeof(dest_addr));
dest_addr.sin_family = AF_INET;
dest_addr.sin_port = htons(12345);
inet_pton(AF_INET, "192.168.1.100", &dest_addr.sin_addr);

const char message = "Hello UDP!";
sendto(sock, message, strlen(message), 0, // 发送UDP数据包
(struct sockaddr)&dest_addr, sizeof(dest_addr));

close(sock);
#+end_src


* recvfrom
从无连接套接字接收数据并获取发送方地址

#+begin_src C
int recvfrom
(int sockfd,
void *buf,
int len,
unsigned int flags,
struct sockaddr *from,
int *fromlen)
#+end_src
- sockfd :: 已创建的套接字描述符（通常为SOCK_DGRAM类型）
- buf :: 用于存储接收数据的缓冲区指针
- len :: 缓冲区最大容量（字节数）
- flags :: 控制接收行为的标志位（通常设为0）
- from :: 用于存储发送方地址信息的缓冲区指针（可为NULL）
- fromlen :: 输入时为from缓冲区大小，输出时为实际地址长度（可为NULL）

#+begin_src C
int sock = socket(AF_INET, SOCK_DGRAM, 0); // 创建UDP套接字
struct sockaddr_in server_addr;
memset(&server_addr, 0, sizeof(server_addr));
server_addr.sin_family = AF_INET;
server_addr.sin_port = htons(12345);
server_addr.sin_addr.s_addr = INADDR_ANY;
bind(sock, (struct sockaddr*)&server_addr, sizeof(server_addr));

char buffer[1024];
struct sockaddr_in client_addr;
socklen_t addr_len = sizeof(client_addr);
int bytes_received = recvfrom(sock, buffer, sizeof(buffer), 0, // 接收UDP数据包
(struct sockaddr*)&client_addr, &addr_len);

if (bytes_received < 0) {
perror("recvfrom failed");
exit(EXIT_FAILURE);
}
buffer[bytes_received] = '\0'; // 确保字符串终止
close(sock);
#+end_src


* close
关闭文件描述符（包括套接字）并释放相关资源

#+begin_src C
int close
(int fd)
#+end_src
- fd :: 要关闭的文件描述符（可以是套接字或普通文件）

#+begin_src C
int sock = socket(AF_INET, SOCK_STREAM, 0); // 创建TCP套接字
// ...连接(connect)和通信操作...

if (close(sock) < 0) { // 关闭套接字
perror("close failed");
exit(EXIT_FAILURE);
}

int file_fd = open("example.txt", O_RDONLY);
close(file_fd); // 关闭普通文件
#+end_src


* shutdown
关闭套接字的部分或全部通信功能

#+begin_src C
int shutdown
(int sockfd,
int how)
#+end_src
- sockfd :: 要操作的套接字描述符
- how :: 关闭方式：
  + SHUT_RD (0) - 关闭接收功能
  + SHUT_WR (1) - 关闭发送功能
  + SHUT_RDWR (2) - 同时关闭接收和发送功能，同 close()

#+begin_src C
int sock = socket(AF_INET, SOCK_STREAM, 0);
// ...连接(connect)和通信操作...

shutdown(sock, SHUT_WR); // 关闭发送功能，通知对方数据发送完毕
char buffer[1024];
while(recv(sock, buffer, sizeof(buffer), 0) > 0); // 继续接收剩余数据

shutdown(sock, SHUT_RD); // 关闭接收功能
close(sock); // 完全关闭套接字
#+end_src


* getpeername
获取已连接套接字的对端（远程）地址信息

#+begin_src C
int getpeername
(int sockfd,
struct sockaddr *addr,
int *addrlen)
#+end_src
- sockfd :: 已建立连接的套接字描述符
- addr :: 用于存储对端地址信息的缓冲区指针
- addrlen :: 输入时为addr缓冲区大小，输出时为实际地址长度

#+begin_src C
int sock = socket(AF_INET, SOCK_STREAM, 0);
// ...连接(connect)操作...

struct sockaddr_in peer_addr;
socklen_t addr_len = sizeof(peer_addr);
if (getpeername(sock, (struct sockaddr*)&peer_addr, &addr_len) == 0) {
char ip[INET_ADDRSTRLEN];
inet_ntop(AF_INET, &peer_addr.sin_addr, ip, sizeof(ip));
printf("Connected to %s:%d\n", ip, ntohs(peer_addr.sin_port));
}
close(sock);
#+end_src


* gethostname
获取本地主机的标准主机名

#+begin_src C
int gethostname
(char *hostname,
size_t size)
#+end_src
- hostname :: 用于存储主机名的字符缓冲区指针
- size :: 缓冲区的大小（字节数）

#+begin_src C
char hostname[256];
if (gethostname(hostname, sizeof(hostname)) == 0) {
printf("Local hostname: %s\n", hostname); // 输出如"Local hostname: mycomputer"
} else {
perror("gethostname failed");
}
#+end_src


* fcntl
控制文件描述符的属性（包括套接字）

#+begin_src C
int fcntl
(int fd,
int cmd,
... /* arg */ )
#+end_src
- fd :: 要操作的文件描述符
- cmd :: 控制命令（如F_GETFL获取状态标志，F_SETFL设置状态标志）
- arg :: 可选参数，取决于cmd（如设置非阻塞模式时传O_NONBLOCK）

#+begin_src C
int sock = socket(AF_INET, SOCK_STREAM, 0);

// 获取当前文件状态标志
int flags = fcntl(sock, F_GETFL, 0);

// 设置为非阻塞模式
fcntl(sock, F_SETFL, flags | O_NONBLOCK);

// 检查是否设置成功
if (fcntl(sock, F_GETFL, 0) & O_NONBLOCK) {
printf("Socket is now non-blocking\n");
}
close(sock);
#+end_src


* setsockopt
设置套接字选项

#+begin_src C
int setsockopt
(int sockfd,
int level,
int optname,
const void *optval,
socklen_t optlen)
#+end_src
- sockfd :: 要设置的套接字描述符
- level :: 选项级别（如SOL_SOCKET表示通用套接字选项）
- optname :: 选项名称（如SO_REUSEADDR表示地址重用）
- optval :: 指向选项值的指针
- optlen :: 选项值的长度

#+begin_src C
int sock = socket(AF_INET, SOCK_STREAM, 0);

// 设置地址重用选项
int enable = 1;
setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &enable, sizeof(enable));

// 设置接收超时为5秒
struct timeval timeout;
timeout.tv_sec = 5;
timeout.tv_usec = 0;
setsockopt(sock, SOL_SOCKET, SO_RCVTIMEO, &timeout, sizeof(timeout));

close(sock);
#+end_src


* epoll_create
创建epoll实例并返回文件描述符

#+begin_src C
int epoll_create
(int size)
#+end_src
- size :: 内核事件表的初始大小（Linux 2.6.8后忽略此参数，但必须大于0）

#+begin_src C
int epfd = epoll_create(1); // 创建epoll实例
if (epfd == -1) {
perror("epoll_create failed");
exit(EXIT_FAILURE);
}

// 可在此添加epoll_ctl操作管理监控的文件描述符
close(epfd); // 关闭epoll实例
#+end_src


* epoll_ctl
控制epoll实例中的文件描述符监控事件

#+begin_src C
int epoll_ctl
(int epfd,
int op,
int fd,
struct epoll_event *event)
#+end_src
- epfd :: epoll实例的文件描述符
- op :: 操作类型：
  + EPOLL_CTL_ADD（添加监控）
  + EPOLL_CTL_MOD（修改监控）
  + EPOLL_CTL_DEL（删除监控）

- fd :: 要操作的目标文件描述符
- event :: 指向epoll_event结构体的指针（定义监控事件）

#+begin_src C
int epfd = epoll_create(1);
int sock = socket(AF_INET, SOCK_STREAM, 0);

struct epoll_event ev;
ev.events = EPOLLIN | EPOLLET; // 监控可读事件，边缘触发模式
ev.data.fd = sock;

epoll_ctl(epfd, EPOLL_CTL_ADD, sock, &ev); // 添加socket到epoll监控

// ...后续可通过epoll_wait获取事件通知...
close(sock);
close(epfd);
#+end_src


* epoll_wait
等待epoll实例中的文件描述符事件触发

#+begin_src C
int epoll_wait
(int epfd,
struct epoll_event *events,
int maxevents,
int timeout)
#+end_src
- epfd :: epoll 实例的文件描述符
- events :: 用于存储就绪事件的数组
- maxevents :: 最多监听的事件数量
- timeout :: 超时时间（毫秒，-1 表示阻塞等待）
- 返回值 :: 就绪事件的数量（超时返回 0，出错返回 -1）

#+begin_src C
int n = epoll_wait(epfd, events, 10, 1000); // 等待最多 10 个事件，超时 1 秒
#+end_src
