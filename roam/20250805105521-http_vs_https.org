:PROPERTIES:
:ID:       b0b55d01-31a8-4684-b94e-880240e10f2a
:END:
#+title: HTTP vs HTTPS
#+filetags: network

* HTTP vs HTTPS :ATTACH:
:PROPERTIES:
:ID:       588c6cd1-1452-40bd-802b-fc6b2baf736b
:END:
[[attachment:_20250805_105648screenshot.png]]

*HTTP*
1. 使用 明文传输 ，简单快速，但存在安全漏洞：
   1) 窃听
   2) 篡改
   3) 冒充
2. TCP端口：80

*HTTPS*
1. 增加了SSL/TLS层：提供
   1) 加密传输：防窃听（通信建立前使用非对称加密，建立后使用对称加密）
   2) 校验机制：防篡改（摘要算法）
   3) 数字证书：验证服务器身份，防冒充
   机制，更安全，但速度更慢（[[id:ceed6c1f-7585-4884-874d-eb2dbf4145ae][TCP三次握手]] 后还需要 TLS四次握手）
2. TCP端口：443


* TLS四次握手
1. *Client Hello* ：TLS版本、支持的加密套件、第1随机数
2. *Server Hello* ：TLS版本、加密套件、第2随机数（服务端确认TLS版本、选择加密套件）
   *Certificate*  ：数字证书（内含公钥：证实服务端身份）
   *Server Hello Done* ：（表示发送完了）
   # 客户端根据 服务端数字证书的签发者 找到中间CA
   # 根据 中间CA数字证书的签发者 找到根CA
   # 用预先存放在浏览器/操作系统根CA公钥 验证 中间CA数字证书，验证成功后，用中间CA公钥 验证 服务器数字证书 -> 服务器公钥可信
3. *Client Key Exchange* ：服务器公钥加密的预主密钥                       -> =非对称加密=
   # 服务端用私钥解密 -> 得到预主密钥
   客户端、服务端用 第1随机数、第2随机数、预主密钥 -> 得到 会话密钥
   *Change Cipher Spec* ：告诉服务器，开始使用会话密钥加密通信            -> =对称加密=
   *Finished* ：所有握手数据的摘要，供服务器校验
   # 服务端 解密摘要，验证是否一致，若一致发送以下内容
4. *Change Cipher Spec* ：告诉客户端，开始使用会话密钥加密通信
   # 数据传输阶段：经过会话密钥加密后的 数据+摘要算法（基于摘要的MAC）
   *Finished* ：所有握手数据的摘要，供客户端校验

** 图:TLS四次握手 :ATTACH:
:PROPERTIES:
:ID:       aac5ee6b-3e88-488f-afa1-66f43b5278cc
:END:
[[attachment:_20250821_131128screenshot.png]]


* 对称加密、非对称加密
:PROPERTIES:
:ID:       6ec0df81-e7a0-4ba7-bbc1-8b9e67e4fd08
:END:
*对称加密* ：加密解密使用同一把密钥；加密解密的速度快，安全性较低（在网络中传递密钥，容易被偷，导致数据安全无法得到保障）
#+begin_example
你给我密钥，我把密钥加密后的数据给你，中间人偷到密钥，中间人能解密
#+end_example

*非对称加密* ：加密解密使用一对密钥，公钥可以公开传播，私钥必须保密：公钥/私钥 加密，私钥/公钥 解密；加密解密的速度慢，安全性高（在网络中传递公钥，安全）
#+begin_example
你给我公钥，我把公钥加密后的数据给你，中间人偷到公钥，中间人无法解密
#+end_example


* 服务端申请数字证书 :ATTACH:
:PROPERTIES:
:ID:       1cc489e2-46d9-45f6-98c7-3e27b69e2a24
:END:
1. 服务端将公钥和自己相关的信息交给 中间CA，中间CA用这些信息计算出hash值，再用自己的私钥加密，生成 数字签名，（数字签名 + 公钥A + 服务端相关信息）= 数字证书
2. 中间CA 向 根CA申请数字证书同理：根CA 计算 中间CA数字证书的哈希值，用自己的私钥加密，得到中间CA数字证书的数字签名
3. 根CA也用自己的私钥自签名，将自己的数字证书 安装到客户端的浏览器/操作系统中
   - 数字签名 :: 证明数字证书的有效性
#+begin_comment
为什么这么麻烦，不根CA直接颁发证书呢？
假设只有根CA，根CA失守了，整个信任链都会有问题；
有中间CA的情况，中间CA失守，问题不大
#+end_comment

[[attachment:_20250806_092614screenshot.png]]

** 图:证书链 :ATTACH:
:PROPERTIES:
:ID:       469be9ff-16f2-4ec5-8831-c0b1a886ad8f
:END:
[[attachment:_20250806_094414screenshot.png]]


* 为什么需要CA(证书颁发机构)？ [[https://www.bilibili.com/video/BV1mj421d7VE/?spm_id_from=333.788.comment.all.click&vd_source=4441bc96046659b39d059d583f36ff52][bilibili-技术蛋老师]]
#+begin_example
背景：你发布公钥A，先给到中间人，中间人不给我，中间人将自己的公钥B给我，我用公钥B加密后，中间人用它的私钥B解密出真实内容，又用公钥A加密后给你，你用私钥A解密发现正确，于是建立了：我-中间人-你 这样的连接

因此我们需要第三方解决公钥信任问题，也就是 证书颁发机构（CA）
你把公钥放到大家都信任的CA那里，CA根据公钥和其他信息生成 数字证书，你把数字证书给我，我发现是信任的CA，于是我取出公钥...
#+end_example
