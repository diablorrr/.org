:PROPERTIES:
:ID:       0b3fad26-6096-455d-a8af-79522c5113f3
:END:
#+title: HTTP/1.0、HTTP/1.1、HTTP/2.0、HTTP/3.0的区别
#+filetags: network

* HTTP/1.0、HTTP/1.1、HTTP/2.0、HTTP/3.0的区别
1. HTTP/1.0 是 *短连接* ：每次 请求-响应 需要 TCP三次握手和四次挥手，效率低下

2. HTTP/1.1 引入 *长连接、管道* -> 解决了 请求队头阻塞，没解决响应队头阻塞问题，提高了性能
   - 管道 :: =解决了 请求队头阻塞= ，具体来说：客户端发送请求后，无需等待服务器响应，可以连续的发送请求 -> 减少整体响应时间；但 =未解决 响应队头阻塞（按顺序响应）=

3. HTTP/2.0 基于 *HTTPS* -> 更安全
            引入 *头部压缩、二进制格式、多路复用、服务器主动推送* 机制 -> 大幅提高性能，解决 HTTP 队头阻塞问题，但没解决 [[id:c00b5a3a-d165-4ecf-ae74-37ea9427608f][TCP层面的队头阻塞问题]]
   - 头部压缩       :: 使用 HPack算法，在客户端和服务端同时维护一张 *头信息表* ，所有字段存入该表，并生成对应索引号，后续只发索引号
   - [[id:ac2d85e8-4653-431f-865a-141e0a636825][二进制格式]]     :: 请求头、请求体 都是 二进制格式，被称为 frame，这样计算机就不用将明文转成二进制，再进行解析了，而是可以直接解析
   - [[id:2693aa5d-a574-4dfe-a22b-655af47e2698][多路复用]]       :: 一个连接中多个“流”，每个请求-响应 对应 一个流，流之间不阻塞 -> 解决HTTP队头阻塞问题（不再需要按序收发）
   - 服务器主动推送 :: 在客户端没明确请求时，主动推送客户端可能需要的资源
     #+begin_example
     客户端请求 /index.html，服务器主动推送 /style.css、/logo.png 文件
     #+end_example

4. HTTP/3.0 使用基于 UDP 的 QUIC协议 -> 实现类似TCP的可靠传输，解决了TCP层面的队头阻塞

** 图:HTTP1、HTTPS、HTTP2、HTTP3 :ATTACH:
:PROPERTIES:
:ID:       29defea1-0ed5-409c-866c-2888fa05994b
:END:
[[attachment:_20250820_164535screenshot.png]]


** 图:HTTP2二进制格式 :ATTACH:
:PROPERTIES:
:ID:       ac2d85e8-4653-431f-865a-141e0a636825
:END:
[[attachment:_20250820_163411screenshot.png]]

** 图:HTTP2多路复用 :ATTACH:
:PROPERTIES:
:ID:       2693aa5d-a574-4dfe-a22b-655af47e2698
:END:
[[attachment:_20250820_163546screenshot.png]]

** 图:TCP层面的队头阻塞问题 :ATTACH:
:PROPERTIES:
:ID:       c00b5a3a-d165-4ecf-ae74-37ea9427608f
:END:
[[attachment:_20250820_163952screenshot.png]]
*TCP队头阻塞* ：TCP层必须保证收到的字节数据是完整且连续的，否则无法从内核缓冲区返回给应用层的HTTP应用
#+begin_example
假设每次内核缓冲区读满才交给应用层的HTTP应用，但是中间有个TCP报文丢失，必须等收到了这个TCP报文才能交给HTTP应用
#+end_example
