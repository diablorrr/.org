:PROPERTIES:
:ID:       db72392d-66d0-4995-90e4-27bbfa83e444
:END:
#+title: leetcode
#+filetags: other

* 1.两数之和(哈希表)
给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个整数，并返回它们的数组下标。
#+begin_example
示例 1：
输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。

示例 2：
输入：nums = [3,2,4], target = 6
输出：[1,2]

示例 3：
输入：nums = [3,3], target = 6
输出：[0,1]
#+end_example

# 使用 哈希表（key-value=值-索引）
循环 遍历数组
  判断 *target - 当前值* 是否存在 哈希表中
  存在则返回结果，否则记录 值与对应索引 到哈希表中


* 49.字母异位词分组(哈希表)
给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。
#+begin_example
示例 1:
输入: strs = ["eat", "tea", "tan", "ate", "nat", "bat"]
输出: [["bat"],["nat","tan"],["ate","eat","tea"]]

解释：
在 strs 中没有字符串可以通过重新排列来形成 "bat"。
字符串 "nat" 和 "tan" 是字母异位词，因为它们可以重新排列以形成彼此。
字符串 "ate" ，"eat" 和 "tea" 是字母异位词，因为它们可以重新排列以形成彼此。

示例 2:
输入: strs = [""]
输出: [[""]]

示例 3:
输入: strs = ["a"]
输出: [["a"]]
#+end_example

# 使用 哈希表（key-value=排序后的字符串-原始字符串）
循环 排序后的字符串 和 原始字符串 放入 哈希表
循环 将哈希表中的内容 放入结果数组


* 128.最长连续序列(哈希表)
给定一个未排序的整数数组 nums，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。
请你设计并实现时间复杂度为 O(n) 的算法解决此问题。
#+begin_example
示例 1：
输入：nums = [100,4,200,1,3,2]
输出：4
解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。

示例 2：
输入：nums = [0,3,7,2,5,8,4,6,0,1]
输出：9

示例 3：
输入：nums = [1,0,1,2]
输出：3
#+end_example

将所有元素放入哈希表（key=所有元素）
循环 哈希表
  找连续序列的开头元素
  找到后
  循环 找连续序列的结尾元素
  更新结果


* 283.移动零(双指针)
给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。
请注意 ，必须在不复制数组的情况下原地对数组进行操作。
#+begin_example
示例 1:
输入: nums = [0,1,0,3,12]
输出: [1,3,12,0,0]

示例 2:
输入: nums = [0]
输出: [0]
#+end_example

循环 移动右指针遍历数组
  判断 元素非0
    交换左右指针元素，移动左指针


* 11.盛最多水的容器(双指针)
给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。
找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。
返回容器可以储存的最大水量。
#+begin_example
示例 1：
输入：[1,8,6,2,5,4,8,3,7]
输出：49
解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。

示例 2：
输入：height = [1,1]
输出：1
#+end_example

循环 左指针 小于 右指针
  根据最短边计算当前面积
  用最大的面积更新结果值
  判断 左指针/右指针对应的短边
    短边移动


* 167.两数之和II - 输入有序数组(双指针)
给你一个下标从 1 开始的整数数组 numbers ，该数组已按 非递减顺序排列  ，请你从数组中找出满足相加之和等于目标数 target 的两个数。如果设这两个数分别是 numbers[index1] 和 numbers[index2] ，则 1 <= index1 < index2 <= numbers.length 。
以长度为 2 的整数数组 [index1, index2] 的形式返回这两个整数的下标 index1 和 index2。
你可以假设每个输入 只对应唯一的答案 ，而且你 不可以 重复使用相同的元素。
你所设计的解决方案必须只使用 *常量级的额外空间*
#+begin_example
示例 1：
输入：numbers = [2,7,11,15], target = 9
输出：[1,2]
解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。返回 [1, 2] 。

示例 2：
输入：numbers = [2,3,4], target = 6
输出：[1,3]
解释：2 与 4 之和等于目标数 6 。因此 index1 = 1, index2 = 3 。返回 [1, 3] 。

示例 3：
输入：numbers = [-1,0], target = -1
输出：[1,2]
解释：-1 与 0 之和等于目标数 -1 。因此 index1 = 1, index2 = 2 。返回 [1, 2] 。
#+end_example

循环 左指针 小于 右指针 时
  判断 左右指针相加
    目标值 返回
    大于目标值 移动右指针
    小于目标值 移动左指针


* 15.三数之和(双指针)
给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请你返回所有和为 0 且不重复的三元组。
注意：答案中不可以包含重复的三元组。
#+begin_example
示例 1：
输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
解释：
nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。
nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。
nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。
不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。
注意，输出的顺序和三元组的顺序并不重要。

示例 2：
输入：nums = [0,1,1]
输出：[]
解释：唯一可能的三元组和不为 0 。

示例 3：
输入：nums = [0,0,0]
输出：[[0,0,0]]
解释：唯一可能的三元组和为 0 。
#+end_example

排序数组
循环 遍历数组
  target=当前值的负数
  设置左右指针
  （167.两数之和II）做法


* 3.无重复字符的最长子串(哈希表、不定长滑动窗口)
给定一个字符串 s，请你找出其中不含有重复字符的 最长子串 的长度。
#+begin_example
示例 1:
输入: s = "abcabcbb"
输出: 3
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。

示例 2:
输入: s = "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。

示例 3:
输入: s = "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
#+end_example

# 使用 哈希表（key=字符）
循环 右指针遍历字符串
  循环 哈希表中查到右指针元素
    # 缩小窗口
    删除哈希表中的元素，移动左指针
  # 增大窗口
  哈希表中插入右指针元素
  用更长的长度更新结果


* 438.找到字符串中所有字母异位词(哈希表、定长滑动窗口)
给定两个字符串s和p，找到s中所有p的异位词的子串，返回这些子串的起始索引。不考虑答案输出的顺序
#+begin_example
示例 1:
输入: s = "cbaebabacd", p = "abc"
输出: [0,6]
解释:
起始索引等于 0 的子串是 "cba", 它是 "abc" 的异位词。
起始索引等于 6 的子串是 "bac", 它是 "abc" 的异位词。

示例 2:
输入: s = "abab", p = "ab"
输出: [0,1,2]
解释:
起始索引等于 0 的子串是 "ab", 它是 "ab" 的异位词。
起始索引等于 1 的子串是 "ba", 它是 "ab" 的异位词。
起始索引等于 2 的子串是 "ab", 它是 "ab" 的异位词。
#+end_example

# 使用 哈希表（array<int, 26> cnt_s）
# 使用 哈希表（array<int, 26> cnt_p）
循环 遍历字符串p
  字符加入哈希表
循环 右指针遍历字符串s
  # 增大窗口
  字符加入哈希表
  # 判断定长窗口是否存在，假设窗口大小为k
  计算左指针，若结果不存在，则 continue，直到窗口大小为k
  判断 p的哈希表和s的哈希表是否相等
    相等 存入结果
  # 减少窗口
  s的哈希表中去除左指针元素


* 560.和为K的子数组(前缀和)
给你一个整数数组 nums 和一个整数 k ，请你统计并返回 该数组中 *和为 k 的子数组* 的个数 。
子数组是数组中元素的连续非空序列。
#+begin_example
示例 1：
输入：nums = [1,1,1], k = 2
输出：2

示例 2：
输入：nums = [1,2,3], k = 3
输出：2
#+end_example

循环 遍历nums
  计算前缀和存入vector
