:PROPERTIES:
:ID:       db72392d-66d0-4995-90e4-27bbfa83e444
:END:
#+title: leetcode
#+filetags: other

* 前缀和
*推导*
数组为nums
前缀和数组为s，s[0]=0
则前缀和数组的长度为：nums.size()+1


*1.当前元素的前缀和 = 除了当前元素的前面所有元素之和*
s[i] = nums[i-1] + nums[i-2] + ... + nums[0]

下一个元素的前缀和 = 当前元素的前缀和 + 当前元素
s[i+1] = s[i] + nums[i]

变形得到
nums[i] = s[i+1] - s[i]  ->  任何子序列的和都可以表示为两个前缀和的差

*2.当前元素的前缀和 = 当前元素以及前面所有元素之和*
s[i] = nums[i] + nums[i-1] + ... + nums[0]

推导得
s[i] = s[i-1] + nums[i]

变形得到
nums[i] = s[i] - s[i-1]  ->  任何子序列的和都可以表示为两个前缀和的差



可以用 *数组、变量* 表示前缀和

*应用场景*
连续子数组和（滑动窗口不适合的原因：不满足单调性，比如包含进来的新元素是负数，则会移动窗口左边界）

* 前后缀分解
pre[0] = suf[n-1] = 1（表示空子数组的元素乘积，1乘任何数都是本身）

pre[i] = nums[0] * ... * nums[i-1]  （i前所有数的乘积）
suf[i] = nums[i+1] * ... * nums[n-1]（i后所有数的乘积）

推导得：
pre[i] = pre[i-1] * nums[i-1]
suf[i] = suf[i+1] * nums[i+1]

除自己以外数组的乘积：
answer[i] = pre[i] * suf[i]

* 定长滑动窗口
假设窗口大小为k
核心思想：入- 更新- 出
入：right元素进入，判断窗口是否为k（left = right -k + 1，因此left < 0代表left不存在，那么窗口大小就不为k了），没到k，继续入
更新：窗口大小为k，更新
出：left出去

* 不定长滑动窗口
入 [出] 更新
right入；若不符合条件了，left出；更新
- 题目说求子数组或子串，意味着数据 *不满足单调性* ，不使用双指针，只能使用滑动窗口；一般不定长滑动窗口是根据某种状态来移动左右窗口边界，比如求窗口内元素和为某个值，若数据中有负数，则不可使用，因为此时左边界会往左走，只能使用前缀和

* 快慢双指针
同向，fast 移动 2，slow 移动 1

*应用场景* ：找链表中点、判断链表是否有环

* 相向双指针
- 通过两个指针(索引)获取一定信息（eg：在两数之和中，这个信息就是两个指针的值与target的比较），根据信息结果，缩小处理数据范围 => 高效
- 一般情况下数据 *满足单调性(有序)* ，定义两个指针(索引)在两侧，相向移动
* 红蓝染色法（二分查找）
while循环条件表示 *处理数据的范围区间* ：闭区间、开区间、左开右闭、左闭右开
#+begin_example cpp
/* 闭区间 -> 要处理的数据范围：[left, right] */
left = 0, right = nums.size() - 1;
while(left <= right) // left == right 时，剩1数据 [left或right]，left或right需要处理

/* 左闭右开区间 -> 要处理数据的范围：[left, right) */
left = 0, right = nums.size();
while(left < right)  // left < right 时，剩2数据 [left, right)，left需要处理

/* 开区间 -> 要处理数据的范围：(left, right) */
left = -1, right = nums.size();
while(left + 1 < right)  // left + 1 < right 时，剩3数据 （left, xxx, right)，xxx需要处理
#+end_example

*循环不变量*
（闭区间情况） =left - 1= 始终为红色， =right + 1= 始终为蓝色，包括[[id:25a5a2b9-8187-4a0c-be39-14a25661e8c8][循环终止后的情况]]

*根据while中的if语句确定红蓝区意义*
# 红蓝区的意义可以是红色为<target的范围，蓝色为>target的范围；也可以是其他意义，eg：162.寻找峰值中红色代表有序部分，蓝色代表无序部分

** 图:闭区间红蓝染色法终止时 :ATTACH:
:PROPERTIES:
:ID:       25a5a2b9-8187-4a0c-be39-14a25661e8c8
:END:
[[attachment:_20250812_161917screenshot.png]]

* 桶排序
适合元素分布均匀的情况，最好时间复杂度O(n)（数据分布均匀），最坏O(n^2)（数据分布极度不均匀）
*使用场景* ：找第k高频元素、找前k个高频元素
* 位运算 [fn:1]
与（&）   ：对应位都为1，则为1
或（|）   ：对应位有一个为1，则为1
异或（^） ：对应位不同，则为1
取反（~） ：0 -> 1；1 -> 0
左移（<<）：各二进制左移，高位丢弃，低位补0
右移（>>）：各二进制右移，低位丢弃，高位补符号位

* 回溯
*两种解法* ：
1. 选哪个  （N 叉树）
2. 选或不选（二叉树）
构成 *搜索树* ，遍历搜索树，将需要的元素加入 path，返回

*三种类型* ：
1. 子集型回溯：选哪个/选或不选
2. 组合型回溯：选哪个
3. 排列型回溯：选哪个

*具体操作* ：定义问题规模为 dfs(i) ，在当前问题 未选集合s中选一个，再不断求解下一个子问题 dfs(i+1)
#+begin_example
当前问题 dfs(i)      ：将 >=i 的部分全排列，处理 i 的部分
下一个子问题 dfs(i+1)：将 >=(i+1) 部分全排列
#+end_example

*剪枝* ：通过条件判断，减少某些递归调用

* 反转链表
- 设置哨兵节点dummy统一操作；pre、cur、nxt三个指针(cur用于反转指向，nxt只用于定位！)
- 最终状态
  1. pre在反转区域的最后一个位置
  2. cur在反转区域的下一个位置
* 递归
# 循环和递归都是在调用同一份代码，通过不断解决小问题从而解决原问题，区别在于循环的每次循环就是提出小问题就解决，递归每次调用自身就是将原问题拆解为小问题(递)，返回时解决小问题(归)，因为递归解决的是嵌套 问题；在返回值方面，循环每次将值返回到当前问题，递归将值返回给上一个问题；再说一些两者类似的地方，递归的边界条件类似循环中的条件判断，不同之处在于循环每次提出小问题就判断一次，递归到最小问题时才进行判断，递归每次调用自身就类似循环每次进入下一次循环；通过循环来理解递归更容易
*递归之间的信息传递* ：自底向上、自顶向下
* 二叉树 递归
- 两种方法：
  1. 递归的时候传入节点                             => 通过归的值得到结果
  2. 递归的时候传入节点、其他变量；同时存在全局变量 => 不断更新全局变量，全局变量的值即为结果
* 二叉树 最大深度 相同 对称 平衡
# 二叉树的解法，函数式编程，假设知道某些基础算法，在那些算法基础上解题
- 对称 :: 使用 *相同的变体* 来判断
- 平衡 :: 使用 *最大深度* 来判断
* 二叉树 右视图
- 先右后左(右边遮蔽左边)，比较当前深度和当前整棵树最大深度(结果数组的长度)，若相等(意味着第一次到达这个深度)，则加入结果数组
* 二叉搜索树判别
- 核心思想：二叉搜索树，进入root->left缩小范围右边界为root值，进入root->right缩小范围左边界为root值；root的范围应该是无限小和无限大
- 中序遍历得到递增序列
* 二叉树层序遍历
- 使用队列：队列相当于是工作队列(里面有工作就取出完成，否则中止 => 以此判断终止条件)



* 动态规划
*两种解法*
1. 选或不选
2. 选哪个

*01背包*   ：不可重复选
*完全背包* ：可以重复选
选或不选

*思路*
1. 大问题拆分为小问题，得到一个方程，这就是 *状态转移方程*
   #+begin_example
   dfs[i] = dfs[i-1]
            dfs[i-2] + nums[i]
   #+end_example
2. 根据这个方程很容易想到用 *递归* ；有些节点重复计算，考虑放到一个"缓存"中，遇到直接返回"缓存"中的结果，这就是 *记忆化搜索*
3. 递归去掉"递"的过程，只保留"归"，即自底向上计算，这就是 *递推*


* 动态规划
- 将 记忆化搜索 翻译成 递推
  1. dfs      -> f数组
  2. 递归     -> 循环
  3. 递归边界 -> 数组初始值
- 自底向上(递推：只有递没有归) 计算 搜索树

* 历史信息
** 变量
获取历史信息（最大值，最小值）
** int数组
用于获取历史信息（特别适合存放char，因为char对应[[id:dfb83e03-e939-4a01-87b5-54aaa92fd424][ASCII]]中的数字，使得我们可以通过数学计算来获取关系）
** 哈希表
用于快速获取历史信息（是否存在、key-value附加信息）
** 单调栈
用于获取上一个值的历史信息（上一个最大/最小）
- 单调性：栈上面的数<栈下面的数(记录t[i]前会把所有<=t[i]的数去掉)
** 单调队列
用于获取一个范围内的历史信息（范围内最大/最小）
1. 右边入（同时维护单调性）
2. 左边出
3. 记录（根据队首）

* Footnotes

[fn:1]
#+begin_src cpp :results output :namespaces std :includes <iostream>
#include <iostream>
using namespace std;

// 辅助函数：打印二进制表示
void printBinary(int num, int bits = 8) {
    for (int i = bits - 1; i >= 0; i--) {
        cout << ((num >> i) & 1);
    }
    cout << endl;
}

int main() {
    int a = 6;  // 二进制：00000110
    int b = 10; // 二进制：00001010

    cout << "a = " << a << " -> ";
    printBinary(a);
    cout << "b = " << b << " -> ";
    printBinary(b);
    cout << endl;

    // 1. 与运算(&)：对应位都为1则为1，否则为0
    int andResult = a & b;
    cout << "a & b = " << andResult << " -> ";
    printBinary(andResult);
    // 用途：提取特定位，例如判断奇偶性(a & 1)

    // 2. 或运算(|)：对应位有一个为1则为1
    int orResult = a | b;
    cout << "a | b = " << orResult << " -> ";
    printBinary(orResult);
    // 用途：设置特定位为1

    // 3. 异或运算(^)：对应位不同则为1，相同则为0
    int xorResult = a ^ b;
    cout << "a ^ b = " << xorResult << " -> ";
    printBinary(xorResult);
    // 用途：交换两个数、翻转特定位

    // 4. 取反运算(~)：0变1，1变0
    int notResult = ~a;
    cout << "~a = " << notResult << " -> ";
    printBinary(notResult);  // 注意符号位变化
    // 用途：准备掩码

    // 5. 左移运算(<<)：各二进制位左移，高位丢弃，低位补0
    int leftShift = a << 2;  // 相当于乘以2的n次方
    cout << "a << 2 = " << leftShift << " -> ";
    printBinary(leftShift);

    // 6. 右移运算(>>)：各二进制位右移，低位丢弃，高位补符号位
    int rightShift = b >> 2;  // 相当于除以2的n次方（向下取整）
    cout << "b >> 2 = " << rightShift << " -> ";
    printBinary(rightShift);

    // 实际应用：使用位运算交换两个数（无需临时变量）
    int x = 3, y = 5;
    cout << "\n交换前: x = " << x << ", y = " << y << endl;
    x ^= y;
    y ^= x;
    x ^= y;
    cout << "交换后: x = " << x << ", y = " << y << endl;

    return 0;
}
#+end_src

#+RESULTS:
#+begin_example
a = 6 -> 00000110
b = 10 -> 00001010

a & b = 2 -> 00000010
a | b = 14 -> 00001110
a ^ b = 12 -> 00001100
~a = -7 -> 11111001
a << 2 = 24 -> 00011000
b >> 2 = 2 -> 00000010

交换前: x = 3, y = 5
交换后: x = 5, y = 3
#+end_example
