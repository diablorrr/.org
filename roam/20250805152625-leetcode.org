:PROPERTIES:
:ID:       db72392d-66d0-4995-90e4-27bbfa83e444
:END:
#+title: 算法
#+filetags: interview

* 模板
** 快速排序
#+begin_src cpp :results output :namespaces std :includes <iostream>
void quick_sort(int q[], int l, int r) {
  if (l > r) return;
  int i = l - 1, j = r + 1, x = q[l+r>>1];
  while (i < j) {
    do ++i; while (q[i] < x);
    do --j; while (q[j] > x);
  }
  quick_sort(q, l, j), quick_sort(q, j+1, r);
}
#+end_src
https://leetcode.cn/problems/xx4gT2/submissions/674729952/
https://www.nowcoder.com/practice/e016ad9b7f0b45048c58a9f27ba618bf?tpId=295&tqId=44581&sourceUrl=%2Fexam%2Foj%3FquestionJobId%3D10%26subTabName%3Donline_coding_page
** 归并排序
1. 找中间节点
2. 分治
3. 合并
#+begin_src cpp :results output :namespaces std :includes <iostream>
void merge_sort(int q[], int l, int r) {
   if (l >= r) return;
   int mid = l+r>>1;
   merge_sort(q, l, mid), merge_sort(q, mid+1, r);

   int k = 0, i = l, j = mid + 1;
   while (i <= mid && j <= r)
        if (q[i] <= q[j]) tmp[k++] = q[i++];
        else tmp[k++] = q[j++];

   while (i <= mid) tmp[k++] = q[i++];
   while (j <= r) tmp[k++] = q[j++];

   for (int i = l, j = 0; i <= r; ++i, ++j) q[i] =tmp[j];
}
#+end_src
https://www.acwing.com/problem/content/789/
** 链表中间节点
#+begin_src cpp :results output :namespaces std :includes <iostream>
ListNode* middleNode(ListNode* head) {
   ListNode *f = head, *s = head;
   while (f && f->next) {
    f = f->next->next;
    s = s->next;
   }
   return s;
}
#+end_src
** 链表反转
#+begin_src cpp :results output :namespaces std :includes <iostream>
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode* p = nullptr, c = head;
        while (c) {
            ListNode* n = c->next;
            c->next = p;
            p = c;
            c = n;
        }
        return p;
    }
};
#+end_src
** 链表两数相加
#+begin_src cpp :results output :namespaces std :includes <iostream>
ListNode* addTwo(ListNode* l1, ListNode* l2) {
    ListNode* p1 = l1, *p2 = l2, *dummy = new ListNode(-1), *cur = dummy;
    int carry = 0;
    while (p1 || p2 || carry) {
        if (p1) {
            carry += p1->val;
            p1 = p1->next;
        }
        if (p2) {
            carry += p2->val;
            p2 = p2->next;
        }
        cur->next = new ListNode(carry%10);
        cur = cur->next;
        carry /= 10;
    }
    return dummy->next;
}
#+end_src
** 合并有序链表
#+begin_src cpp :results output :namespaces std :includes <iostream>
ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
    ListNode* dummy, *cur = dummy;
    while (list1 && list2) {
        if (list1->val < list2->val) {
            cur->next = list1;
            list1 = list1->next;
        } else {
            cur->next = list2;
            list2 = list2->next;
        }
        cur = cur->next;
    }
    cur->next = list1 ? list1 : list2;
    return dummy.next;

#+end_src
** 二分查找
闭区间写法
#+begin_src cpp :results output :namespaces std :includes <iostream>
int left = 0, right = nums.size()-1;
while (left <= right) {
  int mid = left + right >> 1;
  if (/*满足某种性质*/) {
    //...
  } else {
    //...
  }
 }
#+end_src
** 二叉树最大深度
#+begin_src cpp :results output :namespaces std :includes <iostream>
int depthTree(TreeNode* root) {
  if (!root) return 0;
  return 1 + max(depthTree(root->left), depthTree(root->right));
}
#+end_src
** 字符串拆分
#+name: 版本1
#+begin_src cpp :results output :namespaces std :includes <iostream>
string s;
int n = s.size();
for (int i = 0; i < n; ++i) {
  int j = i;
  while (j < n && s[j] != ' ') ++j;
  // 拆分逻辑
  i = j;
}
#+end_src

#+name: 版本2
#+begin_src cpp :results output :namespaces std :includes <iostream>
vector<string> str_split(string s) {
  s += " ";
  string w;
  vector<string> ws;
  for (char c:s) {
      if  (c == ' ') {
          if (!w.empty()) {
              ws.push_back(w);
              w.clear();
          }
      } else {
          w += c;
      }
  }
}
#+end_src
https://leetcode.cn/problems/fan-zhuan-dan-ci-shun-xu-lcof/description/
** 合并区间
1. 将区间按左端点排序
2. 合并区间
#+begin_src cpp :results output :namespaces std :includes <iostream>
typedef PII = pair<int, int>
void merge(vector<PII> &segs)
{
    vector<PII> res;

    sort(segs.begin(), segs.end());

    int st = -2e9, ed = -2e9;
    for (auto seg : segs)
        if (ed < seg.first)
        {
            if (st != -2e9) res.push_back({st, ed});
            st = seg.first, ed = seg.second;
        }
        else ed = max(ed, seg.second);

    if (st != -2e9) res.push_back({st, ed});

    segs = res;
}
#+end_src
https://www.acwing.com/problem/content/805/
https://www.nowcoder.com/practice/69f4e5b7ad284a478777cb2a17fb5e6a?tpId=295&tqId=691&sourceUrl=%2Fexam%2Foj%3FquestionJobId%3D10%26subTabName%3Donline_coding_page
** 双指针
1. 暴力写法
2. 看有没有单调性，然后优化暴力写法
#+begin_src cpp :results output :namespaces std :includes <iostream>
// 一维序列、二维序列都能用；以下只是大致的代码，主要看思想
for (int i = 0, j = 0; i < n; ++i) {
  while (j < i && check(i, j)) j++;
  // 具体问题逻辑
 }
#+end_src
https://www.acwing.com/problem/content/801/
https://www.acwing.com/problem/content/description/802/
https://www.nowcoder.com/practice/b56799ebfd684fb394bd315e89324fb4?tpId=295&tqId=1008889&sourceUrl=%2Fexam%2Foj%3FquestionJobId%3D10%26subTabName%3Donline_coding_page





* 数组
1. 二分查找
2. 双指针法
3. 滑动窗口
4. 前缀和

** 二分查找（红蓝染色法）
while循环条件表示 *处理数据的范围区间* ：闭区间、开区间、左开右闭、左闭右开
#+begin_example cpp
/* 闭区间 -> 要处理的数据范围：[left, right] */
left = 0, right = nums.size() - 1;
while(left <= right) // left == right 时，剩1数据 [left或right]，left或right需要处理

/* 左闭右开区间 -> 要处理数据的范围：[left, right) */
left = 0, right = nums.size();
while(left < right)  // left < right 时，剩2数据 [left, right)，left需要处理

/* 开区间 -> 要处理数据的范围：(left, right) */
left = -1, right = nums.size();
while(left + 1 < right)  // left + 1 < right 时，剩3数据 （left, xxx, right)，xxx需要处理
#+end_example

*循环不变量*
（闭区间情况） =left - 1= 始终为红色， =right + 1= 始终为蓝色，包括[[id:25a5a2b9-8187-4a0c-be39-14a25661e8c8][循环终止后的情况]]

*根据while中的if语句确定红蓝区意义*
# 红蓝区的意义可以是红色为<target的范围，蓝色为>target的范围；也可以是其他意义，eg：162.寻找峰值中红色代表有序部分，蓝色代表无序部分

*** 图:闭区间红蓝染色法终止时 :ATTACH:
:PROPERTIES:
:ID:       25a5a2b9-8187-4a0c-be39-14a25661e8c8
:END:
[[attachment:_20250812_161917screenshot.png]]


** 快慢双指针
同向，fast 移动 2，slow 移动 1

*应用场景* ：找链表中点、判断链表是否有环

** 相向双指针
- 通过两个指针(索引)获取一定信息（eg：在两数之和中，这个信息就是两个指针的值与target的比较），根据信息结果，缩小处理数据范围 => 高效
- 一般情况下数据 *满足单调性(有序)* ，定义两个指针(索引)在两侧，相向移动

** 定长滑动窗口
假设窗口大小为k
核心思想：入- 更新- 出
入：right元素进入，判断窗口是否为k（left = right -k + 1，因此left < 0代表left不存在，那么窗口大小就不为k了），没到k，继续入
更新：窗口大小为k，更新
出：left出去

** 不定长滑动窗口
入 [出] 更新
right入；若不符合条件了，left出；更新
- 题目说求子数组或子串，意味着数据 *不满足单调性* ，不使用双指针，只能使用滑动窗口；一般不定长滑动窗口是根据某种状态来移动左右窗口边界，比如求窗口内元素和为某个值，若数据中有负数，则不可使用，因为此时左边界会往左走，只能使用前缀和


** 前缀和
*推导*
数组为nums
前缀和数组为s，s[0]=0
则前缀和数组的长度为：nums.size()+1


*1.当前元素的前缀和 = 除了当前元素的前面所有元素之和*
s[i] = nums[i-1] + nums[i-2] + ... + nums[0]

下一个元素的前缀和 = 当前元素的前缀和 + 当前元素
s[i+1] = s[i] + nums[i]

变形得到
nums[i] = s[i+1] - s[i]  ->  任何子序列的和都可以表示为两个前缀和的差

*2.当前元素的前缀和 = 当前元素以及前面所有元素之和*
s[i] = nums[i] + nums[i-1] + ... + nums[0]

推导得
s[i] = s[i-1] + nums[i]

变形得到
nums[i] = s[i] - s[i-1]  ->  任何子序列的和都可以表示为两个前缀和的差



可以用 *数组、变量* 表示前缀和

*应用场景*
连续子数组和（滑动窗口不适合的原因：不满足单调性，比如包含进来的新元素是负数，则会移动窗口左边界）

** 前后缀分解
pre[0] = suf[n-1] = 1（表示空子数组的元素乘积，1乘任何数都是本身）

pre[i] = nums[0] * ... * nums[i-1]  （i前所有数的乘积）
suf[i] = nums[i+1] * ... * nums[n-1]（i后所有数的乘积）

推导得：
pre[i] = pre[i-1] * nums[i-1]
suf[i] = suf[i+1] * nums[i+1]

除自己以外数组的乘积：
answer[i] = pre[i] * suf[i]


* 链表
1. 虚拟头节点
2. 增删改查
3. 反转链表
4. 删除倒数第N个节点
5. 链表相交
6. 环形链表



* 哈希表
用于快速判断一个元素是否出现在集合中
1. 数组
2. set（集合）
3. map（映射）
#+begin_comment 3者对比
- 数组：可以用来实现简易 set、map；效率高，但大小受限
- set ：大小不受限，用于判断元素是否存在；占用空间大于数组，速度慢于数组（将值映射到key需要做hash计算）
- map ：大小不受限，需要 key-value 的场景；占用空间大于数组，速度慢于数组（将值映射到key需要做hash计算）
#+end_comment


* 桶排序
适合元素分布均匀的情况，最好时间复杂度O(n)（数据分布均匀），最坏O(n^2)（数据分布极度不均匀）
*使用场景* ：找第k高频元素、找前k个高频元素
* 位运算 [fn:1]
与（&）   ：对应位都为1，则为1
或（|）   ：对应位有一个为1，则为1
异或（^） ：对应位不同，则为1
取反（~） ：0 -> 1；1 -> 0
左移（<<）：各二进制左移，高位丢弃，低位补0
右移（>>）：各二进制右移，低位丢弃，高位补符号位

* 回溯
*两种解法* ：
1. 选哪个  （N 叉树）
2. 选或不选（二叉树）
构成 *搜索树* ，遍历搜索树，将需要的元素加入 path，返回

*三种类型* ：
1. 子集型回溯：选哪个/选或不选
2. 组合型回溯：选哪个
3. 排列型回溯：选哪个

*具体操作* ：定义问题规模为 dfs(i) ，在当前问题 未选集合s中选一个，再不断求解下一个子问题 dfs(i+1)
#+begin_example
当前问题 dfs(i)      ：将 >=i 的部分全排列，处理 i 的部分
下一个子问题 dfs(i+1)：将 >=(i+1) 部分全排列
#+end_example

*剪枝* ：通过条件判断，减少某些递归调用

* 反转链表
- 设置哨兵节点dummy统一操作；pre、cur、nxt三个指针(cur用于反转指向，nxt只用于定位！)
- 最终状态
  1. pre在反转区域的最后一个位置
  2. cur在反转区域的下一个位置
* 递归
# 循环和递归都是在调用同一份代码，通过不断解决小问题从而解决原问题，区别在于循环的每次循环就是提出小问题就解决，递归每次调用自身就是将原问题拆解为小问题(递)，返回时解决小问题(归)，因为递归解决的是嵌套 问题；在返回值方面，循环每次将值返回到当前问题，递归将值返回给上一个问题；再说一些两者类似的地方，递归的边界条件类似循环中的条件判断，不同之处在于循环每次提出小问题就判断一次，递归到最小问题时才进行判断，递归每次调用自身就类似循环每次进入下一次循环；通过循环来理解递归更容易
*递归之间的信息传递* ：自底向上、自顶向下
* 二叉树 递归
- 两种方法：
  1. 递归的时候传入节点                             => 通过归的值得到结果
  2. 递归的时候传入节点、其他变量；同时存在全局变量 => 不断更新全局变量，全局变量的值即为结果
* 二叉树 最大深度 相同 对称 平衡
# 二叉树的解法，函数式编程，假设知道某些基础算法，在那些算法基础上解题
- 对称 :: 使用 *相同的变体* 来判断
- 平衡 :: 使用 *最大深度* 来判断
* 二叉树 右视图
- 先右后左(右边遮蔽左边)，比较当前深度和当前整棵树最大深度(结果数组的长度)，若相等(意味着第一次到达这个深度)，则加入结果数组
* 二叉搜索树判别
- 核心思想：二叉搜索树，进入root->left缩小范围右边界为root值，进入root->right缩小范围左边界为root值；root的范围应该是无限小和无限大
- 中序遍历得到递增序列
* 二叉树层序遍历
- 使用队列：队列相当于是工作队列(里面有工作就取出完成，否则中止 => 以此判断终止条件)



* 动态规划
*两种解法*
1. 选或不选
2. 选哪个

*01背包*   ：不可重复选
*完全背包* ：可以重复选
选或不选

*思路*
1. 大问题拆分为小问题，得到一个方程，这就是 *状态转移方程*
   #+begin_example
   dfs[i] = dfs[i-1]
            dfs[i-2] + nums[i]
   #+end_example
2. 根据这个方程很容易想到用 *递归* ；有些节点重复计算，考虑放到一个"缓存"中，遇到直接返回"缓存"中的结果，这就是 *记忆化搜索*
3. 递归去掉"递"的过程，只保留"归"，即自底向上计算，这就是 *递推*


* 动态规划
- 将 记忆化搜索 翻译成 递推
  1. dfs      -> f数组
  2. 递归     -> 循环
  3. 递归边界 -> 数组初始值
- 自底向上(递推：只有递没有归) 计算 搜索树

* 历史信息
** 变量
获取历史信息（最大值，最小值）
** int数组
用于获取历史信息（特别适合存放char，因为char对应[[id:dfb83e03-e939-4a01-87b5-54aaa92fd424][ASCII]]中的数字，使得我们可以通过数学计算来获取关系）
** 哈希表
用于快速获取历史信息（是否存在、key-value附加信息）
** 单调栈
用于获取上一个值的历史信息（上一个最大/最小）
- 单调性：栈上面的数<栈下面的数(记录t[i]前会把所有<=t[i]的数去掉)
** 单调队列
用于获取一个范围内的历史信息（范围内最大/最小）
1. 右边入（同时维护单调性）
2. 左边出
3. 记录（根据队首）

* Footnotes

[fn:1]
#+begin_src cpp :results output :namespaces std :includes <iostream>
#include <iostream>
using namespace std;

// 辅助函数：打印二进制表示
void printBinary(int num, int bits = 8) {
    for (int i = bits - 1; i >= 0; i--) {
        cout << ((num >> i) & 1);
    }
    cout << endl;
}

int main() {
    int a = 6;  // 二进制：00000110
    int b = 10; // 二进制：00001010

    cout << "a = " << a << " -> ";
    printBinary(a);
    cout << "b = " << b << " -> ";
    printBinary(b);
    cout << endl;

    // 1. 与运算(&)：对应位都为1则为1，否则为0
    int andResult = a & b;
    cout << "a & b = " << andResult << " -> ";
    printBinary(andResult);
    // 用途：提取特定位，例如判断奇偶性(a & 1)

    // 2. 或运算(|)：对应位有一个为1则为1
    int orResult = a | b;
    cout << "a | b = " << orResult << " -> ";
    printBinary(orResult);
    // 用途：设置特定位为1

    // 3. 异或运算(^)：对应位不同则为1，相同则为0
    int xorResult = a ^ b;
    cout << "a ^ b = " << xorResult << " -> ";
    printBinary(xorResult);
    // 用途：交换两个数、翻转特定位

    // 4. 取反运算(~)：0变1，1变0
    int notResult = ~a;
    cout << "~a = " << notResult << " -> ";
    printBinary(notResult);  // 注意符号位变化
    // 用途：准备掩码

    // 5. 左移运算(<<)：各二进制位左移，高位丢弃，低位补0
    int leftShift = a << 2;  // 相当于乘以2的n次方
    cout << "a << 2 = " << leftShift << " -> ";
    printBinary(leftShift);

    // 6. 右移运算(>>)：各二进制位右移，低位丢弃，高位补符号位
    int rightShift = b >> 2;  // 相当于除以2的n次方（向下取整）
    cout << "b >> 2 = " << rightShift << " -> ";
    printBinary(rightShift);

    // 实际应用：使用位运算交换两个数（无需临时变量）
    int x = 3, y = 5;
    cout << "\n交换前: x = " << x << ", y = " << y << endl;
    x ^= y;
    y ^= x;
    x ^= y;
    cout << "交换后: x = " << x << ", y = " << y << endl;

    return 0;
}
#+end_src

#+RESULTS:
#+begin_example
a = 6 -> 00000110
b = 10 -> 00001010

a & b = 2 -> 00000010
a | b = 14 -> 00001110
a ^ b = 12 -> 00001100
~a = -7 -> 11111001
a << 2 = 24 -> 00011000
b >> 2 = 2 -> 00000010

交换前: x = 3, y = 5
交换后: x = 5, y = 3
#+end_example
