:PROPERTIES:
:ID:       f405fdf1-8944-4b8a-b275-afeb753424f1
:END:
#+title: WebSocket
#+filetags: network

* WebSocket [[https://www.xiaolincoding.com/network/2_http/http_websocket.html#websocket%E7%9A%84%E6%B6%88%E6%81%AF%E6%A0%BC%E5%BC%8F][小林coding]]
*全双工* 应用层协议（[[id:6cd6d820-4519-4090-8b15-4b38060fe563][HTTP]] 是半双工），实现客户端和服务器双向实时通信，适用高频信息交互场景（eg：网页游戏、网页聊天室）
- 半双工 :: 同一时间，只能一方发送数据
- 全双工 :: 同一时间，双方都能发送数据
#+begin_comment
为什么 TCP 是全双工的，不直接使用，还要重新实现一个 WebSocket？
使用全双工的协议需要解决 *TCP的粘包问题* ，WebSocket的报文格式就是 *消息头+消息体*
#+end_comment

** 建立 WebSocket 通信流程 :ATTACH:
:PROPERTIES:
:ID:       ad98e21f-5420-4e5f-b8ed-e3c684a8c371
:END:
[[attachment:_20250806_112341screenshot.png]]
1. [[id:ceed6c1f-7585-4884-874d-eb2dbf4145ae][TCP三次握手]]
2. 浏览器 先统一使用 HTTP
   - 普通HTTP请求        :: 后续继续HTTP通信
   - 想建立WebSocket连接 :: HTTP请求头中有以下字段
     #+begin_example css
     Connection: Upgrade                                /* 浏览器希望升级协议 */
     Upgrade: WebSocket                                 /* 希望升级为 WebSocket */
     Sec-WebSocket-Key: T2a6wZlAwhgQNqruZ2YUyg==\r\n    /* 随机生成的base64码 */
     #+end_example
3. 服务器返回 状态码为101的报文（含有 用公开算法将客户端base64码生成的字符串）
   #+begin_example css
   HTTP/1.1 101 Switching Protocols\r\n                   /* 101：转换协议的状态码 */
   Sec-WebSocket-Accept: iBJKv/ALIW2DobfoA4dmr3JHBCY=\r\n /* 公开算法 将 客户端的Sec-WebSocket-Key生成的另一个字符串 */
   Upgrade: WebSocket\r\n
   Connection: Upgrade\r\n
   #+end_example
4. 浏览器用 公开算法 将base64码转换为字符串，与服务器返回的 字符串比对一致则通过，开始通信
