:PROPERTIES:
:ID:       60cbe68b-543d-46b5-a5b2-89452e8ec901
:END:
#+title: cpp实现单例模式、工厂模式
#+filetags: cpp

* 单例模式
确保一个类只有一个实例，提供全局访问点，保证所有访问单例的客户端，获取到单例的信息都是共享的

* 工厂模式
*核心作用* ：将对象的创建和使用分离，降低系统耦合度，提高代码扩展性

*简单工厂模式* [fn:1]：一个工厂根据传入参数创建产品，需要修改工厂类来添加新产品
具体来说：产品有一个继承体系，工厂类中有一个创建产品的static方法，它会根据参数的不同（通常是枚举），通过switch语句动态创建具体产品，当我们要新增产品时需要修改工厂类方法，不符合开闭原则
适合 产品少且无需扩展 的情况
- 开闭原则 :: 对修改关闭，对扩展开放

*工厂方法模式* [fn:2]：定义一个用于创建对象的接口，让派生类决定实例化哪个产品，一个工厂生产一种产品，通过新增工厂的方式添加新产品
具体来说：产品有一个继承体系，工厂也有一个继承体系，每个具体工厂生产一个具体产品，当我们要新增产品时只需要新增具体工厂，符合开闭原则，使用工厂时，只需创建抽象工厂指针，想创建什么产品就指向对应的具体工厂
适合 产品需要扩展 的情况

*抽象工厂模式* [fn:3]：适合 需要创建产品族 的情况

* Footnotes

[fn:1]
#+name: 简单工厂模式
#+begin_src cpp :results output :namespaces std :includes <iostream>
#include <iostream>
#include <memory>

// 支付接口
class Payment {
public:
    virtual ~Payment() = default;
    virtual void pay(double amount) = 0;
};

// 支付宝支付
class Alipay : public Payment {
public:
    void pay(double amount) override {
        std::cout << "使用支付宝支付: " << amount << "元" << std::endl;
    }
};

// 微信支付
class WechatPay : public Payment {
public:
    void pay(double amount) override {
        std::cout << "使用微信支付: " << amount << "元" << std::endl;
    }
};

// 银联支付
class UnionPay : public Payment {
public:
    void pay(double amount) override {
        std::cout << "使用银联支付: " << amount << "元" << std::endl;
    }
};

// 简单支付工厂
class PaymentFactory {
public:
    enum PaymentType { ALIPAY, WECHAT, UNION };

    static std::unique_ptr<Payment> createPayment(PaymentType type) {
        switch (type) {
            case ALIPAY: return std::make_unique<Alipay>();
            case WECHAT: return std::make_unique<WechatPay>();
            case UNION: return std::make_unique<UnionPay>();
            default: throw std::invalid_argument("不支持的支付类型");
        }
    }
};

int main() {
    // 客户端使用
    auto alipay = PaymentFactory::createPayment(PaymentFactory::ALIPAY);
    alipay->pay(100.50);

    auto wechat = PaymentFactory::createPayment(PaymentFactory::WECHAT);
    wechat->pay(200.00);

    return 0;
}
#+end_src

#+RESULTS:
: 使用支付宝支付: 100.5元
: 使用微信支付: 200元

[fn:2]
#+name: 工厂方法模式
#+begin_src cpp :results output :namespaces std :includes <iostream>
#include <iostream>
#include <memory>
#include <string>

// 日志记录器接口
class Logger {
public:
    virtual ~Logger() = default;
    virtual void log(const std::string& message) = 0;
};

// 文件日志
class FileLogger : public Logger {
public:
    void log(const std::string& message) override {
        std::cout << "写入文件日志: " << message << std::endl;
    }
};

// 控制台日志
class ConsoleLogger : public Logger {
public:
    void log(const std::string& message) override {
        std::cout << "控制台输出: " << message << std::endl;
    }
};

// 数据库日志
class DatabaseLogger : public Logger {
public:
    void log(const std::string& message) override {
        std::cout << "存入数据库: " << message << std::endl;
    }
};

////// 日志工厂接口
class LoggerFactory {
public:
    virtual ~LoggerFactory() = default;
    virtual std::unique_ptr<Logger> createLogger() = 0;
};

// 文件日志工厂
class FileLoggerFactory : public LoggerFactory {
public:
    std::unique_ptr<Logger> createLogger() override {
        return std::make_unique<FileLogger>();
    }
};

// 控制台日志工厂
class ConsoleLoggerFactory : public LoggerFactory {
public:
    std::unique_ptr<Logger> createLogger() override {
        return std::make_unique<ConsoleLogger>();
    }
};

// 数据库日志工厂
class DatabaseLoggerFactory : public LoggerFactory {
public:
    std::unique_ptr<Logger> createLogger() override {
        return std::make_unique<DatabaseLogger>();
    }
};

int main() {
    // 根据配置决定使用哪种日志
    std::unique_ptr<LoggerFactory> factory;

    // 这里可以根据配置文件或环境变量选择工厂
    factory = std::make_unique<FileLoggerFactory>();

    auto logger = factory->createLogger();
    logger->log("系统启动完成");

    return 0;
}
#+end_src

#+RESULTS: 工厂方法模式
: 写入文件日志: 系统启动完成

[fn:3]
#+name: 抽象工厂模式
#+begin_src cpp :results output :namespaces std :includes <iostream>
#include <iostream>
#include <memory>
#include <string>

// 抽象按钮
class Button {
public:
    virtual ~Button() = default;
    virtual void render() = 0;
    virtual void onClick() = 0;
};

// 抽象文本框
class TextBox {
public:
    virtual ~TextBox() = default;
    virtual void render() = 0;
    virtual void setText(const std::string& text) = 0;
};

// Windows风格按钮
class WindowsButton : public Button {
public:
    void render() override {
        std::cout << "渲染一个Windows风格的按钮" << std::endl;
    }

    void onClick() override {
        std::cout << "Windows按钮被点击" << std::endl;
    }
};

// Windows风格文本框
class WindowsTextBox : public TextBox {
public:
    void render() override {
        std::cout << "渲染一个Windows风格的文本框" << std::endl;
    }

    void setText(const std::string& text) override {
        std::cout << "Windows文本框设置文本: " << text << std::endl;
    }
};

// Mac风格按钮
class MacButton : public Button {
public:
    void render() override {
        std::cout << "渲染一个Mac风格的按钮" << std::endl;
    }

    void onClick() override {
        std::cout << "Mac按钮被点击" << std::endl;
    }
};

// Mac风格文本框
class MacTextBox : public TextBox {
public:
    void render() override {
        std::cout << "渲染一个Mac风格的文本框" << std::endl;
    }

    void setText(const std::string& text) override {
        std::cout << "Mac文本框设置文本: " << text << std::endl;
    }
};

// 抽象UI工厂
class UIFactory {
public:
    virtual ~UIFactory() = default;
    virtual std::unique_ptr<Button> createButton() = 0;
    virtual std::unique_ptr<TextBox> createTextBox() = 0;
};

// Windows UI工厂
class WindowsUIFactory : public UIFactory {
public:
    std::unique_ptr<Button> createButton() override {
        return std::make_unique<WindowsButton>();
    }

    std::unique_ptr<TextBox> createTextBox() override {
        return std::make_unique<WindowsTextBox>();
    }
};

// Mac UI工厂
class MacUIFactory : public UIFactory {
public:
    std::unique_ptr<Button> createButton() override {
        return std::make_unique<MacButton>();
    }

    std::unique_ptr<TextBox> createTextBox() override {
        return std::make_unique<MacTextBox>();
    }
};

// 客户端代码
class Application {
private:
    std::unique_ptr<UIFactory> factory_;

public:
    Application(std::unique_ptr<UIFactory> factory) : factory_(std::move(factory)) {}

    void createUI() {
        auto button = factory_->createButton();
        auto textbox = factory_->createTextBox();

        button->render();
        button->onClick();

        textbox->render();
        textbox->setText("Hello World");
    }
};

int main() {
    // 根据当前操作系统选择工厂
    #ifdef _WIN32
        auto factory = std::make_unique<WindowsUIFactory>();
    #else
        auto factory = std::make_unique<MacUIFactory>();
    #endif

    Application app(std::move(factory));
    app.createUI();

    return 0;
}
#+end_src

#+RESULTS: 抽象工厂模式
: 渲染一个Mac风格的按钮
: Mac按钮被点击
: 渲染一个Mac风格的文本框
: Mac文本框设置文本: Hello World
