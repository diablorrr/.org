:PROPERTIES:
:ID:       60cbe68b-543d-46b5-a5b2-89452e8ec901
:END:
#+title: cpp实现单例模式、工厂模式
#+filetags: cpp

* 单例模式
1. 创建一个唯一的实例，提供全局访问点
2. 保证所有访问单例的客户端，获取到单例的信息都是共享的
代码：[fn:4] [fn:5]

* 工厂模式
*核心作用* ：
1. 将对象的创建和使用分离，好处如下
   - 降低系统耦合度：添加新类型只需修改工厂类
   - 易于维护      ：创建逻辑改变不会影响客户端代码

*简单工厂模式* [fn:1]：一个工厂根据传入参数创建产品，需要修改工厂类来添加新产品
具体来说：产品有一个继承体系，工厂类中有一个创建产品的static方法，它会根据参数的不同（通常是枚举），通过switch语句动态创建具体产品，当我们要新增产品时需要修改工厂类方法，不符合开闭原则
适合 产品少且无需扩展 的情况
- 开闭原则 :: 对修改关闭，对扩展开放
代码：[fn:6]

*工厂方法模式* [fn:2]：定义一个用于创建对象的接口，让派生类决定实例化哪个产品，一个工厂生产一种产品，通过新增工厂的方式添加新产品
具体来说：产品有一个继承体系，工厂也有一个继承体系，每个具体工厂生产一个具体产品，当我们要新增产品时只需要新增具体工厂，符合开闭原则，使用工厂时，只需创建抽象工厂指针，想创建什么产品就指向对应的具体工厂
适合 产品需要扩展 的情况

*抽象工厂模式* [fn:3]：适合 需要创建产品族 的情况

* Footnotes
[fn:6]
#+begin_src cpp :results output :namespaces std :includes <iostream>
/* 简单工厂 */
#include <iostream>
#include <string>
#include <memory>
using namespace std;

class Shape {
public:
    virtual ~Shape() = default; // 确保基类指针删除派生类对象时，能正确调用派生类的析构函数
    virtual void draw() const = 0;
    virtual double area() const = 0;
};

class Circle : public Shape {
public:
    Circle(double r = 3.0): radius(r) {};
    void draw() const override {
        cout << "Drawing Circle with radius " << radius << endl;
    }

    double area() const override {
        return 3.14*radius*radius;
    }

private:
    double radius;
};

class Rectangle : public Shape {
public:
    Rectangle(double l = 3.0, double w = 4.0): len(l), wid(w) {};
    void draw() const override {
        cout << "Drawing Rectangle " << len << "x" << wid << endl;
    }

    double area() const override {
        return len*wid;
    }
private:
    double len;
    double wid;
};

class Triangle : public Shape {
public:
    Triangle(double l = 3.0, double h = 4.0): len(l), height(h) {};
    void draw() const override {
        cout << "Drawing Triangle " << len << "x" << height << endl;
    }

    double area() const override {
       return len*height/2;
    }
private:
    double len;
    double height;
};

class ShapeFactory {
public:
    enum ShapeType {CIRCLE, RECTANGLE, TRIANGLE}; // 无作用域枚举，直接ShapeFactory::CIRCLE就能访问
                                                  // 作用域枚举 enum class ShapeType，通过ShapeFactory::ShapeType::CIRCLE访问
    static unique_ptr<Shape> createShape(ShapeType type) {
        switch(type) {
            case CIRCLE: return make_unique<Circle>();
            case RECTANGLE: return unique_ptr<Shape>(new Rectangle);
            case TRIANGLE: return make_unique<Triangle>();
            default: return nullptr;
        }
    }
};

int main() {
    unique_ptr<Shape> circle = ShapeFactory::createShape(ShapeFactory::CIRCLE);
    circle->draw();
    cout << circle->area() << endl;

    unique_ptr<Shape> rec = ShapeFactory::createShape(ShapeFactory::RECTANGLE);
    rec->draw();
    cout << rec->area() << endl;
}
#+end_src

#+RESULTS:
: Drawing Circle with radius 3
: 28.26
: Drawing Rectangle 3x4
: 12


[fn:5]
#+begin_src cpp :results output :namespaces std :includes <iostream>
/* 线程安全的配置管理类 */
#include <iostream>
#include <string>
#include <mutex>
#include <thread>
#include <unordered_map>
using namespace std;

class ConfigManager {
public:
    static ConfigManager& getInstance() {
        static ConfigManager instance;
        return instance;
    }

    string getConfig(const string& key) const{
        lock_guard<mutex> lock(mtx); // getConfig是const的，不允许修改；但对mutex加锁会修改mutex内部状态，因此成员变量为 mutable mutex mtx;
        // return configs[key]; -> getConfig是const的，不允许修改；configs[key]会在key不存在时插入新元素，这会修改map
        auto it = configs.find(key);
        if (it != configs.end()) {
            return it->second;
        }
        return "";
    }

    void setConfig(const string& key, const string& value) {
        lock_guard<mutex> lock(mtx);
        configs[key] = value;
    }

    void displayAll() {
        lock_guard<mutex> lock(mtx);
        for (auto& config:configs) {
            cout << config.first << " " << config.second << endl;
        }
    }
private:
    ConfigManager() {
        configs["host"] = "localhost";
        configs["port"] = "8080";
        configs["timeout"] = "30";
    }
    ConfigManager(const ConfigManager&) = delete;
    ConfigManager& operator=(const ConfigManager&) = delete;
    ConfigManager(ConfigManager&&) = delete;
    ConfigManager& operator=(ConfigManager&&) = delete;

    unordered_map<string, string> configs;
    mutable mutex mtx;
    static ConfigManager instance;
};

ConfigManager ConfigManager::instance;

int main() {
    thread t1([](){
        auto& config = ConfigManager::getInstance();
        for (int i = 0; i < 5; ++i) {
            config.setConfig("key" + to_string(i), "value" + to_string(i));
        }
    });

    thread t2([](){
        auto& config = ConfigManager::getInstance();
        for (int i = 0; i < 5; ++i) {
            config.setConfig("key" + to_string(i+10), "value" + to_string(i));
        }
    });

    thread t3([](){
        auto& config = ConfigManager::getInstance();
        this_thread::sleep_for(chrono::milliseconds(10));
        config.displayAll();
    });

    t1.join();
    t2.join();
    t3.join();

    cout << "\nHost: " << ConfigManager::getInstance().getConfig("host") << endl;
}
#+end_src

#+RESULTS:
#+begin_example
key4 value4
key14 value4
key12 value2
key3 value3
key10 value0
key2 value2
key13 value3
key1 value1
key11 value1
key0 value0
timeout 30
port 8080
host localhost

Host: localhost
#+end_example

[fn:4]
#+name: 单例模式
#+begin_src cpp :results output :namespaces std :includes <iostream> <thread>
class Singleton{
public:
    static Singleton& getInstance() {
        static Singleton instance;
        return instance;
    }

    ~Singleton() = default;

    void print() const {
        cout << this << endl;
    }
private:
    Singleton() = default;
    Singleton(const Singleton&) = delete;
    Singleton& operator=(const Singleton&) = delete;
};

int main() {
    thread t1([](){
        Singleton::getInstance().print();
    });

    thread t2([](){
        Singleton::getInstance().print();
    });

    t1.join();
    t2.join();
}
#+end_src

#+RESULTS: 单例模式
: 0x555d7eba7191
: 0x555d7eba7191

[fn:1]
#+name: 简单工厂模式
#+begin_src cpp :results output :namespaces std :includes <iostream>
#include <iostream>
#include <memory>

// 支付接口
class Payment {
public:
    virtual ~Payment() = default;
    virtual void pay(double amount) = 0;
};

// 支付宝支付
class Alipay : public Payment {
public:
    void pay(double amount) override {
        std::cout << "使用支付宝支付: " << amount << "元" << std::endl;
    }
};

// 微信支付
class WechatPay : public Payment {
public:
    void pay(double amount) override {
        std::cout << "使用微信支付: " << amount << "元" << std::endl;
    }
};

// 银联支付
class UnionPay : public Payment {
public:
    void pay(double amount) override {
        std::cout << "使用银联支付: " << amount << "元" << std::endl;
    }
};

// 简单支付工厂
class PaymentFactory {
public:
    enum PaymentType { ALIPAY, WECHAT, UNION };

    static std::unique_ptr<Payment> createPayment(PaymentType type) {
        switch (type) {
            case ALIPAY: return std::make_unique<Alipay>();
            case WECHAT: return std::make_unique<WechatPay>();
            case UNION: return std::make_unique<UnionPay>();
            default: throw std::invalid_argument("不支持的支付类型");
        }
    }
};

int main() {
    // 客户端使用
    auto alipay = PaymentFactory::createPayment(PaymentFactory::ALIPAY);
    alipay->pay(100.50);

    auto wechat = PaymentFactory::createPayment(PaymentFactory::WECHAT);
    wechat->pay(200.00);

    return 0;
}
#+end_src

#+RESULTS:
: 使用支付宝支付: 100.5元
: 使用微信支付: 200元

[fn:2]
#+name: 工厂方法模式
#+begin_src cpp :results output :namespaces std :includes <iostream>
#include <iostream>
#include <memory>
#include <string>

// 日志记录器接口
class Logger {
public:
    virtual ~Logger() = default;
    virtual void log(const std::string& message) = 0;
};

// 文件日志
class FileLogger : public Logger {
public:
    void log(const std::string& message) override {
        std::cout << "写入文件日志: " << message << std::endl;
    }
};

// 控制台日志
class ConsoleLogger : public Logger {
public:
    void log(const std::string& message) override {
        std::cout << "控制台输出: " << message << std::endl;
    }
};

// 数据库日志
class DatabaseLogger : public Logger {
public:
    void log(const std::string& message) override {
        std::cout << "存入数据库: " << message << std::endl;
    }
};

////// 日志工厂接口
class LoggerFactory {
public:
    virtual ~LoggerFactory() = default;
    virtual std::unique_ptr<Logger> createLogger() = 0;
};

// 文件日志工厂
class FileLoggerFactory : public LoggerFactory {
public:
    std::unique_ptr<Logger> createLogger() override {
        return std::make_unique<FileLogger>();
    }
};

// 控制台日志工厂
class ConsoleLoggerFactory : public LoggerFactory {
public:
    std::unique_ptr<Logger> createLogger() override {
        return std::make_unique<ConsoleLogger>();
    }
};

// 数据库日志工厂
class DatabaseLoggerFactory : public LoggerFactory {
public:
    std::unique_ptr<Logger> createLogger() override {
        return std::make_unique<DatabaseLogger>();
    }
};

int main() {
    // 根据配置决定使用哪种日志
    std::unique_ptr<LoggerFactory> factory;

    // 这里可以根据配置文件或环境变量选择工厂
    factory = std::make_unique<FileLoggerFactory>();

    auto logger = factory->createLogger();
    logger->log("系统启动完成");

    return 0;
}
#+end_src

#+RESULTS: 工厂方法模式
: 写入文件日志: 系统启动完成

[fn:3]
#+name: 抽象工厂模式
#+begin_src cpp :results output :namespaces std :includes <iostream>
#include <iostream>
#include <memory>
#include <string>

// 抽象按钮
class Button {
public:
    virtual ~Button() = default;
    virtual void render() = 0;
    virtual void onClick() = 0;
};

// 抽象文本框
class TextBox {
public:
    virtual ~TextBox() = default;
    virtual void render() = 0;
    virtual void setText(const std::string& text) = 0;
};

// Windows风格按钮
class WindowsButton : public Button {
public:
    void render() override {
        std::cout << "渲染一个Windows风格的按钮" << std::endl;
    }

    void onClick() override {
        std::cout << "Windows按钮被点击" << std::endl;
    }
};

// Windows风格文本框
class WindowsTextBox : public TextBox {
public:
    void render() override {
        std::cout << "渲染一个Windows风格的文本框" << std::endl;
    }

    void setText(const std::string& text) override {
        std::cout << "Windows文本框设置文本: " << text << std::endl;
    }
};

// Mac风格按钮
class MacButton : public Button {
public:
    void render() override {
        std::cout << "渲染一个Mac风格的按钮" << std::endl;
    }

    void onClick() override {
        std::cout << "Mac按钮被点击" << std::endl;
    }
};

// Mac风格文本框
class MacTextBox : public TextBox {
public:
    void render() override {
        std::cout << "渲染一个Mac风格的文本框" << std::endl;
    }

    void setText(const std::string& text) override {
        std::cout << "Mac文本框设置文本: " << text << std::endl;
    }
};

// 抽象UI工厂
class UIFactory {
public:
    virtual ~UIFactory() = default;
    virtual std::unique_ptr<Button> createButton() = 0;
    virtual std::unique_ptr<TextBox> createTextBox() = 0;
};

// Windows UI工厂
class WindowsUIFactory : public UIFactory {
public:
    std::unique_ptr<Button> createButton() override {
        return std::make_unique<WindowsButton>();
    }

    std::unique_ptr<TextBox> createTextBox() override {
        return std::make_unique<WindowsTextBox>();
    }
};

// Mac UI工厂
class MacUIFactory : public UIFactory {
public:
    std::unique_ptr<Button> createButton() override {
        return std::make_unique<MacButton>();
    }

    std::unique_ptr<TextBox> createTextBox() override {
        return std::make_unique<MacTextBox>();
    }
};

// 客户端代码
class Application {
private:
    std::unique_ptr<UIFactory> factory_;

public:
    Application(std::unique_ptr<UIFactory> factory) : factory_(std::move(factory)) {}

    void createUI() {
        auto button = factory_->createButton();
        auto textbox = factory_->createTextBox();

        button->render();
        button->onClick();

        textbox->render();
        textbox->setText("Hello World");
    }
};

int main() {
    // 根据当前操作系统选择工厂
    #ifdef _WIN32
        auto factory = std::make_unique<WindowsUIFactory>();
    #else
        auto factory = std::make_unique<MacUIFactory>();
    #endif

    Application app(std::move(factory));
    app.createUI();

    return 0;
}
#+end_src

#+RESULTS: 抽象工厂模式
: 渲染一个Mac风格的按钮
: Mac按钮被点击
: 渲染一个Mac风格的文本框
: Mac文本框设置文本: Hello World
