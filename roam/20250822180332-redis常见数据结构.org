:PROPERTIES:
:ID:       e815c0a7-1496-4552-8a9f-aad4d4227fed
:END:
#+title: redis常见面试题
#+filetags: redis

* redis
基于内存的数据库，读写速度非常快，常用于：缓存、消息队列、分布式锁等场景


* redis常见5种数据结构
# redis所有数据结构都存储为字符串：文本、整数、浮点数、二进制数据
*String（字符串）*
1. 存储 字符串
2. 底层： =简单动态字符串(SDS)= 结构体：内部有个 len字段 用于表示字符串的结束，不同于C风格字符串'\0'
   1) 可以保存 二进制数据（优越点，原因在于 len字段）
   2) 获取字符串长度时间复杂度是 O(1)（优越点，原因在于 len字段）
   3) 不会造成缓冲区溢出：SDS在拼接字符串前会检查SDS空间是否满足要求，不够则扩容（优越点）

*List  （链表）*
1. 存储 *有序、可重复* 字符串
2. 底层： =压缩列表= 或 =双向链表= ：元素个数小于512个，每个元素小于64字节，使用压缩列表，否则 双向链表

*Set   （集合）*
1. 存储 *无序、不可重复* 字符串
2. 底层： =整数集合= 或 =哈希表= ：元素个数小于512个，使用整数集合，否则 哈希表

*Zset  （有序集合）*
1. 存储 *有序（按分数排序）、不可重复* 字符串
2. 底层： =压缩列表= 或 =跳表= ：元素个数小于128个，每个元素小于64字节，使用压缩列表，否则 跳表

*Hash  （哈希）*
1. 存储 *key-value集合* ：key 和 value 都是字符串
1. 底层： =压缩列表= 或 =哈希表= ：元素个数小于512个，每个元素小于64字节，使用压缩列表，否则 哈希表


* redis线程模型
*主线程* 采用IO多路复用模型 负责：网络IO、命令执行
后台3个 *辅助线程* ，负责：处理后台任务
- 文件关闭线程  :: 关闭文件描述符                -> 避免文件关闭操作阻塞主线程，提升主线程处理效率
- AOF刷盘线程   :: 将 AOF 缓冲区的数据刷写到磁盘 -> 在保证数据持久化的同时，减少对主线程的阻塞
- lazy free线程 :: 释放大键值对占用的内存        -> 避免删除大键时因同步释放内存导致主线程阻塞，保障 Redis 响应速度

主线程将 耗时操作（文件关闭、AOF 刷盘、大键释放）封装为任务，放入各个辅助线程对应任务队列；辅助线程各自监听专属队列，执行任务


* redis持久化
redis存储的数据都在内存中，为了保证内存中数据不丢失，需要持久化到磁盘，这样redis重启就能从磁盘恢复数据

*AOF日志*
记录的是写命令的日志，恢复数据慢（全量恢复时所有日志中的所有命令，逐一执行），具体来说 见：[[id:8c69d532-2c56-42ad-81eb-ae4893170435][图:AOF日志]]

*RDB快照*
记录的是某一瞬间内存中的全部数据，恢复数据快（直接加载就行，无需执行命令）；但是频率太低，丢失数据多，频率太高，影响性能

*混合持久化*
=混合持久化的AOF文件 = RDB格式数据 + AOF格式增量操作=
- 前半段 RDB格式数据    ：使得 redis 启动更快（RDB优点）
- 后半段 AOF格式增量操作：减少大量数据丢失风险（AOF优点）

** 图:AOF日志 :ATTACH:
:PROPERTIES:
:ID:       8c69d532-2c56-42ad-81eb-ae4893170435
:END:
[[attachment:_20250830_164507screenshot.png]]
1. redis执行写命令后，将命令追加到 server_aof_buf 缓冲区
2. 通过 write()系统调用 将 aof_buf缓冲区数据写入 AOF文件，然后拷贝 内核缓冲区的 [[id:5007d3f1-963b-48d3-88ff-261c4b4e454e][PageCache]]，等待内核将数据写入磁盘
3. 具体什么时候写入磁盘，由 redis的3种写回策略决定

*redis的3种写回策略* ：在 Redis.conf 中的 appendfsync 配置项
1. Always  ：同步写回，性能较差，最大程度不丢失数据
2. Everysec：每秒写回，性能适中，但可能宕机时丢失1秒内的数据
3. No      ：操作系统控制写回，性能好，但可能宕机时丢失很多数据


* redis集群（redis如何实现服务高可用？）
高可用的redis服务基于3个机制：主从复制、哨兵模式、切片集群
*主从复制* ：
1. 主服务器处理客户端写操作，并同步到从服务器；客户端可以从主服务器和从服务器进行读操作
2. 用于 数据备份、读写分离

*哨兵模式* ：
1. 用于 主从节点故障转移


*切片集群（redis cluster）*  ：
1. 一个切片集群有 16384个哈希槽（类似于数据分区），每个redis节点对应部分哈希槽，数据的key按照CRC16算法计算后再对 16384取模，映射到对应的哈希槽，再从哈希槽映射到对应的redis节点
2. 用于 减少系统对单个主节点依赖、灵活扩容
   - 减少系统对单个主节点依赖 :: 数据是分散到多个主节点的：1. 单个主节点资源压力（CPU、内存）小很多 2. 某个主节点故障，只影响它负责的数据
   - 灵活扩容                 :: 新增主节点只需要重新分配哈希槽，无需停止服务，缩容同理


* redis过期删除策略
每当我们对key设置过期时间，则key、过期时间会被存储到 *过期字典* ：查询key时，先看 过期字典，若不存在则正常读取键值；若存在则读取key的过期时间，判断是否过期，若过期则使用某种 *过期删除策略*

*过期删除策略* ：redis 使用 惰性删除+定期删除
- 惰性删除 :: 不主动删除，每次访问key时，检测key是否过期，若过期则删除 -> 对CPU时间友好，对内存不友好
  #+begin_comment
  对CPU友好   ：每次访问key时，才检查key是否过期
  对内存不友好：若key过期，但一直没被访问，则一直占用内存
  #+end_comment
- 定期删除 :: 每隔一段时间 随机从数据库取出一定数量的key进行检查，删除过期key -> 对内存时间友好，对CPU不友好
  #+begin_comment 流程
  1. 过期字典中随机抽N个key，检查是否过期，过期则删除
  2. 若本次检查的key里超过 25% 过期，则重复 1.；否则停止
  #+end_comment

*持久化时，过期键处理策略* ：
RDB：
1. RDB文件生成：过期key不会保存到RDB文件
2. RDB文件加载：
   主服务器 -> 不会加载过期key
   从服务器 -> 无论是否过期都加载，后续从主服务器同步数据

AOF：
1. AOF文件写入：过期key未被删除，写入AOF文件，当过期key删除后，redis向AOF文件追加一条DEL命令显式删除
2. AOF重写：不会保存 过期key 到重写后的AOF文件

*主从模式，过期键处理策略* ：同上边RDB文件加载的处理方式


* redis内存淘汰策略
- noeviction      :: （redis3.0后默认）运行内存超过最大设置内存时，不淘汰数据，直接返回错误

设置过期时间的数据范围内淘汰
- volatile-random :: 随机淘汰
- volatile-ttl    :: 淘汰最早过期
- volatile-lru    :: （redis3.0前默认）淘汰最久未使用
- volatile-lfu    :: （redis3.0后新增）淘汰最少使用

所有数据范围内淘汰
- allkeys-random  :: 随机淘汰
- allkeys-lru     :: 淘汰最久未使用
- allkeys-lfu     :: 淘汰最少使用

*LRU*
*LFU*


* 缓存雪崩、缓存击穿、缓存穿透
*缓存雪崩*
1. 大量缓存数据同一时间过期；此时大量用户请求redis无法处理，导致数据库压力骤增，严重可能导致数据库宕机
2. 解决：
   1) 缓存随机失效时间
   2) 设置缓存不过期

*缓存击穿*
1. 某个热点缓存数据过期
2. 解决：
   1) 设置热点数据缓存不过期
   2) 互斥锁？

*缓存穿透*
1. 用户访问的数据既不在缓存也不在数据库（缓存雪崩、缓存击穿 因为数据库有数据，可以通过恢复缓存来减少数据库压力，缓存 穿透则不行）
2. 解决：
   1) 缓存中设置 空值 或 默认值
   2) 非法请求限制？
   3) 布隆过滤器？


* 缓存更新策略
常见的有3种：Cache Aside（旁路缓存）、Read/Write Through（读穿/写穿）、Write Back（写回）

*Cache Aside（旁路缓存）*
- 读策略：命中缓存，直接返回数据；否则，先读数据库，再写缓存，再返回用户
- 写策略：先写入数据库，再删除缓存


* 用redis实现一个分布式锁
