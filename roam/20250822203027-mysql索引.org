:PROPERTIES:
:ID:       0ef04dce-3931-4446-80fc-69e37e960fc0
:END:
#+title: mysql索引
#+filetags: mysql

*索引* ：相当于数据的目录，提高数据查询速度但是占用空间；典型的用空间换时间

* 索引分类
按 *数据结构* 分：B+树索引、Hash索引、Full-text索引
- B+树索引      :: InnoDB 使用的 索引数据结构；见：[[id:41464314-4d01-41bb-a343-75fbd8d39c87][为什么InnoDB选择B+树作为索引的数据结构？]]
- Hash索引      ::
- Full-text索引 ::

# 字段 = 列
按 *物理存储* 分：聚簇索引（主键索引）、二级索引（辅助索引）
- 聚簇索引 :: 非叶子节点是索引，叶子节点是记录
- 二级索引 :: 非叶子节点是索引，叶子节点是主键
  若二级索引能查到想要结果，则称 *索引覆盖* ，否则通过二级索引查到的主键再查询聚簇索引，这个过程称为 *回表*

按 *字段特性* 分：主键索引、唯一索引、普通索引、前缀索引
- 主键索引 :: 唯一非空，一张表仅一个（是聚簇索引）
- 唯一索引 :: 唯一可空，一张表可多个
- 普通索引 :: 无约束；仅用于加速查询
- 前缀索引 :: 对字段前N个字符建立索引；节省索引占用空间

按 *字段个数* 分：单列索引、联合索引
- 单列索引 :: 单个字段上的索引
- 联合索引 :: 多个字段组合成一个索引，遵循 *最左匹配原则*
  #+begin_example 最左匹配原则
  创建一个 （a，b，c）的联合索引
  可以匹配的情况：
  where a = 1;
  where a = 1 and b = 2 and c = 3;
  where a = 1 and b = 2;

  不能匹配的情况：
  where b = 2；
  where c = 3;
  where b = 2 and c = 3;
  #+end_example


* 为什么InnoDB选择B+树作为索引的数据结构？
:PROPERTIES:
:ID:       41464314-4d01-41bb-a343-75fbd8d39c87
:END:
*B树* ：
1. 叶子、非叶子节点都要存储数据；B+树只在叶子节点存储数据，非叶子节点就能容纳更多索引，因此树更加"矮胖"，需要 *磁盘IO的次数* 更少
2. 同一层节点之间没有链表连接，范围查找需要对树多次中序遍历，磁盘IO次数 更多；B+树 叶子节点之间通过双向链表相互连接，通过顺序IO进行 *范围查找* 效率更高

*二叉树* ：
原因类似B树，"高瘦"且同一层节点没有链表连接，磁盘IO次数更高

*Hash* ：
等值查询效率很高（O(1)），但不适合范围查询


* 什么时候需要/不需要创建索引？
*需要索引* ：
1. 字段唯一性限制（PRIMARY 或 UNIQUE）；eg：商品编码
2. 常用 WHERE 查询条件的字段
3. 常用 GROUP BY 和 ORDER BY 的字段

*不需要索引* ：
1. WHERE条件、GROUP BY、ORDER BY 里用不到的字段
   # 索引是用于快速定位，起不到定位的字段不需要创建索引
2. 存在大量重复数据的字段；eg：性别
3. 经常更新的字段；eg：电商项目用户余额
   # 索引字段频繁修改，为了保持B+树的有序性，需要频繁重建索引，影响数据库性能
4. 表数据太少


* 什么时候索引会失效？
:PROPERTIES:
:ID:       e3fe9403-ff44-4eb7-a10e-67e4db973455
:END:
核心原因：索引就是数据的目录，失效的本质在于我们查询方法无法利用这个目录，导致数据库搜索所有数据（全表扫描）
1. % *模糊匹配*
2. 查询条件中对索引列 *计算、函数* ，eg：WHERE age+1=30、WHERE SUBSTR(name,1,1)='A'
3. *联合索引* 没有遵循 最左匹配原则，eg：联合索引 (a,b,c)，仅用 b/c 过滤
4. *WHERE中使用OR连接非索引列* ，eg：WHERE a=1 OR b=2，b为非索引列
5. *索引列使用不等于* ：!=、<、>、NOT IN、IS NOT NULL
6. *全表扫描比索引快* ，eg：表数据量极小


* 优化索引的方法？
1. *[[id:e3fe9403-ff44-4eb7-a10e-67e4db973455][防止索引失效]]*
2. *前缀索引* ：使用字段中字符串的前几个字符建立索引
3. *覆盖索引* ：避免回表操作，使用联合索引
4. *主键索引最好是自增的* ：每次插入数据都是追加的，页面满时开辟新页，不需要重新移动数据，只能按顺序插入数据不能在中间插入；非自增索引可以在中间插入，但可能引发 页分裂；见：[[id:96c16662-4e2e-43cf-aea1-b254580fa098][图:页分裂]]
5. *索引最好设为 NOT NULL* ：占用空间 -> 允许字段有NULL值，则 行格式中至少会用 1字节存储 NULL值列表

** 图:页分裂 :ATTACH:
:PROPERTIES:
:ID:       96c16662-4e2e-43cf-aea1-b254580fa098
:END:
非自增主键：页分裂情况
[[attachment:_20250828_165137screenshot.png]]

自增主键：页大小不够时
[[attachment:_20250828_165430screenshot.png]]
