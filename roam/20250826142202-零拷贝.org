:PROPERTIES:
:ID:       38a82890-b4b8-4985-978d-7e9dff72a291
:END:
#+title: 零拷贝
#+filetags: operating_system

* 零拷贝 [[https://xiaolincoding.com/os/8_network_system/zero_copy.html#_9-1-%E4%BB%80%E4%B9%88%E6%98%AF%E9%9B%B6%E6%8B%B7%E8%B4%9D][小林coding]]
通过减少 =CPU上下文切换次数= （用户态/内核态）、 =数据拷贝次数= 来提高 *文件传输* 性能（相较于 [[id:a8a0a3ed-b99d-4638-9530-0fdb0c815676][传统文件传输]]）

具体2种方法：
# 传统拷贝：read + write，4次拷贝 + 4次上下文切换
1. mmap + write： =3次拷贝 + 4次上下文切换=
2. sendfile    ： =3次拷贝 + 2次上下文切换= ；在支持 SG-DMA 的网卡中使用sendfile， =2次拷贝 + 2次上下文切换= （全程没有CPU参与，这是真正的零拷贝技术）

*注* ：这里的内核缓冲区是指 [[id:5007d3f1-963b-48d3-88ff-261c4b4e454e][PageCache]]

** 方法1: mmap + write :ATTACH:
:PROPERTIES:
:ID:       5e2d966e-25e2-449a-bae7-94af7f42231b
:END:
#+begin_example C
buf = mmap(file, len);
write(sockfd, buf, len);
#+end_example
[[attachment:_20250826_153906screenshot.png]]
1. 进程调用 mmap() 将 内核缓冲区 映射到 进程的用户缓冲区（后续在用户缓冲区的操作同步到内核缓冲区，相比传统文件传输的好处： *数据拷贝不需要经过用户缓冲区* ）
2. 通过 DMA 将磁盘数据 *拷贝* 到内核缓冲区（PageCache）
3. 进程调用 write() ，CPU 将数据 *拷贝* 到 内核的socket缓冲区
4. 通过 DMA 将内核缓冲区数据 *拷贝* 到 网卡
3次拷贝 + 4次上下文切换（用户态内核态切换）

** 方法2: sendfile
#+begin_example C
ssize_t sendfile(int out_fd, int in_fd, off_t* offset, size_t count);
#+end_example
sendfile 用于在内核态中拷贝数据

*** 图:sendfile :ATTACH:
:PROPERTIES:
:ID:       f45b2383-983a-4389-85bc-00cbf975eeca
:END:
[[attachment:_20250826_155042screenshot.png]]
3次拷贝 + 2次上下文切换（用户态内核态切换）

*** 图:网卡支持SG-DMA的sendfile :ATTACH:
:PROPERTIES:
:ID:       94e2ca69-cd07-40a2-9a43-4c0526fbbbdd
:END:
[[attachment:_20250826_155215screenshot.png]]
1. DMA 将磁盘数据拷贝到 内核缓冲区
2. 缓冲区fd和数据长度 传到 socket缓冲区
3. 网卡的 SG-DMA控制器 将内核缓冲区数据 拷贝到 网卡缓冲区
全程没有CPU参与
2次拷贝 + 2次上下文切换（用户态内核态切换）


* 传统文件传输 :ATTACH:
:PROPERTIES:
:ID:       a8a0a3ed-b99d-4638-9530-0fdb0c815676
:END:
#+begin_example C
read(file, tmp_buf, len);
write(socket, tmp_buf, len);
#+end_example
[[attachment:_20250826_152130screenshot.png]]
4次拷贝 + 4次上下文切换（用户态内核态切换）


* DMA技术
# 直接内存访问
用于在 *I/O设备和内核缓冲区之间传输数据，无需 CPU 参与* -> 解放 CPU
#+begin_comment
现代设备       ：I/O设备（eg：网卡、显卡、硬盘） 一般内置自己的专用DMA控制器
传统/嵌入式设备：系统中有一个中央的公用的DMA控制器
#+end_comment

** 有无DMA控制器的I/O过程
# 以 read() 为例
*无DMA控制器* ：
1. 进程调用 read()，阻塞： *用户态 -> 内核态*
2. CPU 发出IO请求给 磁盘控制器
3. 磁盘控制器 将数据 *拷贝* 磁盘控制器内部的缓冲区中，发出中断通知 CPU
4. CPU 从磁盘控制器的缓冲区中的数据 *拷贝* 到 PageCache（这个期间 CPU 无法执行其他任务）
5. CPU 将数据从 PageCache *拷贝* 到 用户缓冲区         （这个期间 CPU 无法执行其他任务）
6. 从 read() 返回： *内核态 -> 用户态*

*有DMA控制器* ：
1. 进程调用 read()，阻塞： *用户态 -> 内核态*
2. CPU 发出IO请求给 DMA控制器，返回；DMA控制器 发出IO请求给 磁盘控制器
3. 磁盘控制器 将数据 *拷贝* 磁盘控制器内部的缓冲区中，通知 DMA控制器
4. DMA控制器 从磁盘控制器的缓冲区中 *拷贝* 到 PageCache，通知 CPU
5. CPU 将数据从 PageCache *拷贝* 到 用户缓冲区
6. 从 read() 返回： *内核态 -> 用户态*

* 小/大文件传输方式选择？
小文件：零拷贝技术
大文件：异步IO + 直接IO
#+begin_comment
零拷贝技术要走 PageCache，PageCache 是用于存放常访问的页面，传输小文件还好，传输大文件就会占满 PageCache，大文件要么直接给用户使用，要么从网卡发出去，这导致 PageCache 功能无效化。
假设传输大文件使用 零拷贝，则大文件会占满 PageCache，导致无法用到缓存，增大性能开销
异步IO 不涉及 PageCache，具体见：[[roam:图:同步、异步读]]
#+end_comment
