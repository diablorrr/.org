:PROPERTIES:
:ID:       3c8eb7cf-68ed-4359-8e3f-f7c620b49fc0
:END:
#+title: mysql事务
#+filetags: mysql

* mysql事务 [[https://xiaolincoding.com/mysql/transaction/mvcc.html#%E4%BA%8B%E5%8A%A1%E6%9C%89%E5%93%AA%E4%BA%9B%E7%89%B9%E6%80%A7][小林coding]]
*mysql事务* ：数据库操作的 *最小执行单元* （包含一个或多个SQL语句），要么全部执行成功，要么全部执行失败
# mysql原生的 MyISAM引擎 不支持事务

*事务特性* ：原子性（A）、一致性（C）、隔离性（I）、持久性（D）
| 特性   | 说明                                                           | 如何实现                       |
|--------+----------------------------------------------------------------+--------------------------------|
| 原子性 | 一个事务的所有操作，要么全部完成，要么全部不完成               | undo log                       |
| 一致性 | 事务前后数据库状态一致                                         | 通过 持久性+原子性+隔离性 实现 |
| 隔离性 | 数据库允许多个并发事务同时对数据进行读写和修改，且不会相互干扰 | MVCC 或 锁机制 实现            |
| 持久性 | 事务结束后，对数据的修改就是永久的。就算系统故障也不会丢失     | redo log                       |
- undo log :: 回滚日志
- redo log :: 重做日志
- MVCC     :: 多版本并发控制


* 事务隔离性
事务隔离性：数据库允许多个事务并发访问数据

*事务并发访问引发的问题* ：
（按严重性排序：高 -> 低）
- 脏读       :: 读到其他事务未提交的数据
- 不可重复读 :: 一个事务中多次读取同一数据，前后读到的数据不一致
- 幻读       :: 一个事务中多次查询某个符合条件的记录数量，前后读到的数量不一致

因此 SQL标准提出了 4种隔离级别，隔离级别越高，性能效率越低

*事务隔离级别* ：
（按隔离级别排序：低 -> 高，级别越高性能越低）
| 隔离级别 | 说明                             | 解决的问题             | 实现方式                                          |
|----------+----------------------------------+------------------------+---------------------------------------------------|
| 读未提交 | 可以读到其他事务未提交数据       |                        | 直接读最新数据                                    |
| 读提交   | 可以读到其他事务提交数据         | 脏读                   | 每次读取数据时生成一个新的 Read View              |
| 可重复读 | 事务执行中看到的数据和启动时一致 | 脏读、不可重复读       | 启动事务时 生成一个 Read View，整个事务期间都在用 |
| 串行化   | 通过锁机制强制事务串行执行       | 脏读、不可重复读、幻读 | 锁机制                                            |
（MySQL InnoDB引擎 默认的隔离级别：可重复读）

*两种开启事务的方式* ：
1. begin/start transaction                   ：执行这条命令后，再执行第一条 select语句，事务开启
2. start transaction with consistent snapshot：执行这条命令后，事务开启

** 图:四种隔离级别示例 :ATTACH:
:PROPERTIES:
:ID:       fe05559c-4b0d-4951-af21-9099943f08ce
:END:
[[attachment:_20250828_194857screenshot.png]]
- 读未提交 隔离级别下：事务 B 修改余额后，虽然没有提交事务，但是此时的余额已经可以被事务 A 看见了，于是事务 A 中余额 V1 查询的值是 200 万，余额 V2、V3 自然也是 200 万了；
- 读提交 隔离级别下  ：事务 B 修改余额后，因为没有提交事务，所以事务 A 中余额 V1 的值还是 100 万，等事务 B 提交完后，最新的余额数据才能被事务 A 看见，因此额 V2、V3 都是 200 万；
- 可重复读 隔离级别下：事务 A 只能看见启动事务时的数据，所以余额 V1、余额 V2 的值都是 100 万，当事务 A 提交事务后，就能看见最新的余额数据了，所以余额 V3 的值是 200 万；
- 串行化 隔离级别下  ：事务 B 在执行将余额 100 万修改为 200 万时，由于此前事务 A 执行了读操作，这样就发生了读写冲突，于是就会被锁住，直到事务 A 提交后，事务 B 才可以继续执行，所以从 A 的角度看，余额 V1、V2 的值是 100 万，余额 V3 的值是 200 万。


* 如何解决脏读、不可重复读、幻读问题？
可重复读隔离级别 解决 脏读、不可重复读（通过 MVCC机制 解决）
MVCC机制         解决 快照读 场景下的 幻读
锁机制           解决 当前读 场景下的 幻读
- 快照读 :: 读历史快照
- 当前读 :: 读最新数据


* MVCC
MVCC机制 解决 *可重复读隔离级别下快照读* 中的问题（eg：脏读、不可重复读、幻读）
- 快照读 :: 读取历史快照

*Read View* ：事务快照结构；事务创建时，内存中临时生成的一个数据结构，事务结束后就销毁；有以下4个字段
- creator_trx_id :: 创建该 Read View 的事务的事务ID
- m_ids          :: 创建 Read View 时，已启动但未提交的事务ID列表
- min_trx_id     :: 创建 Read View 时，m_ids中的最小值（已启动但未提交的事务ID列表 中 最小的事务ID）
- max_trx_id     :: 创建 Read View 时，系统即将分配给下一个新事务的事务ID，也就是 =全局事务中最大的事务ID + 1=
见：[[id:3e9e5c9f-a1db-4a6c-b921-f2a33b2abbcc][图:Read View结构、COMPACT行结构中的隐藏列、MVCC原理]]

*MVCC（多版本并发控制）原理* ：通过 =版本链、Read View= 来控制并发事务访问同一个记录时的行为；见：[[id:3e9e5c9f-a1db-4a6c-b921-f2a33b2abbcc][图:Read View结构、COMPACT行结构中的隐藏列、MVCC原理]]

** 图:Read View结构、COMPACT行结构中的隐藏列、MVCC原理 :ATTACH:
:PROPERTIES:
:ID:       3e9e5c9f-a1db-4a6c-b921-f2a33b2abbcc
:END:
*COMPACT行结构中的隐藏列* ：
[[attachment:_20250828_201747screenshot.png]]
1. trx_id      ：改动该行记录的事务ID
2. roll_pointer：一个指向旧版本记录的指针 -> 每次对记录改动时，会将旧版本记录写入 undo日志，并将 roll_pointer 执行它（通过它我们能找到旧版本记录）

*Read View结构* ：
[[attachment:_20250828_200921screenshot.png]]

*MVCC原理* ：
[[attachment:_20250828_200928screenshot.png]]
一个事务访问记录时
1. 自己更新的记录， *可见*
2. =（记录的 trx_id）<  （Read View的 min_trx_id）= ， *可见*   （说明该版本的记录是由创建 Read View 前 已提交的事务生成）
3. =（记录的 trx_id）>​= （Read View的 max_trx_id）= ， *不可见* （说明该版本的记录是由创建 Read View 后 启动的事务生成）
4. =（Read View的 min_trx_id）<=（记录的 trx_id）<（Read View的 max_trx_id）= -> *对应 m_ids 部分*
   - 记录的 trx_id *在*   Read View的 m_ids列表 中， *不可见* （说明生成该版本记录的事务还在运行且未提交）
   - 记录的 trx_id *不在* Read View的 m_ids列表 中， *可见*   （说明生成该版本记录的事务还在运行且提交）


* 可重复读是如何工作的？
*可重复读* ：启动事务时生成一个 Read View，整个事务期间都在用这个 Read View
具体示例见：[[https://xiaolincoding.com/mysql/transaction/mvcc.html#%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84][小林coding]]


* 读提交是如何工作的？
*读提交* ：每次读取数据时 生成一个新的 Read View
具体示例见：[[https://xiaolincoding.com/mysql/transaction/mvcc.html#%E8%AF%BB%E6%8F%90%E4%BA%A4%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84][小林coding]]
