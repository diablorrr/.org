:PROPERTIES:
:ID:       58957271-3fa8-40bc-9140-010e1c8eb91e
:END:
#+title: mysql锁
#+filetags: mysql

* mysql锁 [[https://xiaolincoding.com/mysql/lock/mysql_lock.html#%E5%85%A8%E5%B1%80%E9%94%81][小林coding]]
锁机制 解决 *可重复读隔离级别下当前读* 中的问题（eg：脏读、不可重复读、幻读）
- 当前读 :: 读取最新数据

读锁 = 共享锁
写锁 = 独占锁
表级锁 和 行级锁 -> 读读共享，读写互斥，写写互斥（互斥就是冲突的意思）
** 全局锁
*全局锁*
- 作用       :: 让所有数据库的所有表处于"只读"状态
- 加锁时机   :: 否
- 锁释放时机 :: 手动 或 会话结束
- 使用场景   :: 常用于 MyISAM存储引擎 全量备份（InnoDB存储引擎这种支持「可重复读隔离级别的事务」，推荐用 mysqldump --single-transaction 基于 MVCC 实现 “无锁全量备份”，无需依赖全局锁，避免阻塞业务写操作）
- 缺点       :: 数据库数据量大，备份需要很多时间，而备份期间只能读取数据，不能加数据，造成业务停滞
#+begin_example mysql
flush tables with read lock // 加全局锁
unlock tables               // 解全局锁
#+end_example

** 表级锁
*表锁*
- 作用       :: 防止当前会话 CRUD 数据时，其他会话 CRUD *数据*
  具体来说：可以用读锁或写锁锁定整张表；限制当前会话只能根据「锁的类型」访问该表数据，且不能访问其他未锁定的表
- 加锁时机   :: 手动
- 锁释放时机 :: 手动 或 会话结束
- 缺点       :: 锁的粒度太大
#+begin_example mysql
lock tables t_student read; // 读锁，也就是 表级别的共享锁
                            // 当前会话 可读不可写；上锁期间只能读该表，不能读其他表
                            // 其他会话 可读不可写（会话就是当前的连接，线程只是处理会话请求的临时工）

lock tables t_stuent write; // 写锁，也就是 表级别的独占锁
                            // 当前会话 可读写；上锁期间只能读写该表，不能读写其他表
                            // 其他会话 不可读写

unlock tables               // 解所有表锁
#+end_example

*元数据锁（MDL）*
- 作用       :: 防止当前会话 CRUD 数据时，其他会话修改 *表结构*
  具体来说：
  1. CRUD表中数据，自动加 MDL读锁
  2. 修改表结构时，自动加 MDL写锁
- 加锁时机   :: （涉及表操作）自动加锁
- 锁释放时机 :: 事务提交后

*意向锁*
- 作用 :: 快速判断表里是否有记录被加锁

*自增锁（AUTO-INC锁）*
- 作用 :: 在并发插入时，确保自增主键的唯一性和连续性
  具体来说：在插入数据时，加一个表级别的 自增锁，为  AUTO-INCREMENT修饰的字段 递增值，语句完成，释放 自增锁

** 行级锁
# InnoDB引擎支持，MyISAM引擎不支持
*记录锁（Record Lock）*
1. 在一条记录上加锁，用于解决可重复读隔离级别下的 写冲突 问题
2. 分为 读锁、写锁

*间隙锁（Gap Lock）*
1. 在一个范围加锁，但不包含记录本身，防止数据插入到这个范围内，用于解决 可重复读隔离级别下的 幻读 问题
#+begin_example
锁 (5, 10)
此范围内无法插入新数据，解决 可重复读隔离级别下 当前读场景下 幻读 问题
#+end_example

*Next-Key锁*
1. 在一个范围加锁，且包含记录本身（Record Lock + Gap Lock），防止数据插入到这个范围，用于解决可重复读隔离级别下的 写冲突、幻读 问题
#+begin_example
(5, 10]
此范围内无法插入新数据，也无法修改 10，解决 可重复读隔离级别下 当前读场景下 幻读、写冲突 问题
#+end_example

*插入意向锁*
1. 往同一间隙插数据的多个事务，只要插的位置不重叠，就能同时插入，就无需排队等锁，提高并发效率
   #+begin_example
   假设表中有数据 id=10 和 id=20，中间有个 间隙（10,20）
   - 事务 A 想插 id=15，会先尝试在（10,20）间隙加 插入意向锁，若该间隙没被其他事务上间隙锁，则插数据，否则阻塞，等待间隙锁释放
   - 同时事务 B 想插 id=18，也会检查（10,20）间隙的锁：发现 A 的插入位置（15）和自己的（18）不冲突，就也能加 插入意向锁，和 A 同时插，不用等 A 插完
   - 但如果事务 C 想插 id=15（和 A 位置重叠），就会被 A 的锁挡住，必须等 A 结束才能插。
   #+end_example

